import { isObject } from "./lib/object.js";
import { getKnownProperties, resolveRef, getSimpleSchemaType, isSchema, isSchemaObjectValue, isSchemaArrayValue, isSelect, getClosestMatchingOption, getDiscriminatorFieldFromSchema, } from "./core/index.js";
export function omitExtraData(validator, merger, rootSchema, value) {
    function handleObject(schema, source, target) {
        const { properties, additionalProperties, patternProperties, propertyNames, } = schema;
        function setProperty(key, schemaDef, value) {
            const v = omit(schemaDef, value, target[key]);
            if (v !== undefined) {
                target[key] = v;
            }
        }
        if (properties !== undefined) {
            for (const [key, schema] of Object.entries(properties)) {
                setProperty(key, schema, source[key]);
            }
        }
        let patternPropertiesRest;
        if (patternProperties !== undefined) {
            patternPropertiesRest = [];
            const patterns = Object.entries(patternProperties).map(([pattern, schemaDef]) => [
                new RegExp(pattern),
                schemaDef,
            ]);
            const knownProperties = new Set(getKnownProperties(schema, rootSchema));
            for (const [key, value] of Object.entries(source)) {
                if (knownProperties.has(key)) {
                    continue;
                }
                const found = patterns.find((e) => e[0].test(key));
                if (found === undefined) {
                    patternPropertiesRest.push(key);
                    continue;
                }
                setProperty(key, found[1], value);
            }
        }
        if (additionalProperties !== undefined && additionalProperties !== false) {
            if (patternPropertiesRest !== undefined) {
                for (const key of patternPropertiesRest) {
                    setProperty(key, additionalProperties, source[key]);
                }
            }
            else {
                const knownProperties = new Set(getKnownProperties(schema, rootSchema));
                for (const [key, value] of Object.entries(source)) {
                    if (knownProperties.has(key)) {
                        continue;
                    }
                    setProperty(key, additionalProperties, value);
                }
            }
        }
        if (propertyNames !== undefined) {
            for (const [key, value] of Object.entries(source)) {
                target[key] = value;
            }
        }
        return target;
    }
    function handleArray(schema, source, target) {
        const { items, additionalItems } = schema;
        if (items !== undefined) {
            if (Array.isArray(items)) {
                for (let i = 0; i < items.length; i++) {
                    target.push(omit(items[i], source[i]));
                }
            }
            else {
                for (let i = 0; i < source.length; i++) {
                    target.push(omit(items, source[i]));
                }
            }
        }
        if (additionalItems) {
            for (let i = target.length; i < source.length; i++) {
                target.push(omit(additionalItems, source[i]));
            }
        }
        return target;
    }
    function handleConditions(schema, source, target) {
        const { if: condition, then, else: otherwise } = schema;
        if (condition === undefined) {
            return target;
        }
        const isThenBranch = isSchema(condition)
            ? validator.isValid(condition, rootSchema, source)
            : condition;
        const branch = isThenBranch ? then : otherwise;
        return branch === undefined ? target : omit(branch, source, target);
    }
    function handleOneOf(oneOf, schema, source, target) {
        if (!Array.isArray(oneOf) ||
            isSelect(validator, merger, schema, rootSchema)) {
            return target;
        }
        const bestIndex = getClosestMatchingOption(validator, merger, rootSchema, source, oneOf.map((d) => (isSchema(d) ? d : d ? {} : { not: {} })), 0, getDiscriminatorFieldFromSchema(schema));
        return omit(oneOf[bestIndex], source, target);
    }
    function handleAllOf(allOf, source, target) {
        if (!Array.isArray(allOf)) {
            return target;
        }
        for (let i = 0; i < allOf.length; i++) {
            target = omit(allOf[i], source, target);
        }
        return target;
    }
    function handleAnyOf(schema, source, target) {
        const { anyOf } = schema;
        if (!Array.isArray(anyOf)) {
            return target;
        }
        if (source === undefined ||
            (isObject(source) &&
                (Array.isArray(source)
                    ? source.length === 0
                    : Object.keys(source).length === 0))) {
            return handleAllOf(anyOf, source, target);
        }
        return handleOneOf(anyOf, schema, source, target);
    }
    function handleDependencies(schema, source, target) {
        const { dependencies } = schema;
        if (dependencies === undefined || !isSchemaObjectValue(source)) {
            return target;
        }
        for (const [key, deps] of Object.entries(dependencies)) {
            if (!(key in source) || Array.isArray(deps)) {
                continue;
            }
            target = omit(deps, source, target);
        }
        return target;
    }
    function omit(schema, source, target) {
        if (source === undefined || schema === false) {
            return source;
        }
        if (schema === true) {
            return target;
        }
        const { $ref: ref } = schema;
        if (ref !== undefined) {
            return omit(resolveRef(ref, rootSchema), source, target);
        }
        target = handleAnyOf(schema, source, handleAllOf(schema.allOf, source, handleOneOf(schema.oneOf, schema, source, target)));
        const type = getSimpleSchemaType(schema);
        if (type === "object") {
            if (!isSchemaObjectValue(source)) {
                return undefined;
            }
            target = handleObject(schema, source, isSchemaObjectValue(target) ? target : {});
        }
        else if (type === "array") {
            if (!isSchemaArrayValue(source)) {
                return undefined;
            }
            target = handleArray(schema, source, isSchemaArrayValue(target) ? target : []);
        }
        else if (target === undefined) {
            target = source;
        }
        return handleDependencies(schema, source, handleConditions(schema, source, target));
    }
    return omit(rootSchema, value);
}
