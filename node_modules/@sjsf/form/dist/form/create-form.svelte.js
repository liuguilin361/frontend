import { SvelteMap } from "svelte/reactivity";
import { on } from "svelte/events";
import { createDataURLtoBlob } from "../lib/file.js";
import { abortPrevious, createAction, } from "../lib/action.svelte.js";
import { isFormValueValidator, isFieldValueValidator, isAsyncFormValueValidator, isAsyncFieldValueValidator, } from "./validator.js";
import { createTranslate } from "./translation.js";
import { resolveUiRef, } from "./ui-schema.js";
import { groupErrors, ValidationProcessError, } from "./errors.js";
import {} from "./context/index.js";
import { createFormMerger } from "./merger.js";
import { DEFAULT_ID_PREFIX, DEFAULT_ID_PSEUDO_SEPARATOR, DEFAULT_ID_SEPARATOR, } from "./id.js";
export const DEFAULT_FIELDS_VALIDATION_DEBOUNCE_MS = 300;
const UI_OPTIONS_REGISTRY_KEY = "uiOptionsRegistry";
export function createForm(options) {
    const merger = $derived(options.merger ?? createFormMerger(options.validator, options.schema));
    let value = $state(
    // svelte-ignore state_referenced_locally
    merger.mergeFormDataAndSchemaDefaults(options.initialValue, options.schema));
    let errors = $state.raw(Array.isArray(options.initialErrors)
        ? groupErrors(options.initialErrors)
        : new SvelteMap(options.initialErrors));
    let isSubmitted = $state.raw(false);
    let isChanged = $state.raw(false);
    const fieldsValidationMode = $derived(options.fieldsValidationMode ?? 0);
    const uiSchemaRoot = $derived(options.uiSchema ?? {});
    const uiSchema = $derived(resolveUiRef(uiSchemaRoot, options.uiSchema) ?? {});
    const disabled = $derived(options.disabled ?? false);
    const schedulerYield = $derived((options.schedulerYield ??
        (typeof scheduler !== "undefined" && "yield" in scheduler))
        ? scheduler.yield.bind(scheduler)
        : ({ signal }) => new Promise((resolve, reject) => {
            setTimeout(() => {
                if (signal.aborted) {
                    reject(signal.reason);
                }
                else {
                    resolve();
                }
            }, 0);
        }));
    const dataUrlToBlob = $derived(createDataURLtoBlob(schedulerYield));
    const getSnapshot = $derived(options.getSnapshot ?? (() => $state.snapshot(value)));
    const translate = $derived(createTranslate(options.translation));
    const validateForm = $derived.by(() => {
        const v = options.validator;
        if (isAsyncFormValueValidator(v)) {
            return (signal, schema, formValue) => v.validateFormValueAsync(signal, schema, formValue);
        }
        if (isFormValueValidator(v)) {
            return (_, schema, formValue) => Promise.resolve(v.validateFormValue(schema, formValue));
        }
        return async () => Promise.resolve([]);
    });
    const submission = createAction({
        async execute(signal, _event) {
            isSubmitted = true;
            const formValue = getSnapshot(context);
            return {
                formValue,
                formErrors: groupErrors(await validateForm(signal, options.schema, formValue)),
            };
        },
        onSuccess({ formValue, formErrors }, event) {
            errors = formErrors;
            if (errors.size === 0) {
                options.onSubmit?.(formValue, event);
                isChanged = false;
                return;
            }
            options.onSubmitError?.(formErrors, event, formValue);
        },
        onFailure(error, e) {
            errors.set(context.rootId, [
                {
                    propertyTitle: "",
                    message: translate("validation-process-error", { error }),
                    error: new ValidationProcessError(error),
                },
            ]);
            options.onSubmissionFailure?.(error, e);
        },
        get combinator() {
            return options.submissionCombinator;
        },
        get delayedMs() {
            return options.submissionDelayedMs;
        },
        get timeoutMs() {
            return options.submissionTimeoutMs;
        },
    });
    const validateFields = $derived.by(() => {
        const v = options.validator;
        if (isAsyncFieldValueValidator(v)) {
            return (signal, config, value) => v.validateFieldValueAsync(signal, config, value);
        }
        if (isFieldValueValidator(v)) {
            return (_, config, value) => Promise.resolve(v.validateFieldValue(config, value));
        }
        return () => Promise.resolve([]);
    });
    const fieldsValidation = createAction({
        execute(signal, config, value) {
            const debounceMs = options.fieldsValidationDebounceMs ?? 300;
            if (debounceMs < 0) {
                return validateFields(signal, config, value);
            }
            const promise = Promise.withResolvers();
            const id = setTimeout(() => {
                promise.resolve(validateFields(signal, config, value));
            }, debounceMs);
            const onAbort = () => {
                clearTimeout(id);
                promise.reject(new DOMException("field validation has been aborted", "AbortError"));
            };
            signal.addEventListener("abort", onAbort);
            return promise.promise.finally(() => {
                signal.removeEventListener("abort", onAbort);
            });
        },
        onSuccess(fieldErrors, config) {
            if (fieldErrors.length > 0) {
                errors.set(config.id, fieldErrors);
            }
            else {
                errors.delete(config.id);
            }
        },
        onFailure(error, config, value) {
            if (error.reason !== "aborted") {
                errors.set(config.id, [
                    {
                        propertyTitle: config.title,
                        message: translate("validation-process-error", { error }),
                        error: new ValidationProcessError(error),
                    },
                ]);
            }
            options.onFieldsValidationFailure?.(error, config, value);
        },
        get combinator() {
            return options.fieldsValidationCombinator ?? abortPrevious;
        },
        get delayedMs() {
            return options.fieldsValidationDelayedMs;
        },
        get timeoutMs() {
            return options.fieldsValidationTimeoutMs;
        },
    });
    function submitHandler(e) {
        e.preventDefault();
        submission.run(e);
    }
    function resetHandler(e) {
        e.preventDefault();
        isSubmitted = false;
        isChanged = false;
        errors.clear();
        value = merger.mergeFormDataAndSchemaDefaults(options.initialValue, options.schema);
        options.onReset?.(e);
    }
    const rootId = $derived(options.idPrefix ?? DEFAULT_ID_PREFIX);
    const uiOptionsRegistry = $derived(options[UI_OPTIONS_REGISTRY_KEY] ?? {});
    const uiOptions = $derived({
        ...uiSchemaRoot["ui:globalOptions"],
        ...uiSchema["ui:options"],
    });
    const context = {
        ...{},
        get rootId() {
            return rootId;
        },
        get value() {
            return value;
        },
        set value(v) {
            value = v;
        },
        get fieldsValidationMode() {
            return fieldsValidationMode;
        },
        submission,
        fieldsValidation,
        get dataUrlToBlob() {
            return dataUrlToBlob;
        },
        get isSubmitted() {
            return isSubmitted;
        },
        set isSubmitted(v) {
            isSubmitted = v;
        },
        get isChanged() {
            return isChanged;
        },
        set isChanged(v) {
            isChanged = v;
        },
        get errors() {
            return errors;
        },
        get schema() {
            return options.schema;
        },
        get uiSchemaRoot() {
            return uiSchemaRoot;
        },
        get uiSchema() {
            return uiSchema;
        },
        get uiOptions() {
            return uiOptions;
        },
        get extraUiOptions() {
            return options.extraUiOptions;
        },
        get uiOptionsRegistry() {
            return uiOptionsRegistry;
        },
        get disabled() {
            return disabled;
        },
        get idPrefix() {
            return options.idPrefix ?? DEFAULT_ID_PREFIX;
        },
        get idSeparator() {
            return options.idSeparator ?? DEFAULT_ID_SEPARATOR;
        },
        get idPseudoSeparator() {
            return options.idPseudoSeparator ?? DEFAULT_ID_PSEUDO_SEPARATOR;
        },
        get validator() {
            return options.validator;
        },
        get merger() {
            return merger;
        },
        get fieldTypeResolver() {
            return fieldTypeResolver;
        },
        get theme() {
            return options.theme;
        },
        get translation() {
            return options.translation;
        },
        get translate() {
            return translate;
        },
        get icons() {
            return options.icons;
        },
        submitHandler,
        resetHandler,
    };
    const fieldTypeResolver = $derived(options.resolver(context));
    return {
        context,
        get value() {
            return getSnapshot(context);
        },
        set value(v) {
            value = merger.mergeFormDataAndSchemaDefaults(v, options.schema);
        },
        get errors() {
            return errors;
        },
        set errors(v) {
            errors = v;
        },
        get isSubmitted() {
            return isSubmitted;
        },
        set isSubmitted(v) {
            isSubmitted = v;
        },
        get isChanged() {
            return isChanged;
        },
        set isChanged(v) {
            isChanged = v;
        },
        submission,
        fieldsValidation,
        submit: submitHandler,
        reset: resetHandler,
    };
}
export function enhance(node, context) {
    $effect(() => {
        const ctx = context;
        const disposeSubmit = on(node, "submit", ctx.submitHandler);
        const disposeReset = on(node, "reset", ctx.resetHandler);
        return () => {
            disposeReset();
            disposeSubmit();
        };
    });
}
