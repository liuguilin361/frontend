import type { SchedulerYield } from "../lib/scheduler.js";
import { type ActionsCombinator, type FailedAction } from "../lib/action.svelte.js";
import type { Schema, Validator } from "../core/index.js";
import { type ValidationError } from "./validator.js";
import { type Translation } from "./translation.js";
import { type ExtraUiOptions, type UiOptionsRegistry, type UiSchemaRoot } from "./ui-schema.js";
import type { Icons } from "./icons.js";
import type { FieldsValidationMode } from "./validation.js";
import { type FieldError, type PossibleError, type FieldErrorsMap, type AnyFormValueValidatorError, type AnyFieldValueValidatorError, type FormSubmission, type FieldsValidation, type FormValidationResult } from "./errors.js";
import { type FormInternalContext, type FormContext } from "./context/index.js";
import { type FormMerger } from "./merger.js";
import { type Id } from "./id.js";
import type { Config } from "./config.js";
import type { Theme } from "./components.js";
import type { FormValue } from "./model.js";
import type { ResolveFieldType } from "./fields.js";
export declare const DEFAULT_FIELDS_VALIDATION_DEBOUNCE_MS = 300;
export type InitialErrors<V extends Validator> = ValidationError<PossibleError<V>>[] | Iterable<readonly [Id, FieldError<PossibleError<V>>[]]>;
declare const UI_OPTIONS_REGISTRY_KEY = "uiOptionsRegistry";
export type UiOptionsRegistryOption = keyof UiOptionsRegistry extends never ? {
    [UI_OPTIONS_REGISTRY_KEY]?: UiOptionsRegistry;
} : {
    [UI_OPTIONS_REGISTRY_KEY]: UiOptionsRegistry;
};
export interface FormOptions<T, V extends Validator> extends UiOptionsRegistryOption {
    validator: V;
    schema: Schema;
    theme: Theme;
    translation: Translation;
    resolver: (ctx: FormInternalContext<V>) => ResolveFieldType;
    icons?: Icons;
    uiSchema?: UiSchemaRoot;
    extraUiOptions?: ExtraUiOptions;
    merger?: FormMerger;
    fieldsValidationMode?: FieldsValidationMode;
    disabled?: boolean;
    /**
     * @default DEFAULT_ID_PREFIX
     */
    idPrefix?: string;
    /**
     * @default DEFAULT_ID_SEPARATOR
     */
    idSeparator?: string;
    /**
     * @default DEFAULT_ID_PSEUDO_SEPARATOR
     */
    idPseudoSeparator?: string;
    initialValue?: Partial<T>;
    initialErrors?: InitialErrors<V>;
    /**
     * @default waitPrevious
     */
    submissionCombinator?: ActionsCombinator<[
        event: SubmitEvent
    ], FormValidationResult<AnyFormValueValidatorError<V>>, unknown>;
    /**
     * @default 500
     */
    submissionDelayedMs?: number;
    /**
     * @default 8000
     */
    submissionTimeoutMs?: number;
    /**
     * @default 300
     */
    fieldsValidationDebounceMs?: number;
    /**
     * @default abortPrevious
     */
    fieldsValidationCombinator?: ActionsCombinator<[
        Config,
        FormValue
    ], FieldError<AnyFieldValueValidatorError<V>>[], unknown>;
    /**
     * @default 500
     */
    fieldsValidationDelayedMs?: number;
    /**
     * @default 8000
     */
    fieldsValidationTimeoutMs?: number;
    /**
     * The function to get the form data snapshot
     *
     * The snapshot is used to validate the form and passed to
     * `onSubmit` and `onSubmitError` handlers.
     *
     * @default (ctx) => $state.snapshot(ctx.value)
     */
    getSnapshot?: (ctx: FormInternalContext<V>) => FormValue;
    /**
     * Submit handler
     *
     * Will be called when the form is submitted and form data
     * snapshot is valid
     *
     * Note that we rely on `validator.validateFormData` to check that the
     * `formData is T`. So make sure you provide a `T` type that
     * matches the validator check result.
     */
    onSubmit?: (value: T, e: SubmitEvent) => void;
    /**
     * Submit error handler
     *
     * Will be called when the form is submitted and form data
     * snapshot is not valid
     */
    onSubmitError?: (errors: FieldErrorsMap<AnyFormValueValidatorError<V>>, e: SubmitEvent, snapshot: FormValue) => void;
    /**
     * Form submission error handler
     *
     * Will be called when the submission fails by a different reasons:
     * - submission is cancelled
     * - error during validation
     * - validation timeout
     */
    onSubmissionFailure?: (state: FailedAction<unknown>, e: SubmitEvent) => void;
    /**
     * Field validation error handler
     */
    onFieldsValidationFailure?: (state: FailedAction<unknown>, config: Config, value: FormValue) => void;
    /**
     * Reset handler
     *
     * Will be called when the form is reset.
     */
    onReset?: (e: Event) => void;
    schedulerYield?: SchedulerYield;
}
export interface FormState<T, V extends Validator> {
    readonly context: FormContext;
    readonly submission: FormSubmission<V>;
    readonly fieldsValidation: FieldsValidation<V>;
    /**
     * An accessor that maintains form state consistency:
     *
     * - A snapshot of the form state is returned on access
     * - Default values from JSON Schema are taken into account during assignment
     *
     * You can gain direct access to the internal state by hacking types:
     *
     * `(form.context as FormInternalContext<typeof validator>).value`
     */
    value: T | undefined;
    isSubmitted: boolean;
    isChanged: boolean;
    errors: FieldErrorsMap<PossibleError<V>>;
    submit(e: SubmitEvent): void;
    reset(e: Event): void;
}
export declare function createForm<T, V extends Validator>(options: FormOptions<T, V>): FormState<T, V>;
export declare function enhance(node: HTMLFormElement, context: FormContext): void;
export {};
