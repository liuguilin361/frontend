export function isUiSchemaRef(def) {
    return typeof def?.$ref === "string";
}
export function resolveUiRef(rootSchema, schemaDef) {
    return isUiSchemaRef(schemaDef)
        ? rootSchema["ui:definitions"]?.[schemaDef.$ref]
        : schemaDef;
}
export function resolveUiOption(uiSchemaRoot, uiOptionsRegistry, uiSchema, option) {
    let value = uiSchema["ui:options"]?.[option];
    if (value === undefined) {
        value = uiSchemaRoot["ui:globalOptions"]?.[option];
    }
    if (typeof value === "string" && value.startsWith("registry:")) {
        return uiOptionsRegistry[value.substring(9)];
    }
    return value;
}
export function getUiSchemaByPath(rootSchema, schemaDef, path) {
    let schema = resolveUiRef(rootSchema, schemaDef);
    for (let i = 0; i < path.length; i++) {
        if (schema === undefined) {
            return undefined;
        }
        const alt = schema.anyOf ?? schema.oneOf;
        if (alt) {
            let def;
            const slice = path.slice(i);
            for (const sub of alt) {
                def = getUiSchemaByPath(rootSchema, sub, slice);
                if (def !== undefined) {
                    return def;
                }
            }
            // Alt schema may be mixed with normal schema so
            // no early exit here
        }
        const k = path[i];
        const { items, additionalItems, additionalProperties } = schema;
        schema = resolveUiRef(rootSchema, schema[k] ??
            (Array.isArray(items) ? items[k] : items) ??
            additionalProperties ??
            additionalItems);
    }
    return schema;
}
export function getRootUiSchemaTitleByPath(uiSchemaRoot, path) {
    return getUiSchemaByPath(uiSchemaRoot, uiSchemaRoot, path)?.["ui:options"]
        ?.title;
}
