import { type Schema, type SchemaArrayValue, type SchemaObjectValue, type SchemaType, type SchemaValue } from "./schema.js";
import type { Validator } from "./validator.js";
import type { Merger } from "./merger.js";
export declare function getDefaultValueForType(type: SchemaType): {} | null;
export declare function getDefaultFormState(validator: Validator, merger: Merger, theSchema: Schema, formData?: SchemaValue | undefined, rootSchema?: Schema, includeUndefinedValues?: boolean | "excludeObjectChildren", experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior): SchemaValue | undefined;
export type Experimental_ArrayMinItems = {
    /** Optional enumerated flag controlling how array minItems are populated, defaulting to `all`:
     * - `all`: Legacy behavior, populate minItems entries with default values initially and include an empty array when
     *        no values have been defined.
     * - `requiredOnly`: Ignore `minItems` on a field when calculating defaults unless the field is required.
     * - `never`: Ignore `minItems` on a field even the field is required.
     */
    populate?: "all" | "requiredOnly" | "never";
    /** A function that determines whether to skip populating the array with default values based on the provided validator,
     * schema, and root schema.
     * If the function returns true, the array will not be populated with default values.
     * If the function returns false, the array will be populated with default values according to the `populate` option.
     * @param validator - An implementation of the `ValidatorType` interface that is used to detect valid schema conditions
     * @param schema - The schema for which resolving a condition is desired
     * @param [rootSchema] - The root schema that will be forwarded to all the APIs
     * @returns A boolean indicating whether to skip populating the array with default values.
     */
    computeSkipPopulate?: (validator: Validator, schema: Schema, rootSchema?: Schema) => boolean;
    /** When `formData` is provided and does not contain `minItems` worth of data, this flag (`false` by default) controls
     * whether the extra data provided by the defaults is appended onto the existing `formData` items to ensure the
     * `minItems` condition is met. When false (legacy behavior), only the `formData` provided is merged into the default
     * form state, even if there are fewer than the `minItems`. When true, the defaults are appended onto the end of the
     * `formData` until the `minItems` condition is met.
     */
    mergeExtraDefaults?: boolean;
};
export type Experimental_DefaultFormStateBehavior = {
    /** Optional object, that controls how the default form state for arrays with `minItems` is handled. When not provided
     * it defaults to `{ populate: 'all' }`.
     */
    arrayMinItems?: Experimental_ArrayMinItems;
    /** Optional enumerated flag controlling how empty object fields are populated, defaulting to `populateAllDefaults`:
     * - `populateAllDefaults`: Legacy behavior - set default when there is a primitive value, an non-empty object field,
     *        or the field itself is required  |
     * - `populateRequiredDefaults`: Only sets default when a value is an object and its parent field is required, or it
     *        is a primitive value and it is required |
     * - `skipDefaults`: Does not set defaults                                                                                                      |
     * - `skipEmptyDefaults`: Does not set an empty default. It will still apply the default value if a default property is defined in your schema.                                                                                                 |
     */
    emptyObjectFields?: "populateAllDefaults" | "populateRequiredDefaults" | "skipDefaults" | "skipEmptyDefaults";
    /**
     * Optional flag to compute the default form state using allOf and if/then/else schemas. Defaults to `skipDefaults'.
     */
    allOf?: "populateDefaults" | "skipDefaults";
    /** Optional enumerated flag controlling how the defaults are merged into the form data when dealing with undefined
     * values, defaulting to `useFormDataIfPresent`.
     * NOTE: If there is a default for a field and the `formData` is unspecified, the default ALWAYS merges.
     * - `useFormDataIfPresent`: Legacy behavior - Do not merge defaults if there is a value for a field in `formData`,
     *        even if that value is explicitly set to `undefined`
     * - `useDefaultIfFormDataUndefined`: - If the value of a field within the `formData` is `undefined`, then use the
     *        default value instead
     */
    mergeDefaultsIntoFormData?: "useFormDataIfPresent" | "useDefaultIfFormDataUndefined";
    /** Optional enumerated flag controlling how const values are merged into the form data as defaults when dealing with
     * undefined values, defaulting to `always`. The defaulting behavior for this flag will always be controlled by the
     * `emptyObjectField` flag value. For instance, if `populateRequiredDefaults` is set and the const value is not
     * required, it will not be set.
     * - `always`: A const value will always be merged into the form as a default. If there is are const values in a
     *        `oneOf` (for instance to create an enumeration with title different from the values), the first const value
     *        will be defaulted
     * - `skipOneOf`: If const is in a `oneOf` it will NOT pick the first value as a default
     * - `never`: A const value will never be used as a default
     *
     */
    constAsDefaults?: "always" | "skipOneOf" | "never";
};
interface ComputeDefaultsProps<FormData = SchemaValue | undefined> {
    parentDefaults: SchemaValue | undefined;
    rootSchema: Schema;
    rawFormData: FormData;
    includeUndefinedValues: boolean | "excludeObjectChildren";
    stack: Set<string>;
    experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior;
    isSchemaRoot: boolean;
    required: boolean;
    /**
     * flag, if true, It will merge defaults into formData.
     * The formData should take precedence unless it's not valid. This is useful when for example the value from formData does not exist in the schema 'enum' property, in such cases we take the value from the defaults because the value from the formData is not valid.
     */
    shouldMergeDefaultsIntoFormData: boolean;
}
export declare function computeDefaults(validator: Validator, merger: Merger, rawSchema: Schema, computeDefaultsProps: ComputeDefaultsProps): SchemaValue | undefined;
/**
 * Ensure that the formData matches the given schema. If it's not matching in the case of a selectField, we change it to match the schema.
 *
 * @param validator - an implementation of the `ValidatorType` interface that will be used when necessary
 * @param schema - The schema for which the formData state is desired
 * @param rootSchema - The root schema, used to primarily to look up `$ref`s
 * @param formData - The current formData
 * @param experimental_defaultFormStateBehavior - Optional configuration object, if provided, allows users to override default form state behavior
 * @returns - valid formData that matches schema
 */
export declare function ensureFormDataMatchingSchema(validator: Validator, merger: Merger, schema: Schema, rootSchema: Schema, formData: SchemaValue | undefined, experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior): SchemaValue | undefined;
export declare enum AdditionalItemsHandling {
    Ignore = 0,
    Invert = 1,
    Fallback = 2
}
export declare function getInnerSchemaForArrayItem(schema: Schema, additionalItems?: AdditionalItemsHandling, idx?: number): Schema;
export declare function getDefaultBasedOnSchemaType(validator: Validator, merger: Merger, rawSchema: Schema, computeDefaultsProps: ComputeDefaultsProps, defaults: SchemaValue | undefined): SchemaValue | undefined;
export declare function getObjectDefaults(validator: Validator, merger: Merger, schema: Schema, { rootSchema, includeUndefinedValues, stack, experimental_defaultFormStateBehavior, required, isSchemaRoot, rawFormData: formData, shouldMergeDefaultsIntoFormData, }: ComputeDefaultsProps<SchemaObjectValue>, defaults: SchemaValue | undefined): SchemaObjectValue;
export declare function getArrayDefaults(validator: Validator, merger: Merger, schema: Schema, { rawFormData, rootSchema, stack, experimental_defaultFormStateBehavior, required, shouldMergeDefaultsIntoFormData, }: ComputeDefaultsProps, defaults: SchemaArrayValue | undefined): SchemaArrayValue | undefined;
export {};
