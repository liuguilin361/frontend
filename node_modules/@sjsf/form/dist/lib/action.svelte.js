import { DEV } from "esm-env";
import { untrack } from "svelte";
import { noop } from "./function.js";
/**
 * Forget previous action
 */
export const forgetPrevious = () => true;
/**
 * Abort previous action
 */
export const abortPrevious = () => "abort";
/**
 * Ignore new action until the previous action is completed
 */
export const waitPrevious = ({ status }) => status !== "processing";
export function throttle(combinator, delayedMs) {
    let nextCallAfter = 0;
    return (state) => {
        const now = Date.now();
        if (now < nextCallAfter) {
            return false;
        }
        nextCallAfter = now + delayedMs;
        return combinator(state);
    };
}
export class InitializationError {
    state;
    constructor(state) {
        this.state = state;
    }
}
export class CompletionError {
    state;
    constructor(state) {
        this.state = state;
    }
}
export function createAction(options) {
    const delayedMs = $derived(options.delayedMs ?? 500);
    const timeoutMs = $derived(options.timeoutMs ?? 8000);
    if (DEV) {
        $effect(() => {
            if (timeoutMs < delayedMs) {
                throw new Error("timeoutMs must be greater than delayedMs");
            }
        });
    }
    const combinator = $derived(options.combinator ?? waitPrevious);
    let state = $state.raw({
        status: "idle",
    });
    let delayedCallbackId;
    let timeoutCallbackId;
    function clearTimeouts() {
        clearTimeout(delayedCallbackId);
        clearTimeout(timeoutCallbackId);
    }
    function abort(state) {
        state.abortController.abort();
    }
    function runEffect(promise, effect) {
        if (state.status === "failed") {
            throw new CompletionError(state);
        }
        if (state.status === "processing" && state.promise === promise) {
            clearTimeouts();
            effect();
        }
    }
    function initAbortController(decision) {
        if (state.status === "processing") {
            if (decision !== "abort") {
                return state.abortController;
            }
            abort(state);
        }
        return new AbortController();
    }
    async function run(decision, args) {
        if (decision === false) {
            throw new InitializationError(state);
        }
        const abortController = initAbortController(decision);
        const cleanPromise = options.execute(abortController.signal, ...args);
        if (decision === "untrack") {
            return cleanPromise;
        }
        const promise = cleanPromise.then((result) => {
            runEffect(promise, () => {
                state = { status: "success" };
                options.onSuccess?.(result, ...args);
            });
            return result;
        }, (error) => {
            runEffect(promise, () => {
                state = { status: "failed", reason: "error", error };
                options.onFailure?.(state, ...args);
            });
            return Promise.reject(error);
        });
        state = {
            status: "processing",
            delayed: action.isDelayed,
            args,
            promise,
            abortController,
        };
        clearTimeouts();
        delayedCallbackId = setTimeout(() => {
            if (state.status !== "processing" || state.promise !== promise)
                return;
            state = {
                ...state,
                delayed: true,
            };
        }, delayedMs);
        timeoutCallbackId = setTimeout(() => {
            if (state.status !== "processing" || state.promise !== promise)
                return;
            // NOTE: The `clearTimeouts` call is not needed here
            abort(state);
            state = { status: "failed", reason: "timeout" };
            options.onFailure?.(state, ...args);
        }, timeoutMs);
        return promise;
    }
    // NOTE: call `combinator` synchronously to propagate possible error even
    // during `run` call
    function decideAndRun(args) {
        return untrack(() => run(combinator(state), args));
    }
    const action = {
        get state() {
            return state;
        },
        get status() {
            return state.status;
        },
        get isSuccess() {
            return state.status === "success";
        },
        get isFailed() {
            return state.status === "failed";
        },
        get isProcessed() {
            return state.status === "processing";
        },
        get isDelayed() {
            return state.status === "processing" && state.delayed;
        },
        matches(status) {
            return state.status === status;
        },
        run(...args) {
            void decideAndRun(args).catch(noop);
        },
        runAsync(...args) {
            return decideAndRun(args);
        },
        abort() {
            untrack(() => {
                if (state.status !== "processing")
                    return;
                const { args } = state;
                abort(state);
                clearTimeouts();
                state = { status: "failed", reason: "aborted" };
                options.onFailure?.(state, ...args);
            });
        },
    };
    return action;
}
