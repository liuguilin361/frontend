export type Status = "idle" | "processing" | "success" | "failed";
export interface AbstractActionState<S extends Status> {
    status: S;
}
export type ActionFailureReason = "timeout" | "aborted" | "error";
export interface AbstractFailedAction<R extends ActionFailureReason> extends AbstractActionState<"failed"> {
    reason: R;
}
export interface ActionFailedByError<E> extends AbstractFailedAction<"error"> {
    error: E;
}
export type FailedAction<E> = ActionFailedByError<E> | AbstractFailedAction<"timeout"> | AbstractFailedAction<"aborted">;
export interface ProcessingAction<T, R> extends AbstractActionState<"processing"> {
    delayed: boolean;
    args: T;
    promise: Promise<R>;
    abortController: AbortController;
}
export type ActionState<T, R, E> = AbstractActionState<"idle"> | ProcessingAction<T, R> | AbstractActionState<"success"> | FailedAction<E>;
export type ActionsCombinatorDecision = boolean | "abort" | "untrack";
export type ActionsCombinator<T, R, E> = (state: ActionState<T, R, E>) => ActionsCombinatorDecision;
export interface ActionOptions<T extends ReadonlyArray<any>, R, E> {
    execute: (signal: AbortSignal, ...args: T) => Promise<R>;
    onSuccess?: (result: R, ...args: T) => void;
    onFailure?: (failure: FailedAction<E>, ...args: T) => void;
    /**
     * The `combinator` runtime error is interpreted as `false`.
     * @default waitPrevious
     */
    combinator?: ActionsCombinator<T, R, E>;
    /**
     * @default 500
     */
    delayedMs?: number;
    /**
     * @default 8000
     */
    timeoutMs?: number;
}
/**
 * Forget previous action
 */
export declare const forgetPrevious: ActionsCombinator<any, any, any>;
/**
 * Abort previous action
 */
export declare const abortPrevious: ActionsCombinator<any, any, any>;
/**
 * Ignore new action until the previous action is completed
 */
export declare const waitPrevious: ActionsCombinator<any, any, any>;
export declare function throttle<T, R, E>(combinator: ActionsCombinator<T, R, E>, delayedMs: number): ActionsCombinator<T, R, E>;
export declare class InitializationError<T, R, E> {
    readonly state: ActionState<T, R, E>;
    constructor(state: ActionState<T, R, E>);
}
export declare class CompletionError<E> {
    readonly state: FailedAction<E>;
    constructor(state: FailedAction<E>);
}
export interface Action<T extends ReadonlyArray<any>, R, E> {
    readonly state: Readonly<ActionState<T, R, E>>;
    readonly status: Status;
    readonly isSuccess: boolean;
    readonly isFailed: boolean;
    readonly isProcessed: boolean;
    readonly isDelayed: boolean;
    matches<S extends Status>(status: S): this is Action<T, R, E> & {
        status: S;
        state: Readonly<Extract<ActionState<T, R, E>, AbstractActionState<S>>>;
    };
    /**
     * Initiates the action without waiting for its result.
     * Any side effects or failures are handled internally.
     */
    run(...args: T): void;
    /**
     * Initiates the action and returns a promise that resolves when the action completes.
     * Use this method when you need to handle the result or catch errors.
     * @throws InitializationError if combinator returns `false`.
     * @throws CompletionError if action were aborted or timeouted.
     */
    runAsync(...args: T): Promise<R>;
    /**
     * Aborts the ongoing action if it is currently processing.
     * The action will fail with an "aborted" reason and trigger any associated failure callbacks.
     */
    abort(): void;
}
export declare function createAction<T extends ReadonlyArray<any>, R = unknown, E = unknown>(options: ActionOptions<T, R, E>): Action<T, R, E>;
