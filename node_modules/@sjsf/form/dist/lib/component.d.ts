import type { Component } from "svelte";
export type AnyComponent = Component<any, any, any>;
type OmitNever<T> = {
    [K in keyof T as T[K] extends never ? never : K]: T[K];
};
type Transforms<FromProps, ToProps> = {
    [K in keyof ToProps]: {
        transform(props: FromProps): ToProps[K];
    };
};
type Recovers<FromProps, ToProps> = {
    [K in keyof ToProps]: {
        recover(props: FromProps, value: ToProps[K]): void;
    };
};
type PropsCast<FromProps extends Record<string, any>, ToProps extends Record<string, any>, ToBindings extends keyof ToProps | "", Transform extends Transforms<FromProps, ToProps> = Transforms<FromProps, ToProps>, Recover extends Recovers<FromProps, ToProps> = Recovers<FromProps, ToProps>> = OmitNever<{
    [K in keyof ToProps]: K extends keyof FromProps ? FromProps[K] extends ToProps[K] ? K extends ToBindings ? ToProps[K] extends FromProps[K] ? never : // Prop is not assignable, recover required
    Recover[K] & Partial<Transform[K]> : never : // Transform is required, lets check bindings
    Transform[K] & (K extends ToBindings ? ToProps[K] extends FromProps[K] ? Partial<Recover[K]> : Recover[K] : {}) : ToProps[K] extends undefined ? never : Transform[K] & (K extends ToBindings ? Partial<Recover[K]> : {});
}> & Partial<OmitNever<{
    [K in keyof ToProps]: Partial<K extends keyof FromProps ? FromProps[K] extends ToProps[K] ? K extends ToBindings ? ToProps[K] extends FromProps[K] ? // Prop is assignable, recover is also optional
    Transform[K] & Recover[K] : never : Transform[K] : never : ToProps[K] extends undefined ? Transform & (K extends ToBindings ? Recover[K] : {}) : never>;
}>>;
export type PropertiesCast<From extends AnyComponent, To extends AnyComponent> = From extends Component<infer FromProps, any, any> ? To extends Component<infer ToProps, any, infer ToBindings> ? PropsCast<FromProps, ToProps, ToBindings> : never : never;
export declare function cast<From extends AnyComponent, To extends AnyComponent>(Component: To, propsCast: PropertiesCast<From, To>): From;
export {};
