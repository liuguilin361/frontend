import {
  AFTER_SUBMITTED,
  ON_ARRAY_CHANGE,
  ON_OBJECT_CHANGE,
  createChildId,
  createPseudoId,
  getClosestMatchingOption,
  getComponent,
  getDefaultFieldState,
  getErrors,
  getFieldComponent,
  getFormContext,
  identity,
  makeEventHandlers,
  retrieveSchema,
  retrieveTranslate,
  retrieveUiOption,
  retrieveUiSchema,
  sanitizeDataForNewSchema,
  text_default,
  uiTitleOption,
  validateAdditionalPropertyKey,
  validateField
} from "./chunk-TH67H3ZF.js";
import {
  ADDITIONAL_PROPERTY_FLAG,
  ANY_OF_KEY,
  ONE_OF_KEY,
  getDefaultValueForType,
  getDiscriminatorFieldFromSchema,
  getSimpleSchemaType,
  isAdditionalProperty,
  isSchema,
  isSchemaArrayValue,
  isSchemaDeepEqual,
  isSchemaExpandable,
  isSchemaNullable,
  isSchemaObjectValue,
  orderProperties
} from "./chunk-L5BEN6GZ.js";
import {
  add_locations,
  check_target,
  component,
  create_ownership_validator,
  each,
  hmr,
  if_block,
  legacy_api,
  prop,
  validate_binding,
  validate_each_keys,
  validate_snippet_args,
  wrap_snippet
} from "./chunk-C3TCUAZZ.js";
import {
  append,
  comment,
  from_html,
  text
} from "./chunk-4O4LVGQI.js";
import {
  FILENAME,
  HMR,
  first_child,
  get,
  getContext,
  next,
  pop,
  push,
  set,
  setContext,
  sibling,
  snapshot,
  state,
  strict_equals,
  tag,
  untrack,
  update,
  user_derived,
  user_effect
} from "./chunk-YEGJDBKW.js";
import {
  __export
} from "./chunk-G3PMV62Z.js";

// node_modules/@sjsf/form/dist/fields/exports.js
var exports_exports = {};
__export(exports_exports, {
  anyOfField: () => any_of_default,
  arrayField: () => array_field_default,
  arrayItemField: () => array_item_field_default,
  booleanField: () => boolean_default,
  integerField: () => integer_default,
  nullField: () => null_default,
  numberField: () => number_field_default,
  objectField: () => object_field_default,
  objectPropertyField: () => object_property_field_default,
  oneOfField: () => one_of_default,
  stringField: () => string_default,
  tupleField: () => tuple_field_default
});

// node_modules/@sjsf/form/dist/fields/combination.svelte
Combination[FILENAME] = "node_modules/@sjsf/form/dist/fields/combination.svelte";
var root = add_locations(from_html(`<!> <!>`, 1), Combination[FILENAME], []);
function Combination($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Combination);
  var $$ownership_validator = create_ownership_validator($$props);
  let value = prop($$props, "value", 15);
  const ctx = getFormContext();
  const Template = tag(user_derived(() => getComponent(ctx, "multiFieldTemplate", $$props.config)), "Template");
  const Widget = tag(user_derived(() => getComponent(ctx, "selectWidget", $$props.config)), "Widget");
  const restFieldConfig = tag(
    user_derived(() => {
      const { [$$props.combinationKey]: _, ...restSchema } = $$props.config.schema;
      const restSchemaType = getSimpleSchemaType(restSchema);
      return strict_equals(restSchemaType, "null", false) ? { ...$$props.config, schema: restSchema } : null;
    }),
    "restFieldConfig"
  );
  const RestSchemaField = tag(user_derived(() => get(restFieldConfig) && getFieldComponent(ctx, get(restFieldConfig))), "RestSchemaField");
  const retrievedOptions = tag(user_derived(() => ($$props.config.schema[$$props.combinationKey] ?? []).map((s) => strict_equals(typeof s, "boolean", false) ? retrieveSchema(ctx, s, value()) : {})), "retrievedOptions");
  let readableSelectedOption = tag(state(0), "readableSelectedOption");
  let writableSelectedOption = tag(user_derived(() => getClosestMatchingOption(ctx, value(), get(retrievedOptions), get(readableSelectedOption), getDiscriminatorFieldFromSchema($$props.config.schema))), "writableSelectedOption");
  user_effect(() => {
    const nextSelected = get(writableSelectedOption);
    if (strict_equals(get(readableSelectedOption), nextSelected)) {
      return;
    }
    value(untrack(() => {
      const nextSchema = get(retrievedOptions)[nextSelected];
      if (strict_equals(nextSchema, void 0)) {
        return void 0;
      }
      const oldSchema = get(retrievedOptions)[get(readableSelectedOption)];
      return getDefaultFieldState(ctx, nextSchema, strict_equals(oldSchema, void 0, false) ? sanitizeDataForNewSchema(ctx, nextSchema, oldSchema, value()) : value());
    }));
    set(readableSelectedOption, nextSelected, true);
  });
  const optionsUiSchemas = tag(
    user_derived(() => {
      const schemas = $$props.config.uiSchema[$$props.combinationKey];
      return Array.isArray(schemas) ? schemas.map((s) => retrieveUiSchema(ctx, s)) : [];
    }),
    "optionsUiSchemas"
  );
  const enumOptionLabel = tag(
    user_derived(() => {
      const explicitTitle = uiTitleOption(ctx, $$props.config.uiSchema) ?? $$props.config.schema.title;
      return explicitTitle ? (index) => $$props.translate("multi-schema-option-label-with-title", { index, title: explicitTitle }) : (index) => $$props.translate("multi-schema-option-label", { index });
    }),
    "enumOptionLabel"
  );
  const optionTitles = tag(
    user_derived(() => {
      const discriminator = getDiscriminatorFieldFromSchema($$props.config.schema);
      return get(retrievedOptions).map((s, i) => {
        if (strict_equals(discriminator, void 0, false)) {
          const uiSchemaDefinition = get(optionsUiSchemas)[i]?.[discriminator];
          if (strict_equals(typeof uiSchemaDefinition, "object") && !Array.isArray(uiSchemaDefinition)) {
            const title = uiTitleOption(ctx, retrieveUiSchema(ctx, uiSchemaDefinition));
            if (strict_equals(title, void 0, false)) {
              return title;
            }
          }
          const schemaDef = s.properties?.[discriminator];
          if (strict_equals(schemaDef, void 0, false) && strict_equals(typeof schemaDef, "boolean", false)) {
            const { title } = retrieveSchema(ctx, schemaDef, void 0);
            if (strict_equals(title, void 0, false)) {
              return title;
            }
          }
        }
        const uiSchema = get(optionsUiSchemas)[i];
        return (uiSchema && uiTitleOption(ctx, uiSchema)) ?? s.title ?? get(enumOptionLabel)(i);
      });
    }),
    "optionTitles"
  );
  const enumOptions = tag(
    user_derived(() => get(optionTitles).map((label, i) => ({
      id: createPseudoId($$props.config.id, i, ctx),
      label,
      value: i,
      disabled: false
    }))),
    "enumOptions"
  );
  const widgetConfig = tag(
    user_derived(() => {
      const suffix = $$props.combinationKey.toLowerCase();
      const uiSchema = retrieveUiSchema(ctx, $$props.config.uiSchema.combinationFieldOptionSelector);
      return {
        id: createPseudoId($$props.config.id, suffix, ctx),
        title: uiTitleOption(ctx, uiSchema) ?? $$props.config.title,
        schema: { type: "integer", default: 0 },
        uiSchema,
        required: true
      };
    }),
    "widgetConfig"
  );
  const errors = tag(user_derived(() => getErrors(ctx, $$props.config.id)), "errors");
  const combinationFieldConfig = tag(
    user_derived(() => {
      const selected = get(readableSelectedOption);
      if (selected < 0) {
        return null;
      }
      const schema = get(retrievedOptions)[selected];
      const { required } = $$props.config.schema;
      const optionSchema = required ? {
        ...schema,
        required: schema.required ? required.concat(schema.required) : required
      } : schema;
      const optionUiSchema = selected < get(optionsUiSchemas).length ? get(optionsUiSchemas)[selected] : $$props.config.uiSchema;
      return {
        id: $$props.config.id,
        title: "",
        schema: optionSchema,
        uiSchema: optionUiSchema,
        required: $$props.config.required
      };
    }),
    "combinationFieldConfig"
  );
  const CombinationField = tag(user_derived(() => get(combinationFieldConfig) && getFieldComponent(ctx, get(combinationFieldConfig))), "CombinationField");
  var fragment = root();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      const expression = user_derived(() => retrieveTranslate(ctx, get(restFieldConfig)));
      component(node_1, () => get(RestSchemaField), ($$anchor3, RestSchemaField_1) => {
        $$ownership_validator.binding("value", RestSchemaField_1, value);
        RestSchemaField_1($$anchor3, {
          type: "field",
          get config() {
            return get(restFieldConfig);
          },
          uiOption: (opt) => retrieveUiOption(ctx, get(restFieldConfig), opt),
          get translate() {
            return get(expression);
          },
          get value() {
            return value();
          },
          set value($$value) {
            value($$value);
          }
        });
      });
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (get(restFieldConfig)) $$render(consequent);
    });
  }
  var node_2 = sibling(node, 2);
  {
    const optionSelector = wrap_snippet(Combination, function($$anchor2) {
      validate_snippet_args(...arguments);
      var fragment_2 = comment();
      var node_3 = first_child(fragment_2);
      var bind_get = () => get(readableSelectedOption);
      var bind_set = (v) => set(writableSelectedOption, v, true);
      component(node_3, () => get(Widget), ($$anchor3, Widget_1) => {
        Widget_1($$anchor3, {
          type: "widget",
          get errors() {
            return get(errors);
          },
          handlers: {},
          get config() {
            return get(widgetConfig);
          },
          uiOption: (opt) => retrieveUiOption(ctx, get(widgetConfig), opt),
          get options() {
            return get(enumOptions);
          },
          get value() {
            return bind_get();
          },
          set value($$value) {
            bind_set($$value);
          }
        });
      });
      append($$anchor2, fragment_2);
    });
    component(node_2, () => get(Template), ($$anchor2, Template_1) => {
      Template_1($$anchor2, {
        type: "template",
        get config() {
          return $$props.config;
        },
        get value() {
          return value();
        },
        get errors() {
          return get(errors);
        },
        get uiOption() {
          return $$props.uiOption;
        },
        optionSelector,
        children: wrap_snippet(Combination, ($$anchor3, $$slotProps) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          {
            var consequent_1 = ($$anchor4) => {
              var fragment_4 = comment();
              var node_5 = first_child(fragment_4);
              const expression_1 = user_derived(() => retrieveTranslate(ctx, get(combinationFieldConfig)));
              component(node_5, () => get(CombinationField), ($$anchor5, CombinationField_1) => {
                $$ownership_validator.binding("value", CombinationField_1, value);
                CombinationField_1($$anchor5, {
                  type: "field",
                  get config() {
                    return get(combinationFieldConfig);
                  },
                  uiOption: (opt) => retrieveUiOption(ctx, get(combinationFieldConfig), opt),
                  get translate() {
                    return get(expression_1);
                  },
                  get value() {
                    return value();
                  },
                  set value($$value) {
                    value($$value);
                  }
                });
              });
              append($$anchor4, fragment_4);
            };
            if_block(node_4, ($$render) => {
              if (get(combinationFieldConfig)) $$render(consequent_1);
            });
          }
          append($$anchor3, fragment_3);
        }),
        $$slots: { optionSelector: true, default: true }
      });
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Combination = hmr(Combination, () => Combination[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Combination[HMR].source;
    set(Combination[HMR].source, module.default[HMR].original);
  });
}
var combination_default = Combination;

// node_modules/@sjsf/form/dist/lib/keyed-array.svelte.js
var EMPTY = [];
function createKeyedArray(array) {
  let arrayRef = new WeakRef(EMPTY);
  let lastKeys = EMPTY;
  let lastKey = -1;
  let changesPropagator = tag(state(0), "changesPropagator");
  const keys = tag(
    user_derived(() => {
      const arr = array();
      if (strict_equals(arrayRef.deref(), arr)) {
        return lastKeys;
      }
      arrayRef = new WeakRef(arr);
      lastKeys = new Array(arr.length);
      for (let i = 0; i < arr.length; i++) {
        lastKeys[i] = ++lastKey;
      }
      return lastKeys;
    }),
    "keys"
  );
  return {
    key(index) {
      get(changesPropagator);
      return get(keys)[index];
    },
    push(value) {
      lastKeys.push(++lastKey);
      array().push(value);
    },
    swap(a, b) {
      const arr = array();
      const key = lastKeys[a];
      lastKeys[a] = lastKeys[b];
      lastKeys[b] = key;
      if (strict_equals(arr[a], arr[b])) {
        update(changesPropagator);
      } else {
        const tmp = arr[a];
        arr[a] = arr[b];
        arr[b] = tmp;
      }
    },
    insert(index, value) {
      lastKeys.splice(index, 0, ++lastKey);
      array().splice(index, 0, value);
    },
    remove(index) {
      lastKeys.splice(index, 1);
      array().splice(index, 1);
    }
  };
}

// node_modules/@sjsf/form/dist/fields/array/model.js
function titleWithIndex(title, index, fixedItemsCount) {
  return index >= fixedItemsCount ? `${title}-${index - fixedItemsCount + 1}` : title;
}

// node_modules/@sjsf/form/dist/fields/array/context.svelte.js
var ARRAY_CONTEXT = Symbol("array-context");
function getArrayContext() {
  return getContext(ARRAY_CONTEXT);
}
function setArrayContext(ctx) {
  setContext(ARRAY_CONTEXT, ctx);
}
function createItemsAPI(ctx, config, value, itemSchema) {
  function validate() {
    const m = ctx.fieldsValidationMode;
    if (!(m & ON_ARRAY_CHANGE) || m & AFTER_SUBMITTED && !ctx.isSubmitted) {
      return;
    }
    validateField(ctx, config(), value());
  }
  const uiOption = (opt) => retrieveUiOption(ctx, config(), opt);
  const keyedArray = createKeyedArray(() => value() ?? []);
  const errors = tag(user_derived(() => getErrors(ctx, config().id)), "errors");
  const addable = tag(user_derived(() => uiOption("addable") ?? true), "addable");
  const orderable = tag(user_derived(() => uiOption("orderable") ?? true), "orderable");
  const removable = tag(user_derived(() => uiOption("removable") ?? true), "removable");
  const copyable = tag(user_derived(() => uiOption("copyable") ?? false), "copyable");
  const itemTitle = tag(user_derived(() => uiOption("itemTitle") ?? titleWithIndex), "itemTitle");
  return {
    uiOption,
    get itemTitle() {
      return get(itemTitle);
    },
    get config() {
      return config();
    },
    get addable() {
      return get(addable);
    },
    get orderable() {
      return get(orderable);
    },
    get removable() {
      return get(removable);
    },
    get copyable() {
      return get(copyable);
    },
    get errors() {
      return get(errors);
    },
    key(index) {
      return keyedArray.key(index);
    },
    pushItem() {
      const schema = itemSchema();
      if (strict_equals(schema, void 0)) {
        return;
      }
      keyedArray.push(getDefaultFieldState(ctx, schema, void 0) ?? getDefaultValueForType(getSimpleSchemaType(schema)));
      validate();
    },
    moveItemUp(index) {
      keyedArray.swap(index, index - 1);
      validate();
    },
    moveItemDown(index) {
      keyedArray.swap(index, index + 1);
      validate();
    },
    copyItem(index) {
      keyedArray.insert(index, snapshot(value()[index]));
      validate();
    },
    removeItem(index) {
      keyedArray.remove(index);
      validate();
    }
  };
}
function createCanAdd(config, value, addable) {
  let val, maxItems;
  return () => addable() && (val = value(), Array.isArray(val)) && (maxItems = config().schema.maxItems, strict_equals(maxItems, void 0) || val.length < maxItems);
}
function createArrayContext(ctx, config, value, _) {
  const itemSchema = tag(
    user_derived(() => {
      const { schema: { items } } = config();
      return isSchemaObjectValue(items) ? items : {};
    }),
    "itemSchema"
  );
  const api = createItemsAPI(ctx, config, value, () => get(itemSchema));
  const itemUiSchema = tag(
    user_derived(() => {
      const { uiSchema: { items } } = config();
      return retrieveUiSchema(ctx, !Array.isArray(items) ? items : void 0);
    }),
    "itemUiSchema"
  );
  const itemUiTitle = tag(user_derived(() => uiTitleOption(ctx, get(itemUiSchema))), "itemUiTitle");
  const canAdd = tag(user_derived(createCanAdd(config, value, () => api.addable)), "canAdd");
  return Object.assign(api, {
    canAdd() {
      return get(canAdd);
    },
    canCopy() {
      return api.copyable && get(canAdd);
    },
    canRemove() {
      return api.removable;
    },
    canMoveUp(index) {
      return api.orderable && index > 0;
    },
    canMoveDown(index) {
      return api.orderable && index < value().length - 1;
    },
    itemConfig(config2, item, index) {
      const schema = retrieveSchema(ctx, get(itemSchema), item);
      return {
        id: createChildId(config2.id, index, ctx),
        title: api.itemTitle(get(itemUiTitle) ?? schema.title ?? config2.title, index, 0),
        schema,
        uiSchema: get(itemUiSchema),
        required: !isSchemaNullable(schema)
      };
    }
  });
}
function createTupleContext(ctx, config, value, setValue) {
  const itemsSchema = tag(
    user_derived(() => {
      const { items } = config().schema;
      return Array.isArray(items) ? items.map((item, i) => {
        if (strict_equals(typeof item, "boolean")) {
          throw new Error("Invalid schema: items must be an array of schemas");
        }
        return retrieveSchema(ctx, item, value()?.[i]);
      }) : [];
    }),
    "itemsSchema"
  );
  const isAdditional = (index) => index >= get(itemsSchema).length;
  user_effect(() => {
    const val = value();
    if (strict_equals(val, void 0)) {
      setValue(new Array(get(itemsSchema).length));
      return;
    }
    if (val.length < get(itemsSchema).length) {
      val.push(...new Array(get(itemsSchema).length - value.length));
    }
  });
  const schemaAdditionalItems = tag(
    user_derived(() => {
      const { additionalItems } = config().schema;
      return isSchemaObjectValue(additionalItems) ? additionalItems : void 0;
    }),
    "schemaAdditionalItems"
  );
  const api = createItemsAPI(ctx, config, value, () => get(schemaAdditionalItems));
  const canAdd = tag(user_derived(createCanAdd(config, value, () => api.addable && strict_equals(get(schemaAdditionalItems), void 0, false))), "canAdd");
  return Object.assign(api, {
    canAdd() {
      return get(canAdd);
    },
    canCopy(index) {
      return api.copyable && get(canAdd) && isAdditional(index);
    },
    canRemove(index) {
      return api.removable && isAdditional(index);
    },
    canMoveUp(index) {
      return api.orderable && index > get(itemsSchema).length;
    },
    canMoveDown(index) {
      return api.orderable && index < value().length - 1 && isAdditional(index);
    },
    itemConfig(config2, item, index) {
      const additional = isAdditional(index);
      const schema = retrieveSchema(ctx, additional ? get(schemaAdditionalItems) : get(itemsSchema)[index], item);
      const uiSchema = retrieveUiSchema(ctx, additional ? config2.uiSchema.additionalItems : Array.isArray(config2.uiSchema.items) ? config2.uiSchema.items[index] : config2.uiSchema.items);
      return {
        id: createChildId(config2.id, index, ctx),
        title: api.itemTitle(uiTitleOption(ctx, uiSchema) ?? schema.title ?? config2.title, index, get(itemsSchema).length),
        schema,
        uiSchema,
        required: !isSchemaNullable(schema)
      };
    }
  });
}

// node_modules/@sjsf/form/dist/fields/array/array-base.svelte
Array_base[FILENAME] = "node_modules/@sjsf/form/dist/fields/array/array-base.svelte";
function Array_base($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Array_base);
  var $$ownership_validator = create_ownership_validator($$props);
  const addButton = wrap_snippet(Array_base, function($$anchor2) {
    validate_snippet_args(...arguments);
    var fragment = comment();
    var node = first_child(fragment);
    component(node, () => get(Button), ($$anchor3, Button_1) => {
      Button_1($$anchor3, {
        get errors() {
          return arrayCtx.errors;
        },
        get config() {
          return $$props.config;
        },
        disabled: false,
        type: "array-item-add",
        get onclick() {
          return arrayCtx.pushItem;
        },
        children: wrap_snippet(Array_base, ($$anchor4, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          text_default(node_1, {
            get config() {
              return $$props.config;
            },
            id: "add-array-item",
            get translate() {
              return $$props.translate;
            }
          });
          append($$anchor4, fragment_1);
        }),
        $$slots: { default: true }
      });
    });
    append($$anchor2, fragment);
  });
  let value = prop($$props, "value", 15);
  const ctx = getFormContext();
  const arrayCtx = $$props.createArrayContext(ctx, () => $$props.config, () => value(), (v) => value(v));
  setArrayContext(arrayCtx);
  const ArrayItem = tag(user_derived(() => getComponent(ctx, "arrayItemField", $$props.config)), "ArrayItem");
  const Template = tag(user_derived(() => getComponent(ctx, "arrayTemplate", $$props.config)), "Template");
  const Button = tag(user_derived(() => getComponent(ctx, "button", $$props.config)), "Button");
  var fragment_2 = comment();
  var node_2 = first_child(fragment_2);
  const expression = user_derived(() => arrayCtx.canAdd() ? addButton : void 0);
  component(node_2, () => get(Template), ($$anchor2, Template_1) => {
    Template_1($$anchor2, {
      type: "template",
      get errors() {
        return arrayCtx.errors;
      },
      get config() {
        return $$props.config;
      },
      get value() {
        return value();
      },
      get addButton() {
        return get(expression);
      },
      get uiOption() {
        return $$props.uiOption;
      },
      children: wrap_snippet(Array_base, ($$anchor3, $$slotProps) => {
        var fragment_3 = comment();
        var node_3 = first_child(fragment_3);
        {
          var consequent = ($$anchor4) => {
            var fragment_4 = comment();
            var node_4 = first_child(fragment_4);
            validate_each_keys(value, (item, index) => arrayCtx.key(index));
            each(node_4, 19, value, (item, index) => arrayCtx.key(index), ($$anchor5, item, index) => {
              var fragment_5 = comment();
              const cfg = user_derived(() => arrayCtx.itemConfig($$props.config, get(item), get(index)));
              get(cfg);
              var node_5 = first_child(fragment_5);
              validate_binding("bind:value={value[index]}", value, () => get(index), 72, 8);
              const expression_1 = user_derived(() => retrieveTranslate(ctx, get(cfg)));
              component(node_5, () => get(ArrayItem), ($$anchor6, ArrayItem_1) => {
                $$ownership_validator.binding("value", ArrayItem_1, () => value()[get(index)]);
                ArrayItem_1($$anchor6, {
                  type: "field",
                  get index() {
                    return get(index);
                  },
                  get config() {
                    return get(cfg);
                  },
                  uiOption: (opt) => retrieveUiOption(ctx, get(cfg), opt),
                  get translate() {
                    return get(expression_1);
                  },
                  get value() {
                    return value()[get(index)];
                  },
                  set value($$value) {
                    $$ownership_validator.mutation("value", ["value", get(index)], value(value()[get(index)] = $$value, true), 72, 20);
                  }
                });
              });
              append($$anchor5, fragment_5);
            });
            append($$anchor4, fragment_4);
          };
          if_block(node_3, ($$render) => {
            if (isSchemaArrayValue(value())) $$render(consequent);
          });
        }
        append($$anchor3, fragment_3);
      }),
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment_2);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Array_base = hmr(Array_base, () => Array_base[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Array_base[HMR].source;
    set(Array_base[HMR].source, module.default[HMR].original);
  });
}
var array_base_default = Array_base;

// node_modules/@sjsf/form/dist/fields/array/array-field.svelte
Array_field[FILENAME] = "node_modules/@sjsf/form/dist/fields/array/array-field.svelte";
function Array_field($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Array_field);
  var $$ownership_validator = create_ownership_validator($$props);
  let value = prop($$props, "value", 15);
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("value", array_base_default, value);
    array_base_default(node, {
      type: "field",
      get config() {
        return $$props.config;
      },
      get uiOption() {
        return $$props.uiOption;
      },
      get translate() {
        return $$props.translate;
      },
      get createArrayContext() {
        return createArrayContext;
      },
      get value() {
        return value();
      },
      set value($$value) {
        value($$value);
      }
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Array_field = hmr(Array_field, () => Array_field[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Array_field[HMR].source;
    set(Array_field[HMR].source, module.default[HMR].original);
  });
}
var array_field_default = Array_field;

// node_modules/@sjsf/form/dist/fields/array/tuple-field.svelte
Tuple_field[FILENAME] = "node_modules/@sjsf/form/dist/fields/array/tuple-field.svelte";
function Tuple_field($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Tuple_field);
  var $$ownership_validator = create_ownership_validator($$props);
  let value = prop($$props, "value", 15);
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("value", array_base_default, value);
    array_base_default(node, {
      type: "field",
      get config() {
        return $$props.config;
      },
      get uiOption() {
        return $$props.uiOption;
      },
      get translate() {
        return $$props.translate;
      },
      get createArrayContext() {
        return createTupleContext;
      },
      get value() {
        return value();
      },
      set value($$value) {
        value($$value);
      }
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tuple_field = hmr(Tuple_field, () => Tuple_field[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tuple_field[HMR].source;
    set(Tuple_field[HMR].source, module.default[HMR].original);
  });
}
var tuple_field_default = Tuple_field;

// node_modules/@sjsf/form/dist/fields/array/array-item-field.svelte
Array_item_field[FILENAME] = "node_modules/@sjsf/form/dist/fields/array/array-item-field.svelte";
var root_2 = add_locations(from_html(`<!> <!>`, 1), Array_item_field[FILENAME], []);
var root_1 = add_locations(from_html(`<!> <!> <!>`, 1), Array_item_field[FILENAME], []);
function Array_item_field($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Array_item_field);
  var $$ownership_validator = create_ownership_validator($$props);
  const buttons = wrap_snippet(Array_item_field, function($$anchor2) {
    validate_snippet_args(...arguments);
    var fragment = root_1();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor3) => {
        var fragment_1 = root_2();
        var node_1 = first_child(fragment_1);
        const expression = user_derived(() => !get(canMoveUp));
        component(node_1, () => get(Button), ($$anchor4, Button_1) => {
          Button_1($$anchor4, {
            get errors() {
              return get(errors);
            },
            get config() {
              return $$props.config;
            },
            type: "array-item-move-up",
            get disabled() {
              return get(expression);
            },
            onclick: () => {
              arrayCtx.moveItemUp($$props.index);
            },
            children: wrap_snippet(Array_item_field, ($$anchor5, $$slotProps) => {
              var fragment_2 = comment();
              var node_2 = first_child(fragment_2);
              text_default(node_2, {
                get config() {
                  return $$props.config;
                },
                id: "move-array-item-up",
                get translate() {
                  return $$props.translate;
                }
              });
              append($$anchor5, fragment_2);
            }),
            $$slots: { default: true }
          });
        });
        var node_3 = sibling(node_1, 2);
        const expression_1 = user_derived(() => !get(canMoveDown));
        component(node_3, () => get(Button), ($$anchor4, Button_2) => {
          Button_2($$anchor4, {
            get errors() {
              return get(errors);
            },
            get config() {
              return $$props.config;
            },
            get disabled() {
              return get(expression_1);
            },
            type: "array-item-move-down",
            onclick: () => {
              arrayCtx.moveItemDown($$props.index);
            },
            children: wrap_snippet(Array_item_field, ($$anchor5, $$slotProps) => {
              var fragment_3 = comment();
              var node_4 = first_child(fragment_3);
              text_default(node_4, {
                get config() {
                  return $$props.config;
                },
                id: "move-array-item-down",
                get translate() {
                  return $$props.translate;
                }
              });
              append($$anchor5, fragment_3);
            }),
            $$slots: { default: true }
          });
        });
        append($$anchor3, fragment_1);
      };
      if_block(node, ($$render) => {
        if (arrayCtx.orderable) $$render(consequent);
      });
    }
    var node_5 = sibling(node, 2);
    {
      var consequent_1 = ($$anchor3) => {
        var fragment_4 = comment();
        var node_6 = first_child(fragment_4);
        component(node_6, () => get(Button), ($$anchor4, Button_3) => {
          Button_3($$anchor4, {
            get errors() {
              return get(errors);
            },
            get config() {
              return $$props.config;
            },
            type: "array-item-copy",
            onclick: () => {
              arrayCtx.copyItem($$props.index);
            },
            disabled: false,
            children: wrap_snippet(Array_item_field, ($$anchor5, $$slotProps) => {
              var fragment_5 = comment();
              var node_7 = first_child(fragment_5);
              text_default(node_7, {
                get config() {
                  return $$props.config;
                },
                id: "copy-array-item",
                get translate() {
                  return $$props.translate;
                }
              });
              append($$anchor5, fragment_5);
            }),
            $$slots: { default: true }
          });
        });
        append($$anchor3, fragment_4);
      };
      if_block(node_5, ($$render) => {
        if (get(canCopy)) $$render(consequent_1);
      });
    }
    var node_8 = sibling(node_5, 2);
    {
      var consequent_2 = ($$anchor3) => {
        var fragment_6 = comment();
        var node_9 = first_child(fragment_6);
        component(node_9, () => get(Button), ($$anchor4, Button_4) => {
          Button_4($$anchor4, {
            get errors() {
              return get(errors);
            },
            get config() {
              return $$props.config;
            },
            disabled: false,
            type: "array-item-remove",
            onclick: () => {
              arrayCtx.removeItem($$props.index);
            },
            children: wrap_snippet(Array_item_field, ($$anchor5, $$slotProps) => {
              var fragment_7 = comment();
              var node_10 = first_child(fragment_7);
              text_default(node_10, {
                get config() {
                  return $$props.config;
                },
                id: "remove-array-item",
                get translate() {
                  return $$props.translate;
                }
              });
              append($$anchor5, fragment_7);
            }),
            $$slots: { default: true }
          });
        });
        append($$anchor3, fragment_6);
      };
      if_block(node_8, ($$render) => {
        if (get(canRemove)) $$render(consequent_2);
      });
    }
    append($$anchor2, fragment);
  });
  let value = prop($$props, "value", 15);
  const ctx = getFormContext();
  const arrayCtx = getArrayContext();
  const Template = tag(user_derived(() => getComponent(ctx, "arrayItemTemplate", $$props.config)), "Template");
  const Field = tag(user_derived(() => getFieldComponent(ctx, $$props.config)), "Field");
  const Button = tag(user_derived(() => getComponent(ctx, "button", $$props.config)), "Button");
  const canCopy = tag(user_derived(() => arrayCtx.canCopy($$props.index)), "canCopy");
  const canRemove = tag(user_derived(() => arrayCtx.canRemove($$props.index)), "canRemove");
  const canMoveUp = tag(user_derived(() => arrayCtx.canMoveUp($$props.index)), "canMoveUp");
  const canMoveDown = tag(user_derived(() => arrayCtx.canMoveDown($$props.index)), "canMoveDown");
  const toolbar = tag(user_derived(() => get(canCopy) || get(canRemove) || get(canMoveUp) || get(canMoveDown)), "toolbar");
  const errors = tag(user_derived(() => getErrors(ctx, $$props.config.id)), "errors");
  var fragment_8 = comment();
  var node_11 = first_child(fragment_8);
  const expression_2 = user_derived(() => get(toolbar) ? buttons : void 0);
  component(node_11, () => get(Template), ($$anchor2, Template_1) => {
    Template_1($$anchor2, {
      type: "template",
      get index() {
        return $$props.index;
      },
      get value() {
        return value();
      },
      get config() {
        return $$props.config;
      },
      get errors() {
        return get(errors);
      },
      get buttons() {
        return get(expression_2);
      },
      get uiOption() {
        return $$props.uiOption;
      },
      children: wrap_snippet(Array_item_field, ($$anchor3, $$slotProps) => {
        var fragment_9 = comment();
        var node_12 = first_child(fragment_9);
        component(node_12, () => get(Field), ($$anchor4, Field_1) => {
          $$ownership_validator.binding("value", Field_1, value);
          Field_1($$anchor4, {
            type: "field",
            get config() {
              return $$props.config;
            },
            get uiOption() {
              return $$props.uiOption;
            },
            get translate() {
              return $$props.translate;
            },
            get value() {
              return value();
            },
            set value($$value) {
              value($$value);
            }
          });
        });
        append($$anchor3, fragment_9);
      }),
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment_8);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Array_item_field = hmr(Array_item_field, () => Array_item_field[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Array_item_field[HMR].source;
    set(Array_item_field[HMR].source, module.default[HMR].original);
  });
}
var array_item_field_default = Array_item_field;

// node_modules/@sjsf/form/dist/fields/object/model.js
function generateNewKey(value, preferredKey, additionalPropertyKey) {
  let index = 0;
  let newKey;
  do {
    newKey = additionalPropertyKey(preferredKey, index++);
  } while (newKey in value);
  return newKey;
}
function createAdditionalPropertyKey(preferredKey, attempt) {
  return attempt === 0 ? preferredKey : `${preferredKey}-${attempt}`;
}
function createOriginalKeysOrder(properties) {
  const order = [];
  const keys = Object.keys(properties);
  for (const key of keys) {
    const property = properties[key];
    if (!isSchema(property) || ADDITIONAL_PROPERTY_FLAG in property) {
      continue;
    }
    order.push(key);
  }
  if (order.length < keys.length) {
    order.push("*");
  }
  return order;
}

// node_modules/@sjsf/form/dist/fields/object/context.svelte.js
var OBJECT_CONTEXT = Symbol("object-context");
function getObjectContext() {
  return getContext(OBJECT_CONTEXT);
}
function setObjectContext(ctx) {
  setContext(OBJECT_CONTEXT, ctx);
}
function createObjectContext(ctx, config, value, setValue, translate) {
  const retrievedSchema = tag(user_derived(() => retrieveSchema(ctx, config().schema, value())), "retrievedSchema");
  let lastSchemaProperties = void 0;
  const schemaProperties = tag(
    user_derived(() => {
      if (!isSchemaDeepEqual(lastSchemaProperties, get(retrievedSchema).properties)) {
        lastSchemaProperties = snapshot(get(retrievedSchema).properties);
      }
      return lastSchemaProperties;
    }),
    "schemaProperties"
  );
  user_effect(() => {
    get(schemaProperties);
    setValue(untrack(() => getDefaultFieldState(ctx, get(retrievedSchema), value())));
  });
  const uiOption = (opt) => retrieveUiOption(ctx, config(), opt);
  const schemaPropertiesOrder = tag(user_derived(() => isSchemaObjectValue(get(schemaProperties)) ? orderProperties(get(schemaProperties), uiOption("order") ?? createOriginalKeysOrder(get(schemaProperties))) : []), "schemaPropertiesOrder");
  const requiredProperties = tag(user_derived(() => new Set(get(retrievedSchema).required)), "requiredProperties");
  const getAdditionalPropertySchema = tag(
    user_derived(() => {
      const { additionalProperties, patternProperties } = get(retrievedSchema);
      if (isSchemaObjectValue(additionalProperties)) {
        return (val) => retrieveSchema(ctx, additionalProperties, val);
      }
      let patterns;
      if (strict_equals(patternProperties, void 0) || (patterns = Object.keys(patternProperties), strict_equals(patterns.length, 0))) {
        return () => ({});
      }
      const pairs = patterns.map((pattern) => {
        const property = patternProperties[pattern];
        return [
          new RegExp(pattern),
          strict_equals(typeof property, "boolean") ? {} : property
        ];
      });
      return (val, key) => retrieveSchema(ctx, pairs.find(([p]) => p.test(key))?.[1] ?? pairs[0][1], val);
    }),
    "getAdditionalPropertySchema"
  );
  const canExpand = tag(user_derived(() => strict_equals(uiOption("expandable"), false, false) && isSchemaExpandable(get(retrievedSchema), value())), "canExpand");
  const errors = tag(user_derived(() => getErrors(ctx, config().id)), "errors");
  const newKeyPrefix = tag(user_derived(() => translate("additional-property", {})), "newKeyPrefix");
  function validate(val) {
    const m = ctx.fieldsValidationMode;
    if (!(m & ON_OBJECT_CHANGE) || m & AFTER_SUBMITTED && !ctx.isSubmitted) {
      return;
    }
    validateField(ctx, config(), val);
  }
  const additionalPropertyKey = tag(user_derived(() => uiOption("additionalPropertyKey") ?? createAdditionalPropertyKey), "additionalPropertyKey");
  return {
    get errors() {
      return get(errors);
    },
    get canExpand() {
      return get(canExpand);
    },
    get propertiesOrder() {
      return get(schemaPropertiesOrder);
    },
    isAdditionalProperty(property) {
      return isAdditionalProperty(get(schemaProperties), property);
    },
    propertyConfig(config2, property, isAdditional) {
      const definition = get(schemaProperties)[property] ?? false;
      const schema = strict_equals(typeof definition, "boolean") ? {} : definition;
      const uiSchema = retrieveUiSchema(ctx, isAdditional ? config2.uiSchema.additionalProperties : config2.uiSchema[property]);
      return {
        id: createChildId(config2.id, property, ctx),
        name: property,
        title: uiTitleOption(ctx, uiSchema) ?? schema.title ?? property,
        schema,
        uiSchema,
        required: get(requiredProperties).has(property)
      };
    },
    addProperty() {
      const val = value();
      if (strict_equals(val, void 0)) {
        return;
      }
      const newKey = generateNewKey(val, get(newKeyPrefix), get(additionalPropertyKey));
      const additionalPropertySchema = get(getAdditionalPropertySchema)(val, newKey);
      val[newKey] = getDefaultFieldState(ctx, additionalPropertySchema, void 0) ?? getDefaultValueForType(getSimpleSchemaType(additionalPropertySchema));
      validate(val);
    },
    removeProperty(prop2) {
      const val = value();
      if (strict_equals(val, void 0)) {
        return;
      }
      delete val[prop2];
      validate(val);
    },
    renameProperty(oldProp, newProp, fieldConfig) {
      const val = value();
      if (strict_equals(val, void 0)) {
        return;
      }
      const newKey = generateNewKey(val, newProp, get(additionalPropertyKey));
      if (!validateAdditionalPropertyKey(ctx, config(), newKey, fieldConfig)) {
        return;
      }
      val[newKey] = val[oldProp];
      delete val[oldProp];
      validate(val);
    }
  };
}

// node_modules/@sjsf/form/dist/fields/object/object-field.svelte
Object_field[FILENAME] = "node_modules/@sjsf/form/dist/fields/object/object-field.svelte";
function Object_field($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Object_field);
  var $$ownership_validator = create_ownership_validator($$props);
  const addButton = wrap_snippet(Object_field, function($$anchor2) {
    validate_snippet_args(...arguments);
    var fragment = comment();
    var node = first_child(fragment);
    component(node, () => get(Button), ($$anchor3, Button_1) => {
      Button_1($$anchor3, {
        type: "object-property-add",
        get config() {
          return $$props.config;
        },
        get errors() {
          return objCtx.errors;
        },
        disabled: false,
        get onclick() {
          return objCtx.addProperty;
        },
        children: wrap_snippet(Object_field, ($$anchor4, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          text_default(node_1, {
            get config() {
              return $$props.config;
            },
            id: "add-object-property",
            get translate() {
              return $$props.translate;
            }
          });
          append($$anchor4, fragment_1);
        }),
        $$slots: { default: true }
      });
    });
    append($$anchor2, fragment);
  });
  const ctx = getFormContext();
  let value = prop($$props, "value", 15);
  const objCtx = createObjectContext(ctx, () => $$props.config, () => value(), (v) => value(v), $$props.translate);
  setObjectContext(objCtx);
  const ObjectProperty = tag(user_derived(() => getComponent(ctx, "objectPropertyField", $$props.config)), "ObjectProperty");
  const Template = tag(user_derived(() => getComponent(ctx, "objectTemplate", $$props.config)), "Template");
  const Button = tag(user_derived(() => getComponent(ctx, "button", $$props.config)), "Button");
  var fragment_2 = comment();
  var node_2 = first_child(fragment_2);
  const expression = user_derived(() => objCtx.canExpand ? addButton : void 0);
  component(node_2, () => get(Template), ($$anchor2, Template_1) => {
    Template_1($$anchor2, {
      type: "template",
      get value() {
        return value();
      },
      get config() {
        return $$props.config;
      },
      get errors() {
        return objCtx.errors;
      },
      get addButton() {
        return get(expression);
      },
      get uiOption() {
        return $$props.uiOption;
      },
      children: wrap_snippet(Object_field, ($$anchor3, $$slotProps) => {
        var fragment_3 = comment();
        var node_3 = first_child(fragment_3);
        {
          var consequent = ($$anchor4) => {
            var fragment_4 = comment();
            var node_4 = first_child(fragment_4);
            validate_each_keys(() => objCtx.propertiesOrder, (property) => property);
            each(node_4, 16, () => objCtx.propertiesOrder, (property) => property, ($$anchor5, property) => {
              var fragment_5 = comment();
              const isAdditional = user_derived(() => objCtx.isAdditionalProperty(property));
              get(isAdditional);
              const cfg = user_derived(() => objCtx.propertyConfig($$props.config, property, get(isAdditional)));
              get(cfg);
              var node_5 = first_child(fragment_5);
              validate_binding("bind:value={value[property]}", value, () => property, 66, 8);
              const expression_1 = user_derived(() => retrieveTranslate(ctx, get(cfg)));
              component(node_5, () => get(ObjectProperty), ($$anchor6, ObjectProperty_1) => {
                $$ownership_validator.binding("value", ObjectProperty_1, () => value()[property]);
                ObjectProperty_1($$anchor6, {
                  type: "field",
                  get property() {
                    return property;
                  },
                  get isAdditional() {
                    return get(isAdditional);
                  },
                  get config() {
                    return get(cfg);
                  },
                  uiOption: (opt) => retrieveUiOption(ctx, get(cfg), opt),
                  get translate() {
                    return get(expression_1);
                  },
                  get value() {
                    return value()[property];
                  },
                  set value($$value) {
                    $$ownership_validator.mutation("value", ["value", property], value(value()[property] = $$value, true), 66, 20);
                  }
                });
              });
              append($$anchor5, fragment_5);
            });
            append($$anchor4, fragment_4);
          };
          if_block(node_3, ($$render) => {
            if (isSchemaObjectValue(value())) $$render(consequent);
          });
        }
        append($$anchor3, fragment_3);
      }),
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment_2);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Object_field = hmr(Object_field, () => Object_field[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Object_field[HMR].source;
    set(Object_field[HMR].source, module.default[HMR].original);
  });
}
var object_field_default = Object_field;

// node_modules/@sjsf/form/dist/fields/object/object-key-input.svelte
Object_key_input[FILENAME] = "node_modules/@sjsf/form/dist/fields/object/object-key-input.svelte";
function Object_key_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Object_key_input);
  const ctx = getFormContext();
  const objCtx = getObjectContext();
  const id = tag(user_derived(() => createPseudoId($$props.parentId, "key-input", ctx)), "id");
  const config = tag(
    user_derived(() => ({
      id: get(id),
      name: get(id),
      title: uiTitleOption(ctx, $$props.uiSchema) ?? $$props.translate("key-input-title", { name: $$props.property }),
      schema: { type: "string" },
      uiSchema: $$props.uiSchema,
      required: true
    })),
    "config"
  );
  const Template = tag(user_derived(() => getComponent(ctx, "fieldTemplate", get(config))), "Template");
  const widgetType = "textWidget";
  const Widget = tag(user_derived(() => getComponent(ctx, widgetType, get(config))), "Widget");
  let key = tag(user_derived(() => $$props.property), "key");
  const handlers = {
    onblur: () => {
      if (strict_equals(get(key), void 0) || strict_equals(get(key), $$props.property)) {
        return;
      }
      objCtx.renameProperty($$props.property, get(key), get(config));
    }
  };
  const errors = tag(user_derived(() => getErrors(ctx, get(id))), "errors");
  const uiOption = (opt) => retrieveUiOption(ctx, get(config), opt);
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => get(Template), ($$anchor2, Template_1) => {
    Template_1($$anchor2, {
      type: "template",
      showTitle: true,
      useLabel: true,
      widgetType,
      get value() {
        return $$props.property;
      },
      get config() {
        return get(config);
      },
      get errors() {
        return get(errors);
      },
      uiOption,
      children: wrap_snippet(Object_key_input, ($$anchor3, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        component(node_1, () => get(Widget), ($$anchor4, Widget_1) => {
          Widget_1($$anchor4, {
            type: "widget",
            get errors() {
              return get(errors);
            },
            get handlers() {
              return handlers;
            },
            get config() {
              return get(config);
            },
            uiOption,
            get value() {
              return get(key);
            },
            set value($$value) {
              set(key, $$value, true);
            }
          });
        });
        append($$anchor3, fragment_1);
      }),
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Object_key_input = hmr(Object_key_input, () => Object_key_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Object_key_input[HMR].source;
    set(Object_key_input[HMR].source, module.default[HMR].original);
  });
}
var object_key_input_default = Object_key_input;

// node_modules/@sjsf/form/dist/fields/object/object-property-field.svelte
Object_property_field[FILENAME] = "node_modules/@sjsf/form/dist/fields/object/object-property-field.svelte";
function Object_property_field($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Object_property_field);
  var $$ownership_validator = create_ownership_validator($$props);
  const keyInput = wrap_snippet(Object_property_field, function($$anchor2) {
    validate_snippet_args(...arguments);
    var fragment = comment();
    var node = first_child(fragment);
    const expression = user_derived(() => retrieveUiSchema(ctx, $$props.config.uiSchema.additionalPropertyKeyInput));
    object_key_input_default(node, {
      get translate() {
        return $$props.translate;
      },
      get property() {
        return $$props.property;
      },
      get parentId() {
        return $$props.config.id;
      },
      get uiSchema() {
        return get(expression);
      }
    });
    append($$anchor2, fragment);
  });
  const removeButton = wrap_snippet(Object_property_field, function($$anchor2) {
    validate_snippet_args(...arguments);
    var fragment_1 = comment();
    var node_1 = first_child(fragment_1);
    component(node_1, () => get(Button), ($$anchor3, Button_1) => {
      Button_1($$anchor3, {
        get errors() {
          return get(errors);
        },
        get config() {
          return $$props.config;
        },
        type: "object-property-remove",
        disabled: false,
        onclick: () => {
          objCtx.removeProperty($$props.property);
        },
        children: wrap_snippet(Object_property_field, ($$anchor4, $$slotProps) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          text_default(node_2, {
            get config() {
              return $$props.config;
            },
            id: "remove-object-property",
            get translate() {
              return $$props.translate;
            }
          });
          append($$anchor4, fragment_2);
        }),
        $$slots: { default: true }
      });
    });
    append($$anchor2, fragment_1);
  });
  let value = prop($$props, "value", 15);
  const ctx = getFormContext();
  const objCtx = getObjectContext();
  const Template = tag(user_derived(() => getComponent(ctx, "objectPropertyTemplate", $$props.config)), "Template");
  const Field = tag(user_derived(() => getFieldComponent(ctx, $$props.config)), "Field");
  const Button = tag(user_derived(() => getComponent(ctx, "button", $$props.config)), "Button");
  const errors = tag(user_derived(() => getErrors(ctx, $$props.config.id)), "errors");
  var fragment_3 = comment();
  var node_3 = first_child(fragment_3);
  const expression_1 = user_derived(() => $$props.isAdditional ? keyInput : void 0);
  const expression_2 = user_derived(() => $$props.isAdditional ? removeButton : void 0);
  component(node_3, () => get(Template), ($$anchor2, Template_1) => {
    Template_1($$anchor2, {
      type: "template",
      get property() {
        return $$props.property;
      },
      get value() {
        return value();
      },
      get config() {
        return $$props.config;
      },
      get errors() {
        return get(errors);
      },
      get keyInput() {
        return get(expression_1);
      },
      get removeButton() {
        return get(expression_2);
      },
      get uiOption() {
        return $$props.uiOption;
      },
      children: wrap_snippet(Object_property_field, ($$anchor3, $$slotProps) => {
        var fragment_4 = comment();
        var node_4 = first_child(fragment_4);
        component(node_4, () => get(Field), ($$anchor4, Field_1) => {
          $$ownership_validator.binding("value", Field_1, value);
          Field_1($$anchor4, {
            type: "field",
            get config() {
              return $$props.config;
            },
            get uiOption() {
              return $$props.uiOption;
            },
            get translate() {
              return $$props.translate;
            },
            get value() {
              return value();
            },
            set value($$value) {
              value($$value);
            }
          });
        });
        append($$anchor3, fragment_4);
      }),
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment_3);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Object_property_field = hmr(Object_property_field, () => Object_property_field[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Object_property_field[HMR].source;
    set(Object_property_field[HMR].source, module.default[HMR].original);
  });
}
var object_property_field_default = Object_property_field;

// node_modules/@sjsf/form/dist/fields/field-base.svelte
Field_base[FILENAME] = "node_modules/@sjsf/form/dist/fields/field-base.svelte";
function Field_base($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Field_base);
  const ctx = getFormContext();
  let value = prop($$props, "value", 15);
  const Template = tag(user_derived(() => getComponent(ctx, "fieldTemplate", $$props.config)), "Template");
  const Widget = tag(user_derived(() => getComponent(ctx, $$props.widgetType, $$props.config)), "Widget");
  const handlers = makeEventHandlers(ctx, () => validateField(ctx, $$props.config, value()));
  const errors = tag(user_derived(() => getErrors(ctx, $$props.config.id)), "errors");
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => get(Template), ($$anchor2, Template_1) => {
    Template_1($$anchor2, {
      type: "template",
      get showTitle() {
        return $$props.showTitle;
      },
      get useLabel() {
        return $$props.useLabel;
      },
      get widgetType() {
        return $$props.widgetType;
      },
      get uiOption() {
        return $$props.uiOption;
      },
      get value() {
        return value();
      },
      get config() {
        return $$props.config;
      },
      get errors() {
        return get(errors);
      },
      children: wrap_snippet(Field_base, ($$anchor3, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        var bind_get = () => $$props.fromValue(value());
        var bind_set = (v) => value($$props.toValue(v));
        component(node_1, () => get(Widget), ($$anchor4, Widget_1) => {
          Widget_1($$anchor4, {
            type: "widget",
            get config() {
              return $$props.config;
            },
            get errors() {
              return get(errors);
            },
            get uiOption() {
              return $$props.uiOption;
            },
            get value() {
              return bind_get();
            },
            set value($$value) {
              bind_set($$value);
            },
            get handlers() {
              return handlers;
            }
          });
        });
        append($$anchor3, fragment_1);
      }),
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Field_base = hmr(Field_base, () => Field_base[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Field_base[HMR].source;
    set(Field_base[HMR].source, module.default[HMR].original);
  });
}
var field_base_default = Field_base;

// node_modules/@sjsf/form/dist/fields/boolean.svelte
Boolean[FILENAME] = "node_modules/@sjsf/form/dist/fields/boolean.svelte";
function Boolean($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Boolean);
  var $$ownership_validator = create_ownership_validator($$props);
  let value = prop($$props, "value", 15);
  var fragment = comment();
  var node = first_child(fragment);
  const expression = user_derived(() => strict_equals($$props.uiOption("hideTitle"), false));
  {
    $$ownership_validator.binding("value", field_base_default, value);
    field_base_default(node, {
      get config() {
        return $$props.config;
      },
      get uiOption() {
        return $$props.uiOption;
      },
      widgetType: "checkboxWidget",
      get showTitle() {
        return get(expression);
      },
      useLabel: true,
      get fromValue() {
        return identity;
      },
      get toValue() {
        return identity;
      },
      get value() {
        return value();
      },
      set value($$value) {
        value($$value);
      }
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Boolean = hmr(Boolean, () => Boolean[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Boolean[HMR].source;
    set(Boolean[HMR].source, module.default[HMR].original);
  });
}
var boolean_default = Boolean;

// node_modules/@sjsf/form/dist/fields/integer.svelte
Integer[FILENAME] = "node_modules/@sjsf/form/dist/fields/integer.svelte";
function Integer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Integer);
  let value = prop($$props, "value", 15);
  var fragment = comment();
  var node = first_child(fragment);
  var bind_get = () => value();
  var bind_set = (v) => {
    if (Number.isInteger(v)) {
      value(v);
    } else if (strict_equals(v, void 0)) {
      value($$props.uiOption("numberEmptyValue"));
    }
  };
  field_base_default(node, {
    get config() {
      return $$props.config;
    },
    get uiOption() {
      return $$props.uiOption;
    },
    showTitle: true,
    useLabel: true,
    widgetType: "numberWidget",
    get value() {
      return bind_get();
    },
    set value($$value) {
      bind_set($$value);
    },
    get fromValue() {
      return identity;
    },
    get toValue() {
      return identity;
    }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Integer = hmr(Integer, () => Integer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Integer[HMR].source;
    set(Integer[HMR].source, module.default[HMR].original);
  });
}
var integer_default = Integer;

// node_modules/@sjsf/form/dist/fields/null.svelte
Null[FILENAME] = "node_modules/@sjsf/form/dist/fields/null.svelte";
function Null($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Null);
  let value = prop($$props, "value", 15);
  user_effect(() => {
    if (strict_equals(value(), void 0)) {
      value(null);
    }
  });
  const ctx = getFormContext();
  const Template = tag(user_derived(() => getComponent(ctx, "fieldTemplate", $$props.config)), "Template");
  const errors = tag(user_derived(() => getErrors(ctx, $$props.config.id)), "errors");
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => get(Template), ($$anchor2, Template_1) => {
    Template_1($$anchor2, {
      type: "template",
      showTitle: true,
      useLabel: false,
      widgetType: "nullField",
      get uiOption() {
        return $$props.uiOption;
      },
      get errors() {
        return get(errors);
      },
      get value() {
        return value();
      },
      get config() {
        return $$props.config;
      },
      children: wrap_snippet(Null, ($$anchor3, $$slotProps) => {
        next();
        var text2 = text();
        text2.nodeValue = "";
        append($$anchor3, text2);
      }),
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Null = hmr(Null, () => Null[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Null[HMR].source;
    set(Null[HMR].source, module.default[HMR].original);
  });
}
var null_default = Null;

// node_modules/@sjsf/form/dist/fields/number-field.svelte
Number_field[FILENAME] = "node_modules/@sjsf/form/dist/fields/number-field.svelte";
function Number_field($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Number_field);
  var $$ownership_validator = create_ownership_validator($$props);
  let value = prop($$props, "value", 15);
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("value", field_base_default, value);
    field_base_default(node, {
      get config() {
        return $$props.config;
      },
      get uiOption() {
        return $$props.uiOption;
      },
      showTitle: true,
      useLabel: true,
      widgetType: "numberWidget",
      get fromValue() {
        return identity;
      },
      toValue: (v) => v ?? $$props.uiOption("numberEmptyValue"),
      get value() {
        return value();
      },
      set value($$value) {
        value($$value);
      }
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Number_field = hmr(Number_field, () => Number_field[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Number_field[HMR].source;
    set(Number_field[HMR].source, module.default[HMR].original);
  });
}
var number_field_default = Number_field;

// node_modules/@sjsf/form/dist/fields/string.svelte
String[FILENAME] = "node_modules/@sjsf/form/dist/fields/string.svelte";
function String($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, String);
  var $$ownership_validator = create_ownership_validator($$props);
  let value = prop($$props, "value", 15);
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("value", field_base_default, value);
    field_base_default(node, {
      get config() {
        return $$props.config;
      },
      get uiOption() {
        return $$props.uiOption;
      },
      showTitle: true,
      useLabel: true,
      widgetType: "textWidget",
      get fromValue() {
        return identity;
      },
      toValue: (v) => v || $$props.uiOption("stringEmptyValue"),
      get value() {
        return value();
      },
      set value($$value) {
        value($$value);
      }
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  String = hmr(String, () => String[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = String[HMR].source;
    set(String[HMR].source, module.default[HMR].original);
  });
}
var string_default = String;

// node_modules/@sjsf/form/dist/fields/any-of.svelte
Any_of[FILENAME] = "node_modules/@sjsf/form/dist/fields/any-of.svelte";
function Any_of($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Any_of);
  var $$ownership_validator = create_ownership_validator($$props);
  let value = prop($$props, "value", 15);
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("value", combination_default, value);
    combination_default(node, {
      type: "field",
      get config() {
        return $$props.config;
      },
      get uiOption() {
        return $$props.uiOption;
      },
      get translate() {
        return $$props.translate;
      },
      get combinationKey() {
        return ANY_OF_KEY;
      },
      get value() {
        return value();
      },
      set value($$value) {
        value($$value);
      }
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Any_of = hmr(Any_of, () => Any_of[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Any_of[HMR].source;
    set(Any_of[HMR].source, module.default[HMR].original);
  });
}
var any_of_default = Any_of;

// node_modules/@sjsf/form/dist/fields/one-of.svelte
One_of[FILENAME] = "node_modules/@sjsf/form/dist/fields/one-of.svelte";
function One_of($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, One_of);
  var $$ownership_validator = create_ownership_validator($$props);
  let value = prop($$props, "value", 15);
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("value", combination_default, value);
    combination_default(node, {
      type: "field",
      get config() {
        return $$props.config;
      },
      get uiOption() {
        return $$props.uiOption;
      },
      get translate() {
        return $$props.translate;
      },
      get combinationKey() {
        return ONE_OF_KEY;
      },
      get value() {
        return value();
      },
      set value($$value) {
        value($$value);
      }
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  One_of = hmr(One_of, () => One_of[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = One_of[HMR].source;
    set(One_of[HMR].source, module.default[HMR].original);
  });
}
var one_of_default = One_of;

// node_modules/@sjsf/form/dist/fields/resolver/definitions.js
var definitions = Object.assign({}, exports_exports);

export {
  definitions
};
//# sourceMappingURL=chunk-AKJG6NNY.js.map
