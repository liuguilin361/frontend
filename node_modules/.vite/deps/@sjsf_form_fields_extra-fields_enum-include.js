import {
  definitions
} from "./chunk-AKJG6NNY.js";
import {
  createPseudoId,
  getComponent,
  getErrors,
  getFormContext,
  makeEventHandlers,
  retrieveUiSchema,
  validateField
} from "./chunk-TH67H3ZF.js";
import "./chunk-4CFPDER2.js";
import {
  getSchemaConstantValue
} from "./chunk-L5BEN6GZ.js";
import "./chunk-3I4LE53J.js";
import "./chunk-QKPL34R6.js";
import "./chunk-NMJMEXLF.js";
import "./chunk-7RQDXF5S.js";
import {
  check_target,
  component,
  create_ownership_validator,
  hmr,
  legacy_api,
  prop,
  wrap_snippet
} from "./chunk-C3TCUAZZ.js";
import "./chunk-U7P2NEEE.js";
import {
  append,
  comment
} from "./chunk-4O4LVGQI.js";
import {
  FILENAME,
  HMR,
  first_child,
  get,
  pop,
  push,
  set,
  tag,
  user_derived
} from "./chunk-YEGJDBKW.js";
import "./chunk-NXGWPDOQ.js";
import "./chunk-HNWPC2PS.js";
import "./chunk-TXI4FRAY.js";
import "./chunk-RVAV4ZRS.js";
import "./chunk-G3PMV62Z.js";

// node_modules/@sjsf/form/dist/fields/enum.js
function getAltSchemas(schema, uiSchema) {
  return schema.anyOf ? [schema.anyOf, uiSchema.anyOf] : [schema.oneOf, uiSchema.oneOf];
}
function createOptions(ctx, config, uiOption, schema) {
  const enumValues = schema.enum;
  const disabledValues = new Set(uiOption("disabledEnumValues"));
  if (enumValues) {
    const enumNames = uiOption("enumNames");
    return enumValues.map((value, index) => {
      const label = enumNames?.[index] ?? String(value);
      return {
        id: createPseudoId(config.id, index, ctx),
        label,
        value,
        disabled: disabledValues.has(value)
      };
    });
  }
  const [altSchemas, altUiSchemas] = getAltSchemas(schema, config.uiSchema);
  return altSchemas && altSchemas.map((altSchemaDef, index) => {
    if (typeof altSchemaDef === "boolean") {
      throw new Error(`Invalid enum definition in anyOf ${index}`);
    }
    const value = getSchemaConstantValue(altSchemaDef);
    const label = retrieveUiSchema(ctx, altUiSchemas?.[index])["ui:options"]?.title ?? altSchemaDef.title ?? String(value);
    return {
      id: createPseudoId(config.id, index, ctx),
      schema: altSchemaDef,
      label,
      value,
      disabled: disabledValues.has(value)
    };
  });
}

// node_modules/@sjsf/form/dist/fields/extra-fields/enum.svelte
Enum[FILENAME] = "node_modules/@sjsf/form/dist/fields/extra-fields/enum.svelte";
function Enum($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Enum);
  var $$ownership_validator = create_ownership_validator($$props);
  let value = prop($$props, "value", 15);
  const ctx = getFormContext();
  const Template = tag(user_derived(() => getComponent(ctx, "fieldTemplate", $$props.config)), "Template");
  const widgetType = "selectWidget";
  const Widget = tag(user_derived(() => getComponent(ctx, widgetType, $$props.config)), "Widget");
  const handlers = makeEventHandlers(ctx, () => validateField(ctx, $$props.config, value()));
  const options = tag(user_derived(() => createOptions(ctx, $$props.config, $$props.uiOption, $$props.config.schema) ?? []), "options");
  const errors = tag(user_derived(() => getErrors(ctx, $$props.config.id)), "errors");
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => get(Template), ($$anchor2, Template_1) => {
    Template_1($$anchor2, {
      type: "template",
      showTitle: true,
      useLabel: true,
      get uiOption() {
        return $$props.uiOption;
      },
      widgetType,
      get value() {
        return value();
      },
      get config() {
        return $$props.config;
      },
      get errors() {
        return get(errors);
      },
      children: wrap_snippet(Enum, ($$anchor3, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        component(node_1, () => get(Widget), ($$anchor4, Widget_1) => {
          $$ownership_validator.binding("value", Widget_1, value);
          Widget_1($$anchor4, {
            type: "widget",
            get handlers() {
              return handlers;
            },
            get config() {
              return $$props.config;
            },
            get errors() {
              return get(errors);
            },
            get uiOption() {
              return $$props.uiOption;
            },
            get options() {
              return get(options);
            },
            get value() {
              return value();
            },
            set value($$value) {
              value($$value);
            }
          });
        });
        append($$anchor3, fragment_1);
      }),
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Enum = hmr(Enum, () => Enum[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Enum[HMR].source;
    set(Enum[HMR].source, module.default[HMR].original);
  });
}
var enum_default = Enum;

// node_modules/@sjsf/form/dist/fields/extra-fields/enum-include.js
definitions.enumField = enum_default;
//# sourceMappingURL=@sjsf_form_fields_extra-fields_enum-include.js.map
