import {
  overrideByRecord
} from "./chunk-4CFPDER2.js";
import {
  defaultMerger,
  getClosestMatchingOption,
  getDefaultFormState,
  getSchemaDefinitionByPath,
  isFilesArray,
  isMultiSelect,
  isObject,
  isSelect,
  retrieveSchema,
  sanitizeDataForNewSchema
} from "./chunk-L5BEN6GZ.js";
import {
  SvelteMap
} from "./chunk-3I4LE53J.js";
import {
  add_locations,
  check_target,
  component,
  create_ownership_validator,
  each,
  hmr,
  if_block,
  legacy_api,
  log_if_contains_state,
  prop,
  rest_props,
  set_attribute,
  snippet,
  validate_binding,
  validate_each_keys,
  wrap_snippet
} from "./chunk-C3TCUAZZ.js";
import {
  append,
  comment,
  from_html,
  set_text,
  text
} from "./chunk-4O4LVGQI.js";
import {
  FILENAME,
  HMR,
  child,
  first_child,
  get,
  getContext,
  on,
  pop,
  proxy,
  push,
  reset,
  set,
  setContext,
  sibling,
  snapshot,
  state,
  strict_equals,
  tag,
  template_effect,
  untrack,
  user_derived,
  user_effect
} from "./chunk-YEGJDBKW.js";
import {
  true_default
} from "./chunk-HNWPC2PS.js";

// node_modules/@sjsf/form/dist/form/model.js
var DEFAULT_BOOLEAN_ENUM = [true, false];
function getRootSchemaTitleByPath(rootSchema, path) {
  const def = getSchemaDefinitionByPath(rootSchema, rootSchema, path);
  return typeof def === "object" ? def.title : void 0;
}

// node_modules/@sjsf/form/dist/form/ui-schema.js
function isUiSchemaRef(def) {
  return typeof def?.$ref === "string";
}
function resolveUiRef(rootSchema, schemaDef) {
  return isUiSchemaRef(schemaDef) ? rootSchema["ui:definitions"]?.[schemaDef.$ref] : schemaDef;
}
function resolveUiOption(uiSchemaRoot, uiOptionsRegistry, uiSchema, option) {
  let value = uiSchema["ui:options"]?.[option];
  if (value === void 0) {
    value = uiSchemaRoot["ui:globalOptions"]?.[option];
  }
  if (typeof value === "string" && value.startsWith("registry:")) {
    return uiOptionsRegistry[value.substring(9)];
  }
  return value;
}
function getUiSchemaByPath(rootSchema, schemaDef, path) {
  let schema = resolveUiRef(rootSchema, schemaDef);
  for (let i = 0; i < path.length; i++) {
    if (schema === void 0) {
      return void 0;
    }
    const alt = schema.anyOf ?? schema.oneOf;
    if (alt) {
      let def;
      const slice = path.slice(i);
      for (const sub of alt) {
        def = getUiSchemaByPath(rootSchema, sub, slice);
        if (def !== void 0) {
          return def;
        }
      }
    }
    const k = path[i];
    const { items, additionalItems, additionalProperties } = schema;
    schema = resolveUiRef(rootSchema, schema[k] ?? (Array.isArray(items) ? items[k] : items) ?? additionalProperties ?? additionalItems);
  }
  return schema;
}
function getRootUiSchemaTitleByPath(uiSchemaRoot, path) {
  return getUiSchemaByPath(uiSchemaRoot, uiSchemaRoot, path)?.["ui:options"]?.title;
}

// node_modules/@sjsf/form/dist/form/errors.js
var AdditionalPropertyKeyError = class {
};
var ValidationProcessError = class {
  state;
  constructor(state2) {
    this.state = state2;
  }
};
function groupErrors(errors) {
  return new SvelteMap(SvelteMap.groupBy(errors, (error) => error.instanceId));
}

// node_modules/@sjsf/form/dist/form/validation.js
var ON_INPUT = 1;
var ON_CHANGE = ON_INPUT << 1;
var ON_BLUR = ON_CHANGE << 1;
var ON_ARRAY_CHANGE = ON_BLUR << 1;
var ON_OBJECT_CHANGE = ON_ARRAY_CHANGE << 1;
var AFTER_CHANGED = ON_OBJECT_CHANGE << 1;
var AFTER_TOUCHED = AFTER_CHANGED << 1;
var AFTER_SUBMITTED = AFTER_TOUCHED << 1;

// node_modules/@sjsf/form/dist/form/validator.js
function isFormValueValidator(v) {
  return "validateFormValue" in v;
}
function isAsyncFormValueValidator(v) {
  return "validateFormValueAsync" in v;
}
function isFieldValueValidator(v) {
  return "validateFieldValue" in v;
}
function isAsyncFieldValueValidator(v) {
  return "validateFieldValueAsync" in v;
}
function isAdditionalPropertyKeyValidator(v) {
  return "validateAdditionalPropertyKey" in v;
}

// node_modules/@sjsf/form/dist/form/merger.js
function createFormMerger(validator, rootSchema, options = {}) {
  return {
    mergeAllOf(schema) {
      return defaultMerger.mergeAllOf(schema);
    },
    mergeFormDataAndSchemaDefaults(formData, schema) {
      return getDefaultFormState(validator, defaultMerger, schema, formData, rootSchema, options.includeUndefinedValues, options);
    }
  };
}

// node_modules/@sjsf/form/dist/form/id.js
var DEFAULT_ID_PREFIX = "root";
var DEFAULT_ID_SEPARATOR = ".";
var DEFAULT_ID_PSEUDO_SEPARATOR = "::";
function pathToId(path, { idPrefix = DEFAULT_ID_PREFIX, idSeparator = DEFAULT_ID_SEPARATOR } = {}) {
  return path.length === 0 ? idPrefix : `${idPrefix}${idSeparator}${path.join(idSeparator)}`;
}
function createPseudoId(instanceId, element, { idPseudoSeparator = DEFAULT_ID_PSEUDO_SEPARATOR } = {}) {
  return `${instanceId}${idPseudoSeparator}${element}`;
}
function createChildId(arrayOrObjectId, indexOrProperty, { idSeparator = DEFAULT_ID_SEPARATOR } = {}) {
  return `${arrayOrObjectId}${idSeparator}${indexOrProperty}`;
}

// node_modules/@sjsf/form/dist/form/translation.js
function createTranslate(translation) {
  return (label, params) => {
    const translator = translation(label, params);
    if (translator === void 0) {
      return `Label "${label}" is not translated`;
    }
    return typeof translator === "string" ? translator : translator(params);
  };
}

// node_modules/@sjsf/form/dist/form/context/context.js
var FORM_CONTEXT = Symbol("form-context");
function getFormContext() {
  return getContext(FORM_CONTEXT);
}
function setFormContext(ctx) {
  setContext(FORM_CONTEXT, ctx);
}

// node_modules/@sjsf/form/dist/form/context/schema.js
function isSelect2(ctx, schema) {
  return isSelect(ctx.validator, ctx.merger, schema, ctx.schema);
}
function isMultiSelect2(ctx, schema) {
  return isMultiSelect(ctx.validator, ctx.merger, schema, ctx.schema);
}
function isFilesArray2(ctx, schema) {
  return isFilesArray(ctx.validator, ctx.merger, schema, ctx.schema);
}
function retrieveSchema2(ctx, schema, formData) {
  return retrieveSchema(ctx.validator, ctx.merger, schema, ctx.schema, formData);
}
function sanitizeDataForNewSchema2(ctx, newSchema, oldSchema, formData) {
  return sanitizeDataForNewSchema(ctx.validator, ctx.merger, ctx.schema, newSchema, oldSchema, formData);
}
function getClosestMatchingOption2(ctx, formData, options, selectedOption, discriminatorField) {
  return getClosestMatchingOption(ctx.validator, ctx.merger, ctx.schema, formData, options, selectedOption, discriminatorField);
}
function getDefaultFieldState(ctx, schema, formData) {
  return ctx.merger.mergeFormDataAndSchemaDefaults(formData, schema);
}

// node_modules/@sjsf/form/dist/form/context/ui-schema.js
function retrieveUiSchema(ctx, uiSchemaDef) {
  return resolveUiRef(ctx.uiSchemaRoot, uiSchemaDef) ?? {};
}
function resolveUiOption2(ctx, uiSchema, option) {
  return resolveUiOption(ctx.uiSchemaRoot, ctx.uiOptionsRegistry, uiSchema, option);
}
function uiTitleOption(ctx, uiSchema) {
  return resolveUiOption2(ctx, uiSchema, "title");
}
function retrieveUiOption(ctx, config, option) {
  return ctx.extraUiOptions?.(option, config) ?? resolveUiOption2(ctx, config.uiSchema, option);
}
function uiOptionProps(option) {
  return (props, config, ctx) => {
    return Object.assign(props, resolveUiOption2(ctx, config.uiSchema, option), ctx.extraUiOptions?.(option, config));
  };
}
function uiOptionNestedProps(option, selector) {
  return (props, config, ctx) => {
    const options = resolveUiOption2(ctx, config.uiSchema, option);
    const extraOptions = ctx.extraUiOptions?.(option, config);
    return Object.assign(props, options && selector(options), extraOptions && selector(extraOptions));
  };
}
function retrieveTranslate(ctx, config) {
  let translation = ctx.translation;
  const uiOption = resolveUiOption2(ctx, config.uiSchema, "translations");
  translation = uiOption ? overrideByRecord(translation, uiOption) : translation;
  const extraUiOption = ctx.extraUiOptions?.("translations", config);
  translation = extraUiOption ? overrideByRecord(translation, extraUiOption) : translation;
  return createTranslate(translation);
}

// node_modules/@sjsf/form/dist/form/context/validation.js
function getErrors(ctx, id) {
  return ctx.errors.get(id) ?? [];
}
function validateField(ctx, config, value) {
  ctx.fieldsValidation.run(config, value);
}
function validateAdditionalPropertyKey(ctx, config, key, fieldConfig) {
  const validator = ctx.validator;
  if (!isAdditionalPropertyKeyValidator(validator)) {
    return true;
  }
  const messages = validator.validateAdditionalPropertyKey(key, config.schema);
  ctx.errors.set(fieldConfig.id, messages.map((message) => ({
    propertyTitle: fieldConfig.title,
    message,
    error: new AdditionalPropertyKeyError()
  })));
  return messages.length === 0;
}

// node_modules/@sjsf/form/dist/form/context/event-handlers.svelte.js
function makeEventHandlers(ctx, validate) {
  let changed = tag(state(false), "changed");
  let touched = tag(state(false), "touched");
  user_effect(() => {
    if (ctx.isSubmitted) {
      return;
    }
    set(changed, false);
    set(touched, false);
  });
  const makeHandler = (event) => {
    const m = ctx.fieldsValidationMode;
    if (!(m & event) || m & AFTER_SUBMITTED && !ctx.isSubmitted || m & AFTER_CHANGED && !get(changed) || m & AFTER_TOUCHED && !get(touched)) {
      return;
    }
    return validate;
  };
  const onInput = tag(user_derived(() => makeHandler(ON_INPUT)), "onInput");
  const onChange = tag(user_derived(() => makeHandler(ON_CHANGE)), "onChange");
  const onBlur = tag(user_derived(() => makeHandler(ON_BLUR)), "onBlur");
  return {
    oninput() {
      get(onInput)?.();
    },
    onchange() {
      set(changed, true);
      ctx.isChanged = true;
      get(onChange)?.();
    },
    onblur() {
      set(touched, true);
      get(onBlur)?.();
    }
  };
}

// node_modules/@sjsf/form/dist/form/context/attributes.js
function composeProps(ctx, config, props, ...options) {
  for (let i = 0; i < options.length; i++) {
    props = options[i](props, config, ctx);
  }
  return props;
}
function assignProps(options) {
  return (props) => Object.assign(props, options);
}
function isDisabled(ctx, attributes) {
  return attributes?.disabled || ctx.disabled;
}
function disabledProp(obj, _, ctx) {
  obj.disabled ||= ctx.disabled;
  return obj;
}
function inputType(format) {
  switch (format) {
    case "date-time":
      return "datetime-local";
    case "uri":
      return "url";
    case "color":
    case "date":
    case "time":
    case "email":
      return format;
    default:
      return void 0;
  }
}
var DEFAULT_DESCRIBE_ELEMENTS = [
  "description",
  "help",
  "errors"
];
var DEFAULT_DESCRIBE_ELEMENTS_WITH_EXAMPLES = DEFAULT_DESCRIBE_ELEMENTS.concat("examples");
function describedBy(ctx, config) {
  return (Array.isArray(config.schema.examples) ? DEFAULT_DESCRIBE_ELEMENTS_WITH_EXAMPLES : DEFAULT_DESCRIBE_ELEMENTS).map((el) => createPseudoId(config.id, el, ctx)).join(" ");
}
function inputProps(handlers) {
  return (props, config, ctx) => {
    const { id, required, schema } = config;
    props.id = id;
    props.name = id;
    const type = inputType(schema.format);
    if (type !== void 0) {
      props.type = type;
    }
    props.required = required;
    props.minlength = schema.minLength;
    props.maxlength = schema.maxLength;
    props.pattern = schema.pattern;
    props.min = schema.minimum;
    props.max = schema.maximum;
    props.step = schema.multipleOf ?? (schema.type === "number" ? "any" : void 0);
    props.list = Array.isArray(schema.examples) ? createPseudoId(id, "examples", ctx) : void 0;
    props.readonly = schema.readOnly;
    props.oninput = handlers.oninput;
    props.onchange = handlers.onchange;
    props.onblur = handlers.onblur;
    props["aria-describedby"] = describedBy(ctx, config);
    return props;
  };
}
function textareaProps(handlers) {
  return (props, config, ctx) => {
    const { id, required, schema } = config;
    props.id = id;
    props.name = id;
    props.required = required;
    props.minlength = schema.minLength;
    props.maxlength = schema.maxLength;
    props.readonly = schema.readOnly;
    props.oninput = handlers.oninput;
    props.onchange = handlers.onchange;
    props.onblur = handlers.onblur;
    props["aria-describedby"] = describedBy(ctx, config);
    return props;
  };
}
function selectProps(handlers) {
  return (props, config, ctx) => {
    const { id, required } = config;
    props.id = id;
    props.name = id;
    props.required = required;
    props.oninput = handlers.oninput;
    props.onchange = handlers.onchange;
    props.onblur = handlers.onblur;
    props["aria-describedby"] = describedBy(ctx, config);
    return props;
  };
}
function forProp(props, config) {
  props.for = config.id;
  return props;
}
function idProp(element) {
  return (props, config, ctx) => {
    props.id = createPseudoId(config.id, element, ctx);
    return props;
  };
}
function tabindexProp(tabindex) {
  return (props) => {
    props.tabindex = tabindex;
    return props;
  };
}
function dataLayoutProp(type) {
  return (props) => {
    props["data-layout"] = type;
    return props;
  };
}
function buttonTypeProp(type) {
  return (props) => {
    props.type = type;
    return props;
  };
}
function descriptionAttributes(ctx, config, option, props) {
  return composeProps(ctx, config, props, idProp("description"), uiOptionProps(option));
}
function errorsListAttributes(ctx, config, option, props) {
  return composeProps(ctx, config, props, idProp("errors"), tabindexProp(-1), uiOptionProps(option));
}
function formAttributes(ctx, config, option, attributes, props) {
  return composeProps(ctx, config, props, uiOptionProps(option), assignProps(attributes));
}
function helpAttributes(ctx, config, option, props) {
  return composeProps(ctx, config, props, idProp("help"), uiOptionProps(option));
}
function labelAttributes(ctx, config, option, props) {
  return composeProps(ctx, config, props, forProp, uiOptionProps(option));
}
function titleAttributes(ctx, config, option, props) {
  return composeProps(ctx, config, props, idProp("title"), uiOptionProps(option));
}
function layoutAttributes(ctx, config, option, nestedOption, type, props) {
  return composeProps(ctx, config, props, dataLayoutProp(type), uiOptionProps(option), uiOptionNestedProps(nestedOption, (t) => t[type]));
}
function buttonAttributes(ctx, config, option, type, props) {
  return composeProps(ctx, config, props, buttonTypeProp(type), uiOptionProps(option), disabledProp);
}
function customInputAttributes(ctx, config, option, props) {
  return composeProps(ctx, config, props, uiOptionProps(option), disabledProp);
}
function inputAttributes(ctx, config, option, handlers, props) {
  return composeProps(ctx, config, props, inputProps(handlers), uiOptionProps(option), disabledProp);
}
function selectAttributes(ctx, config, option, handlers, props) {
  return composeProps(ctx, config, props, selectProps(handlers), uiOptionProps(option), disabledProp);
}
function textareaAttributes(ctx, config, option, handlers, props) {
  return composeProps(ctx, config, props, textareaProps(handlers), uiOptionProps(option), disabledProp);
}

// node_modules/@sjsf/form/dist/form/context/files.js
async function addFile(ctx, signal, data, value) {
  const { name, blob } = await ctx.dataUrlToBlob(signal, value);
  data.items.add(new File([blob], name, { type: blob.type }));
}
function addFiles(ctx, signal, data, values) {
  const promises = [];
  for (const value of values) {
    promises.push(addFile(ctx, signal, data, value));
  }
  return Promise.all(promises);
}

// node_modules/@sjsf/form/dist/form/error-message.svelte
Error_message[FILENAME] = "node_modules/@sjsf/form/dist/form/error-message.svelte";
function createMessage(message) {
  return (internal) => error_message_default(internal, { message });
}
var root = add_locations(from_html(`<pre style="color: red;"> </pre>`), Error_message[FILENAME], [[15, 0]]);
function Error_message($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Error_message);
  var pre = root();
  var text2 = child(pre, true);
  reset(pre);
  template_effect(() => set_text(text2, $$props.message));
  append($$anchor, pre);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Error_message = hmr(Error_message, () => Error_message[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Error_message[HMR].source;
    set(Error_message[HMR].source, module.default[HMR].original);
  });
}
var error_message_default = Error_message;

// node_modules/@sjsf/form/dist/form/context/components.js
function getComponent(ctx, type, config) {
  const component2 = config.uiSchema["ui:components"]?.[type];
  switch (typeof component2) {
    case "undefined":
      return ctx.theme(type, config) ?? createMessage(ctx.translate("component-not-found", { type }));
    case "string":
      return ctx.theme(component2, config) ?? createMessage(ctx.translate("component-not-found", {
        // @ts-expect-error
        type: component2
      }));
    default:
      return component2;
  }
}
function getFieldComponent(ctx, config) {
  return getComponent(ctx, ctx.fieldTypeResolver(config), config);
}

// node_modules/@sjsf/form/dist/lib/file.js
var CHUNK_SIZE = 8192;
function createDataURLtoBlob(schedulerYield) {
  return async (signal, dataURILike) => {
    if (!dataURILike.startsWith("data:")) {
      throw new Error("File is invalid: URI must be a dataURI");
    }
    const dataURI = dataURILike.slice(5);
    const splitted = dataURI.split(";base64,");
    if (splitted.length !== 2) {
      throw new Error("File is invalid: dataURI must be base64");
    }
    const [media, base64] = splitted;
    const [mime, ...mediaParams] = media.split(";");
    const type = mime || "";
    const name = decodeURI(mediaParams.map((param) => param.split("=")).find(([key]) => key === "name")?.[1] || "unknown");
    try {
      const binary = atob(base64);
      await schedulerYield({ signal });
      const array = new Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        if (i % CHUNK_SIZE === 0) {
          await schedulerYield({ signal });
        }
        array[i] = binary.charCodeAt(i);
      }
      const blob = new Blob([new Uint8Array(array)], { type });
      return { blob, name };
    } catch (error) {
      if (error instanceof DOMException && error.name === "AbortError") {
        throw error;
      }
      throw new Error("File is invalid: " + error.message);
    }
  };
}
function addNameToDataURL(dataURL, name) {
  return dataURL.replace(";base64", `;name=${encodeURIComponent(name)};base64`);
}
function fileToDataURL(signal, file) {
  const reader = new FileReader();
  const onAbort = () => {
    reader.abort();
  };
  signal.addEventListener("abort", onAbort);
  return new Promise((resolve, reject) => {
    reader.onerror = reject;
    reader.onabort = reject;
    reader.onload = (event) => {
      const result = event.target?.result;
      if (typeof result !== "string") {
        reject(new Error("File is invalid: result must be a string"));
        return;
      }
      resolve(addNameToDataURL(result, file.name));
    };
    reader.readAsDataURL(file);
  }).finally(() => {
    signal.removeEventListener("abort", onAbort);
  });
}

// node_modules/@sjsf/form/dist/lib/function.js
function noop() {
}
function identity(v) {
  return v;
}

// node_modules/@sjsf/form/dist/lib/action.svelte.js
var abortPrevious = () => "abort";
var waitPrevious = ({ status }) => strict_equals(status, "processing", false);
var InitializationError = class {
  state;
  constructor(state2) {
    this.state = state2;
  }
};
var CompletionError = class {
  state;
  constructor(state2) {
    this.state = state2;
  }
};
function createAction(options) {
  const delayedMs = tag(user_derived(() => options.delayedMs ?? 500), "delayedMs");
  const timeoutMs = tag(user_derived(() => options.timeoutMs ?? 8e3), "timeoutMs");
  if (true_default) {
    user_effect(() => {
      if (get(timeoutMs) < get(delayedMs)) {
        throw new Error("timeoutMs must be greater than delayedMs");
      }
    });
  }
  const combinator = tag(user_derived(() => options.combinator ?? waitPrevious), "combinator");
  let state2 = tag(state({ status: "idle" }), "state");
  let delayedCallbackId;
  let timeoutCallbackId;
  function clearTimeouts() {
    clearTimeout(delayedCallbackId);
    clearTimeout(timeoutCallbackId);
  }
  function abort(state3) {
    state3.abortController.abort();
  }
  function runEffect(promise, effect) {
    if (strict_equals(get(state2).status, "failed")) {
      throw new CompletionError(get(state2));
    }
    if (strict_equals(get(state2).status, "processing") && strict_equals(get(state2).promise, promise)) {
      clearTimeouts();
      effect();
    }
  }
  function initAbortController(decision) {
    if (strict_equals(get(state2).status, "processing")) {
      if (strict_equals(decision, "abort", false)) {
        return get(state2).abortController;
      }
      abort(get(state2));
    }
    return new AbortController();
  }
  async function run(decision, args) {
    if (strict_equals(decision, false)) {
      throw new InitializationError(get(state2));
    }
    const abortController = initAbortController(decision);
    const cleanPromise = options.execute(abortController.signal, ...args);
    if (strict_equals(decision, "untrack")) {
      return cleanPromise;
    }
    const promise = cleanPromise.then(
      (result) => {
        runEffect(promise, () => {
          set(state2, { status: "success" });
          options.onSuccess?.(result, ...args);
        });
        return result;
      },
      (error) => {
        runEffect(promise, () => {
          set(state2, { status: "failed", reason: "error", error });
          options.onFailure?.(get(state2), ...args);
        });
        return Promise.reject(error);
      }
    );
    set(state2, {
      status: "processing",
      delayed: action.isDelayed,
      args,
      promise,
      abortController
    });
    clearTimeouts();
    delayedCallbackId = setTimeout(
      () => {
        if (strict_equals(get(state2).status, "processing", false) || strict_equals(get(state2).promise, promise, false)) return;
        set(state2, { ...get(state2), delayed: true });
      },
      get(delayedMs)
    );
    timeoutCallbackId = setTimeout(
      () => {
        if (strict_equals(get(state2).status, "processing", false) || strict_equals(get(state2).promise, promise, false)) return;
        abort(get(state2));
        set(state2, { status: "failed", reason: "timeout" });
        options.onFailure?.(get(state2), ...args);
      },
      get(timeoutMs)
    );
    return promise;
  }
  function decideAndRun(args) {
    return untrack(() => run(get(combinator)(get(state2)), args));
  }
  const action = {
    get state() {
      return get(state2);
    },
    get status() {
      return get(state2).status;
    },
    get isSuccess() {
      return strict_equals(get(state2).status, "success");
    },
    get isFailed() {
      return strict_equals(get(state2).status, "failed");
    },
    get isProcessed() {
      return strict_equals(get(state2).status, "processing");
    },
    get isDelayed() {
      return strict_equals(get(state2).status, "processing") && get(state2).delayed;
    },
    matches(status) {
      return strict_equals(get(state2).status, status);
    },
    run(...args) {
      void decideAndRun(args).catch(noop);
    },
    runAsync(...args) {
      return decideAndRun(args);
    },
    abort() {
      untrack(() => {
        if (strict_equals(get(state2).status, "processing", false)) return;
        const { args } = get(state2);
        abort(get(state2));
        clearTimeouts();
        set(state2, { status: "failed", reason: "aborted" });
        options.onFailure?.(get(state2), ...args);
      });
    }
  };
  return action;
}

// node_modules/@sjsf/form/dist/form/create-form.svelte.js
var DEFAULT_FIELDS_VALIDATION_DEBOUNCE_MS = 300;
var UI_OPTIONS_REGISTRY_KEY = "uiOptionsRegistry";
function createForm(options) {
  const merger = tag(user_derived(() => options.merger ?? createFormMerger(options.validator, options.schema)), "merger");
  let value = tag(state(proxy(
    // svelte-ignore state_referenced_locally
    get(merger).mergeFormDataAndSchemaDefaults(options.initialValue, options.schema)
  )), "value");
  let errors = tag(state(Array.isArray(options.initialErrors) ? groupErrors(options.initialErrors) : new SvelteMap(options.initialErrors)), "errors");
  let isSubmitted = tag(state(false), "isSubmitted");
  let isChanged = tag(state(false), "isChanged");
  const fieldsValidationMode = tag(user_derived(() => options.fieldsValidationMode ?? 0), "fieldsValidationMode");
  const uiSchemaRoot = tag(user_derived(() => options.uiSchema ?? {}), "uiSchemaRoot");
  const uiSchema = tag(user_derived(() => resolveUiRef(get(uiSchemaRoot), options.uiSchema) ?? {}), "uiSchema");
  const disabled = tag(user_derived(() => options.disabled ?? false), "disabled");
  const schedulerYield = tag(user_derived(() => options.schedulerYield ?? (strict_equals(typeof scheduler, "undefined", false) && "yield" in scheduler) ? scheduler.yield.bind(scheduler) : ({ signal }) => new Promise((resolve, reject) => {
    setTimeout(
      () => {
        if (signal.aborted) {
          reject(signal.reason);
        } else {
          resolve();
        }
      },
      0
    );
  })), "schedulerYield");
  const dataUrlToBlob = tag(user_derived(() => createDataURLtoBlob(get(schedulerYield))), "dataUrlToBlob");
  const getSnapshot = tag(user_derived(() => options.getSnapshot ?? (() => snapshot(get(value)))), "getSnapshot");
  const translate = tag(user_derived(() => createTranslate(options.translation)), "translate");
  const validateForm = tag(
    user_derived(() => {
      const v = options.validator;
      if (isAsyncFormValueValidator(v)) {
        return (signal, schema, formValue) => v.validateFormValueAsync(signal, schema, formValue);
      }
      if (isFormValueValidator(v)) {
        return (_, schema, formValue) => Promise.resolve(v.validateFormValue(schema, formValue));
      }
      return async () => Promise.resolve([]);
    }),
    "validateForm"
  );
  const submission = createAction({
    async execute(signal, _event) {
      set(isSubmitted, true);
      const formValue = get(getSnapshot)(context);
      return {
        formValue,
        formErrors: groupErrors(await get(validateForm)(signal, options.schema, formValue))
      };
    },
    onSuccess({ formValue, formErrors }, event) {
      set(errors, formErrors);
      if (strict_equals(get(errors).size, 0)) {
        options.onSubmit?.(formValue, event);
        set(isChanged, false);
        return;
      }
      options.onSubmitError?.(formErrors, event, formValue);
    },
    onFailure(error, e) {
      get(errors).set(context.rootId, [
        {
          propertyTitle: "",
          message: get(translate)("validation-process-error", { error }),
          error: new ValidationProcessError(error)
        }
      ]);
      options.onSubmissionFailure?.(error, e);
    },
    get combinator() {
      return options.submissionCombinator;
    },
    get delayedMs() {
      return options.submissionDelayedMs;
    },
    get timeoutMs() {
      return options.submissionTimeoutMs;
    }
  });
  const validateFields = tag(
    user_derived(() => {
      const v = options.validator;
      if (isAsyncFieldValueValidator(v)) {
        return (signal, config, value2) => v.validateFieldValueAsync(signal, config, value2);
      }
      if (isFieldValueValidator(v)) {
        return (_, config, value2) => Promise.resolve(v.validateFieldValue(config, value2));
      }
      return () => Promise.resolve([]);
    }),
    "validateFields"
  );
  const fieldsValidation = createAction({
    execute(signal, config, value2) {
      const debounceMs = options.fieldsValidationDebounceMs ?? 300;
      if (debounceMs < 0) {
        return get(validateFields)(signal, config, value2);
      }
      const promise = Promise.withResolvers();
      const id = setTimeout(
        () => {
          promise.resolve(get(validateFields)(signal, config, value2));
        },
        debounceMs
      );
      const onAbort = () => {
        clearTimeout(id);
        promise.reject(new DOMException("field validation has been aborted", "AbortError"));
      };
      signal.addEventListener("abort", onAbort);
      return promise.promise.finally(() => {
        signal.removeEventListener("abort", onAbort);
      });
    },
    onSuccess(fieldErrors, config) {
      if (fieldErrors.length > 0) {
        get(errors).set(config.id, fieldErrors);
      } else {
        get(errors).delete(config.id);
      }
    },
    onFailure(error, config, value2) {
      if (strict_equals(error.reason, "aborted", false)) {
        get(errors).set(config.id, [
          {
            propertyTitle: config.title,
            message: get(translate)("validation-process-error", { error }),
            error: new ValidationProcessError(error)
          }
        ]);
      }
      options.onFieldsValidationFailure?.(error, config, value2);
    },
    get combinator() {
      return options.fieldsValidationCombinator ?? abortPrevious;
    },
    get delayedMs() {
      return options.fieldsValidationDelayedMs;
    },
    get timeoutMs() {
      return options.fieldsValidationTimeoutMs;
    }
  });
  function submitHandler(e) {
    e.preventDefault();
    submission.run(e);
  }
  function resetHandler(e) {
    e.preventDefault();
    set(isSubmitted, false);
    set(isChanged, false);
    get(errors).clear();
    set(value, get(merger).mergeFormDataAndSchemaDefaults(options.initialValue, options.schema), true);
    options.onReset?.(e);
  }
  const rootId = tag(user_derived(() => options.idPrefix ?? DEFAULT_ID_PREFIX), "rootId");
  const uiOptionsRegistry = tag(user_derived(() => options[UI_OPTIONS_REGISTRY_KEY] ?? {}), "uiOptionsRegistry");
  const uiOptions = tag(
    user_derived(() => ({
      ...get(uiSchemaRoot)["ui:globalOptions"],
      ...get(uiSchema)["ui:options"]
    })),
    "uiOptions"
  );
  const context = {
    ...{},
    get rootId() {
      return get(rootId);
    },
    get value() {
      return get(value);
    },
    set value(v) {
      set(value, v, true);
    },
    get fieldsValidationMode() {
      return get(fieldsValidationMode);
    },
    submission,
    fieldsValidation,
    get dataUrlToBlob() {
      return get(dataUrlToBlob);
    },
    get isSubmitted() {
      return get(isSubmitted);
    },
    set isSubmitted(v) {
      set(isSubmitted, v);
    },
    get isChanged() {
      return get(isChanged);
    },
    set isChanged(v) {
      set(isChanged, v);
    },
    get errors() {
      return get(errors);
    },
    get schema() {
      return options.schema;
    },
    get uiSchemaRoot() {
      return get(uiSchemaRoot);
    },
    get uiSchema() {
      return get(uiSchema);
    },
    get uiOptions() {
      return get(uiOptions);
    },
    get extraUiOptions() {
      return options.extraUiOptions;
    },
    get uiOptionsRegistry() {
      return get(uiOptionsRegistry);
    },
    get disabled() {
      return get(disabled);
    },
    get idPrefix() {
      return options.idPrefix ?? DEFAULT_ID_PREFIX;
    },
    get idSeparator() {
      return options.idSeparator ?? DEFAULT_ID_SEPARATOR;
    },
    get idPseudoSeparator() {
      return options.idPseudoSeparator ?? DEFAULT_ID_PSEUDO_SEPARATOR;
    },
    get validator() {
      return options.validator;
    },
    get merger() {
      return get(merger);
    },
    get fieldTypeResolver() {
      return get(fieldTypeResolver);
    },
    get theme() {
      return options.theme;
    },
    get translation() {
      return options.translation;
    },
    get translate() {
      return get(translate);
    },
    get icons() {
      return options.icons;
    },
    submitHandler,
    resetHandler
  };
  const fieldTypeResolver = tag(user_derived(() => options.resolver(context)), "fieldTypeResolver");
  return {
    context,
    get value() {
      return get(getSnapshot)(context);
    },
    set value(v) {
      set(value, get(merger).mergeFormDataAndSchemaDefaults(v, options.schema), true);
    },
    get errors() {
      return get(errors);
    },
    set errors(v) {
      set(errors, v);
    },
    get isSubmitted() {
      return get(isSubmitted);
    },
    set isSubmitted(v) {
      set(isSubmitted, v);
    },
    get isChanged() {
      return get(isChanged);
    },
    set isChanged(v) {
      set(isChanged, v);
    },
    submission,
    fieldsValidation,
    submit: submitHandler,
    reset: resetHandler
  };
}
function enhance(node, context) {
  user_effect(() => {
    const ctx = context;
    const disposeSubmit = on(node, "submit", ctx.submitHandler);
    const disposeReset = on(node, "reset", ctx.resetHandler);
    return () => {
      disposeReset();
      disposeSubmit();
    };
  });
}

// node_modules/@sjsf/form/dist/form/content.svelte
Content[FILENAME] = "node_modules/@sjsf/form/dist/form/content.svelte";
function Content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Content);
  const ctx = getFormContext();
  const retrievedSchema = tag(user_derived(() => retrieveSchema2(ctx, ctx.schema, ctx.value)), "retrievedSchema");
  const config = tag(
    user_derived(() => ({
      id: ctx.rootId,
      title: uiTitleOption(ctx, ctx.uiSchema) ?? get(retrievedSchema).title ?? "",
      schema: get(retrievedSchema),
      uiSchema: ctx.uiSchema,
      required: false
    })),
    "config"
  );
  const Field = tag(user_derived(() => getFieldComponent(ctx, get(config))), "Field");
  var fragment = comment();
  var node = first_child(fragment);
  validate_binding("bind:value={ctx.value as undefined}", () => ctx, () => "value", 28, 2);
  const expression = user_derived(() => retrieveTranslate(ctx, get(config)));
  component(node, () => get(Field), ($$anchor2, Field_12) => {
    Field_12($$anchor2, {
      type: "field",
      get config() {
        return get(config);
      },
      uiOption: (opt) => retrieveUiOption(ctx, get(config), opt),
      get translate() {
        return get(expression);
      },
      get value() {
        return ctx.value;
      },
      set value($$value) {
        ctx.value = $$value;
      }
    });
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Content = hmr(Content, () => Content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Content[HMR].source;
    set(Content[HMR].source, module.default[HMR].original);
  });
}
var content_default = Content;

// node_modules/@sjsf/form/dist/form/text.svelte
Text[FILENAME] = "node_modules/@sjsf/form/dist/form/text.svelte";
function Text($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Text);
  const ctx = getFormContext();
  const args = prop($$props, "args", 19, () => ({}));
  const translation = tag(user_derived(() => $$props.translate($$props.id, args())), "translation");
  const iconConfig = tag(
    user_derived(() => ({
      config: $$props.config,
      params: args(),
      translation: get(translation)
    })),
    "iconConfig"
  );
  const icon = tag(user_derived(() => ctx.icons?.($$props.id, get(
    //@ts-expect-error
    iconConfig
  ))), "icon");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => get(icon), () => get(iconConfig));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var text2 = text();
      template_effect(() => set_text(text2, get(translation)));
      append($$anchor2, text2);
    };
    if_block(node, ($$render) => {
      if (get(icon)) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Text = hmr(Text, () => Text[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Text[HMR].source;
    set(Text[HMR].source, module.default[HMR].original);
  });
}
var text_default = Text;

// node_modules/@sjsf/form/dist/form/submit-button.svelte
Submit_button[FILENAME] = "node_modules/@sjsf/form/dist/form/submit-button.svelte";
function Submit_button($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Submit_button);
  const ctx = getFormContext();
  const config = tag(
    user_derived(() => ({
      id: ctx.rootId,
      name: "submit-button",
      title: "",
      schema: ctx.schema,
      uiSchema: ctx.uiSchema,
      required: false
    })),
    "config"
  );
  const Button = tag(user_derived(() => getComponent(ctx, "submitButton", get(config))), "Button");
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => get(Button), ($$anchor2, Button_1) => {
    Button_1($$anchor2, {
      get config() {
        return get(config);
      },
      children: wrap_snippet(Submit_button, ($$anchor3, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        const expression = user_derived(() => retrieveTranslate(ctx, get(config)));
        text_default(node_1, {
          get config() {
            return get(config);
          },
          id: "submit",
          get translate() {
            return get(expression);
          }
        });
        append($$anchor3, fragment_1);
      }),
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Submit_button = hmr(Submit_button, () => Submit_button[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Submit_button[HMR].source;
    set(Submit_button[HMR].source, module.default[HMR].original);
  });
}
var submit_button_default = Submit_button;

// node_modules/@sjsf/form/dist/form/form.svelte
Form_1[FILENAME] = "node_modules/@sjsf/form/dist/form/form.svelte";
function Form_1($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Form_1);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15);
  const ctx = getFormContext();
  const config = tag(
    user_derived(() => ({
      id: ctx.rootId,
      name: "form",
      title: "",
      schema: ctx.schema,
      uiSchema: ctx.uiSchema,
      required: false
    })),
    "config"
  );
  const Form = tag(user_derived(() => getComponent(ctx, "form", get(config))), "Form");
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => get(Form), ($$anchor2, Form_2) => {
    $$ownership_validator.binding("ref", Form_2, ref);
    Form_2($$anchor2, {
      get config() {
        return get(config);
      },
      get children() {
        return $$props.children;
      },
      get attributes() {
        return $$props.attributes;
      },
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      }
    });
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Form_1 = hmr(Form_1, () => Form_1[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Form_1[HMR].source;
    set(Form_1[HMR].source, module.default[HMR].original);
  });
}
var form_default = Form_1;

// node_modules/@sjsf/form/dist/form/basic-form.svelte
Basic_form[FILENAME] = "node_modules/@sjsf/form/dist/form/basic-form.svelte";
var root_1 = add_locations(from_html(`<!> <!>`, 1), Basic_form[FILENAME], []);
function Basic_form($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Basic_form);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15), attributes = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "form"
    ],
    "attributes"
  );
  setFormContext($$props.form.context);
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("ref", form_default, ref);
    form_default(node, {
      get attributes() {
        return attributes;
      },
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      },
      children: wrap_snippet(Basic_form, ($$anchor2, $$slotProps) => {
        var fragment_1 = root_1();
        var node_1 = first_child(fragment_1);
        content_default(node_1, {});
        var node_2 = sibling(node_1, 2);
        submit_button_default(node_2, {});
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Basic_form = hmr(Basic_form, () => Basic_form[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Basic_form[HMR].source;
    set(Basic_form[HMR].source, module.default[HMR].original);
  });
}
var basic_form_default = Basic_form;

// node_modules/@sjsf/form/dist/form/simple-form.svelte
Simple_form[FILENAME] = "node_modules/@sjsf/form/dist/form/simple-form.svelte";
function Simple_form($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Simple_form);
  const options = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "options");
  const form = createForm(options);
  var fragment = comment();
  var node = first_child(fragment);
  basic_form_default(node, {
    get form() {
      return form;
    }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Simple_form = hmr(Simple_form, () => Simple_form[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Simple_form[HMR].source;
    set(Simple_form[HMR].source, module.default[HMR].original);
  });
}
var simple_form_default = Simple_form;

// node_modules/@sjsf/form/dist/form/datalist.svelte
Datalist[FILENAME] = "node_modules/@sjsf/form/dist/form/datalist.svelte";
var root_2 = add_locations(from_html(`<option></option>`), Datalist[FILENAME], [[26, 6]]);
var root_12 = add_locations(from_html(`<datalist></datalist>`), Datalist[FILENAME], [[24, 2]]);
function Datalist($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Datalist);
  const examples = tag(
    user_derived(() => {
      const { default: defaultValue, examples: examples2 } = $$props.config.schema;
      if (!Array.isArray(examples2) || !$$props.id) {
        return;
      }
      return strict_equals(defaultValue, void 0, false) && !examples2.includes(defaultValue) ? [defaultValue].concat(examples2) : examples2;
    }),
    "examples"
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var datalist = root_12();
      validate_each_keys(() => get(examples), (example) => example);
      each(datalist, 20, () => get(examples), (example) => example, ($$anchor3, example) => {
        var option = root_2();
        var option_value = {};
        template_effect(() => {
          if (option_value !== (option_value = example)) {
            option.value = (option.__value = example) ?? "";
          }
        });
        append($$anchor3, option);
      });
      reset(datalist);
      template_effect(() => set_attribute(datalist, "id", $$props.id));
      append($$anchor2, datalist);
    };
    if_block(node, ($$render) => {
      if (get(examples)) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Datalist = hmr(Datalist, () => Datalist[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Datalist[HMR].source;
    set(Datalist[HMR].source, module.default[HMR].original);
  });
}
var datalist_default = Datalist;

// node_modules/@sjsf/form/dist/form/field.svelte
Field_1[FILENAME] = "node_modules/@sjsf/form/dist/form/field.svelte";
function Field_1($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Field_1);
  const ctx = $$props.form.context;
  if (true_default) {
    user_effect(() => {
      if (strict_equals($$props.name, "")) {
        console.warn('Use `<Content />` instead of `<Field name="" />`');
      }
    });
  }
  const valuePath = tag(user_derived(() => strict_equals($$props.name, "") ? [] : $$props.name.split(".")), "valuePath");
  const id = tag(user_derived(() => pathToId(get(valuePath), ctx)), "id");
  const valueRef = tag(
    user_derived(() => {
      if (strict_equals(get(valuePath).length, 0)) {
        return ctx;
      }
      let node = ctx.value;
      let i = -1;
      const lastIndex = get(valuePath).length - 1;
      while (isObject(node) && ++i < lastIndex) {
        node = node[get(valuePath)[i]];
      }
      if (strict_equals(i, lastIndex, false)) {
        console.error(...log_if_contains_state("error", "Current form state", snapshot(ctx.value)));
        throw new Error(`Path "${$$props.name}" is not populated or invalid, check current form state`);
      }
      const lastKey = get(valuePath)[lastIndex];
      return {
        get value() {
          return node[lastKey];
        },
        set value(v) {
          node[lastKey] = v;
        }
      };
    }),
    "valueRef"
  );
  const parentSchema = tag(
    user_derived(() => {
      const len = get(valuePath).length;
      if (len < 2) {
        return ctx.schema;
      }
      const def = getSchemaDefinitionByPath(ctx.schema, ctx.schema, get(valuePath).slice(0, -1));
      return strict_equals(def, void 0) || strict_equals(typeof def, "boolean") ? {} : def;
    }),
    "parentSchema"
  );
  const schema = tag(
    user_derived(() => {
      if (strict_equals(get(valuePath).length, 0)) {
        return ctx.schema;
      }
      const def = getSchemaDefinitionByPath(ctx.schema, get(parentSchema), get(valuePath).slice(-1));
      return strict_equals(def, void 0) || strict_equals(typeof def, "boolean") ? {} : def;
    }),
    "schema"
  );
  const retrievedSchema = tag(user_derived(() => retrieveSchema2(ctx, get(schema), get(valueRef).value)), "retrievedSchema");
  const uiSchema = tag(user_derived(() => $$props.uiSchema ?? getUiSchemaByPath(ctx.uiSchemaRoot, ctx.uiSchema, get(valuePath)) ?? {}), "uiSchema");
  const required = tag(
    user_derived(() => {
      if (strict_equals($$props.required, void 0, false)) {
        return $$props.required;
      }
      if (strict_equals(get(valuePath).length, 0)) {
        return false;
      }
      const property = get(valuePath)[get(valuePath).length - 1];
      const { required: required2, items, minItems } = get(parentSchema);
      if (Array.isArray(required2)) {
        return required2.includes(property);
      }
      const num = Number(property);
      if (Number.isInteger(num) && num >= 0) {
        if (strict_equals(minItems, void 0, false)) {
          return num < minItems;
        }
        if (Array.isArray(items)) {
          return num < items.length;
        }
      }
      return false;
    }),
    "required"
  );
  const config = tag(
    user_derived(() => ({
      id: get(id),
      title: uiTitleOption(ctx, get(uiSchema)) ?? get(retrievedSchema).title ?? "",
      schema: get(retrievedSchema),
      uiSchema: get(uiSchema),
      required: get(required)
    })),
    "config"
  );
  const translate = tag(user_derived(() => retrieveTranslate(ctx, get(config))), "translate");
  const uiOption = (opt) => retrieveUiOption(ctx, get(config), opt);
  const renderField = tag(user_derived(() => $$props.render ?? $$props.children), "renderField");
  setFormContext(ctx);
  var fragment = comment();
  var node_1 = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      snippet(node_2, () => get(renderField), () => ({
        type: "field",
        config: get(config),
        translate: get(translate),
        uiOption,
        valueRef: get(valueRef)
      }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_2 = comment();
      const Field = user_derived(() => getFieldComponent(ctx, get(config)));
      get(Field);
      var node_3 = first_child(fragment_2);
      validate_binding("bind:value={valueRef.value as undefined}", () => get(valueRef), () => "value", 191, 4);
      component(node_3, () => get(Field), ($$anchor3, Field_2) => {
        Field_2($$anchor3, {
          type: "field",
          get config() {
            return get(config);
          },
          uiOption,
          get translate() {
            return get(translate);
          },
          get value() {
            return get(valueRef).value;
          },
          set value($$value) {
            get(valueRef).value = $$value;
          }
        });
      });
      append($$anchor2, fragment_2);
    };
    if_block(node_1, ($$render) => {
      if (get(renderField)) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Field_1 = hmr(Field_1, () => Field_1[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Field_1[HMR].source;
    set(Field_1[HMR].source, module.default[HMR].original);
  });
}
var field_default = Field_1;

export {
  DEFAULT_BOOLEAN_ENUM,
  getRootSchemaTitleByPath,
  isUiSchemaRef,
  resolveUiRef,
  resolveUiOption,
  getUiSchemaByPath,
  getRootUiSchemaTitleByPath,
  AdditionalPropertyKeyError,
  ValidationProcessError,
  groupErrors,
  ON_INPUT,
  ON_CHANGE,
  ON_BLUR,
  ON_ARRAY_CHANGE,
  ON_OBJECT_CHANGE,
  AFTER_CHANGED,
  AFTER_TOUCHED,
  AFTER_SUBMITTED,
  isFormValueValidator,
  isAsyncFormValueValidator,
  isFieldValueValidator,
  isAsyncFieldValueValidator,
  isAdditionalPropertyKeyValidator,
  createFormMerger,
  DEFAULT_ID_PREFIX,
  DEFAULT_ID_SEPARATOR,
  DEFAULT_ID_PSEUDO_SEPARATOR,
  pathToId,
  createPseudoId,
  createChildId,
  createTranslate,
  FORM_CONTEXT,
  getFormContext,
  setFormContext,
  isSelect2 as isSelect,
  isMultiSelect2 as isMultiSelect,
  isFilesArray2 as isFilesArray,
  retrieveSchema2 as retrieveSchema,
  sanitizeDataForNewSchema2 as sanitizeDataForNewSchema,
  getClosestMatchingOption2 as getClosestMatchingOption,
  getDefaultFieldState,
  retrieveUiSchema,
  uiTitleOption,
  retrieveUiOption,
  uiOptionProps,
  uiOptionNestedProps,
  retrieveTranslate,
  getErrors,
  validateField,
  validateAdditionalPropertyKey,
  makeEventHandlers,
  composeProps,
  assignProps,
  isDisabled,
  disabledProp,
  inputType,
  describedBy,
  inputProps,
  textareaProps,
  selectProps,
  forProp,
  idProp,
  tabindexProp,
  dataLayoutProp,
  buttonTypeProp,
  descriptionAttributes,
  errorsListAttributes,
  formAttributes,
  helpAttributes,
  labelAttributes,
  titleAttributes,
  layoutAttributes,
  buttonAttributes,
  customInputAttributes,
  inputAttributes,
  selectAttributes,
  textareaAttributes,
  addFile,
  addFiles,
  createMessage,
  error_message_default,
  getComponent,
  getFieldComponent,
  fileToDataURL,
  identity,
  abortPrevious,
  createAction,
  DEFAULT_FIELDS_VALIDATION_DEBOUNCE_MS,
  createForm,
  enhance,
  content_default,
  text_default,
  submit_button_default,
  form_default,
  basic_form_default,
  simple_form_default,
  datalist_default,
  field_default
};
//# sourceMappingURL=chunk-TH67H3ZF.js.map
