import {
  __commonJS,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/jsonpointer/jsonpointer.js
var require_jsonpointer = __commonJS({
  "node_modules/jsonpointer/jsonpointer.js"(exports) {
    var hasExcape = /~/;
    var escapeMatcher = /~[01]/g;
    function escapeReplacer(m) {
      switch (m) {
        case "~1":
          return "/";
        case "~0":
          return "~";
      }
      throw new Error("Invalid tilde escape: " + m);
    }
    function untilde(str) {
      if (!hasExcape.test(str)) return str;
      return str.replace(escapeMatcher, escapeReplacer);
    }
    function setter(obj, pointer, value) {
      var part;
      var hasNextPart;
      for (var p = 1, len = pointer.length; p < len; ) {
        if (pointer[p] === "constructor" || pointer[p] === "prototype" || pointer[p] === "__proto__") return obj;
        part = untilde(pointer[p++]);
        hasNextPart = len > p;
        if (typeof obj[part] === "undefined") {
          if (Array.isArray(obj) && part === "-") {
            part = obj.length;
          }
          if (hasNextPart) {
            if (pointer[p] !== "" && pointer[p] < Infinity || pointer[p] === "-") obj[part] = [];
            else obj[part] = {};
          }
        }
        if (!hasNextPart) break;
        obj = obj[part];
      }
      var oldValue = obj[part];
      if (value === void 0) delete obj[part];
      else obj[part] = value;
      return oldValue;
    }
    function compilePointer(pointer) {
      if (typeof pointer === "string") {
        pointer = pointer.split("/");
        if (pointer[0] === "") return pointer;
        throw new Error("Invalid JSON pointer.");
      } else if (Array.isArray(pointer)) {
        for (const part of pointer) {
          if (typeof part !== "string" && typeof part !== "number") {
            throw new Error("Invalid JSON pointer. Must be of type string or number.");
          }
        }
        return pointer;
      }
      throw new Error("Invalid JSON pointer.");
    }
    function get(obj, pointer) {
      if (typeof obj !== "object") throw new Error("Invalid input object.");
      pointer = compilePointer(pointer);
      var len = pointer.length;
      if (len === 1) return obj;
      for (var p = 1; p < len; ) {
        obj = obj[untilde(pointer[p++])];
        if (len === p) return obj;
        if (typeof obj !== "object" || obj === null) return void 0;
      }
    }
    function set(obj, pointer, value) {
      if (typeof obj !== "object") throw new Error("Invalid input object.");
      pointer = compilePointer(pointer);
      if (pointer.length === 0) throw new Error("Invalid JSON pointer for set.");
      return setter(obj, pointer, value);
    }
    function compile(pointer) {
      var compiled = compilePointer(pointer);
      return {
        get: function(object) {
          return get(object, compiled);
        },
        set: function(object, value) {
          return set(object, compiled, value);
        }
      };
    }
    exports.get = get;
    exports.set = set;
    exports.compile = compile;
  }
});

// node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "node_modules/lodash/_listCacheClear.js"(exports, module) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module.exports = listCacheClear;
  }
});

// node_modules/lodash/eq.js
var require_eq = __commonJS({
  "node_modules/lodash/eq.js"(exports, module) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module.exports = eq;
  }
});

// node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "node_modules/lodash/_assocIndexOf.js"(exports, module) {
    var eq = require_eq();
    function assocIndexOf(array2, key) {
      var length = array2.length;
      while (length--) {
        if (eq(array2[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    module.exports = assocIndexOf;
  }
});

// node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "node_modules/lodash/_listCacheDelete.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    module.exports = listCacheDelete;
  }
});

// node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "node_modules/lodash/_listCacheGet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    module.exports = listCacheGet;
  }
});

// node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "node_modules/lodash/_listCacheHas.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module.exports = listCacheHas;
  }
});

// node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "node_modules/lodash/_listCacheSet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    module.exports = listCacheSet;
  }
});

// node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "node_modules/lodash/_ListCache.js"(exports, module) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module.exports = ListCache;
  }
});

// node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "node_modules/lodash/_stackClear.js"(exports, module) {
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module.exports = stackClear;
  }
});

// node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "node_modules/lodash/_stackDelete.js"(exports, module) {
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    module.exports = stackDelete;
  }
});

// node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "node_modules/lodash/_stackGet.js"(exports, module) {
    function stackGet(key) {
      return this.__data__.get(key);
    }
    module.exports = stackGet;
  }
});

// node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "node_modules/lodash/_stackHas.js"(exports, module) {
    function stackHas(key) {
      return this.__data__.has(key);
    }
    module.exports = stackHas;
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports, module) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports, module) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports, module) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module.exports = baseGetTag;
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports, module) {
    function isObject2(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module.exports = isObject2;
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObject2 = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject2(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module.exports = isFunction;
  }
});

// node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "node_modules/lodash/_coreJsData.js"(exports, module) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module.exports = coreJsData;
  }
});

// node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "node_modules/lodash/_isMasked.js"(exports, module) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module.exports = isMasked;
  }
});

// node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "node_modules/lodash/_toSource.js"(exports, module) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    module.exports = toSource;
  }
});

// node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "node_modules/lodash/_baseIsNative.js"(exports, module) {
    var isFunction = require_isFunction();
    var isMasked = require_isMasked();
    var isObject2 = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module.exports = baseIsNative;
  }
});

// node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "node_modules/lodash/_getValue.js"(exports, module) {
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module.exports = getValue;
  }
});

// node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "node_modules/lodash/_getNative.js"(exports, module) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module.exports = getNative;
  }
});

// node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "node_modules/lodash/_Map.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module.exports = Map2;
  }
});

// node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "node_modules/lodash/_nativeCreate.js"(exports, module) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module.exports = nativeCreate;
  }
});

// node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "node_modules/lodash/_hashClear.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module.exports = hashClear;
  }
});

// node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "node_modules/lodash/_hashDelete.js"(exports, module) {
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = hashDelete;
  }
});

// node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "node_modules/lodash/_hashGet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    module.exports = hashGet;
  }
});

// node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "node_modules/lodash/_hashHas.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    module.exports = hashHas;
  }
});

// node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "node_modules/lodash/_hashSet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module.exports = hashSet;
  }
});

// node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "node_modules/lodash/_Hash.js"(exports, module) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module.exports = Hash;
  }
});

// node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "node_modules/lodash/_mapCacheClear.js"(exports, module) {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    module.exports = mapCacheClear;
  }
});

// node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "node_modules/lodash/_isKeyable.js"(exports, module) {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module.exports = isKeyable;
  }
});

// node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "node_modules/lodash/_getMapData.js"(exports, module) {
    var isKeyable = require_isKeyable();
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module.exports = getMapData;
  }
});

// node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "node_modules/lodash/_mapCacheDelete.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = mapCacheDelete;
  }
});

// node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "node_modules/lodash/_mapCacheGet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module.exports = mapCacheGet;
  }
});

// node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "node_modules/lodash/_mapCacheHas.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module.exports = mapCacheHas;
  }
});

// node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "node_modules/lodash/_mapCacheSet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module.exports = mapCacheSet;
  }
});

// node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "node_modules/lodash/_MapCache.js"(exports, module) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module.exports = MapCache;
  }
});

// node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "node_modules/lodash/_stackSet.js"(exports, module) {
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    module.exports = stackSet;
  }
});

// node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "node_modules/lodash/_Stack.js"(exports, module) {
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module.exports = Stack;
  }
});

// node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
  "node_modules/lodash/_arrayEach.js"(exports, module) {
    function arrayEach(array2, iteratee) {
      var index = -1, length = array2 == null ? 0 : array2.length;
      while (++index < length) {
        if (iteratee(array2[index], index, array2) === false) {
          break;
        }
      }
      return array2;
    }
    module.exports = arrayEach;
  }
});

// node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/lodash/_defineProperty.js"(exports, module) {
    var getNative = require_getNative();
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    module.exports = defineProperty;
  }
});

// node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "node_modules/lodash/_baseAssignValue.js"(exports, module) {
    var defineProperty = require_defineProperty();
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    module.exports = baseAssignValue;
  }
});

// node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
  "node_modules/lodash/_assignValue.js"(exports, module) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module.exports = assignValue;
  }
});

// node_modules/lodash/_copyObject.js
var require_copyObject = __commonJS({
  "node_modules/lodash/_copyObject.js"(exports, module) {
    var assignValue = require_assignValue();
    var baseAssignValue = require_baseAssignValue();
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    module.exports = copyObject;
  }
});

// node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "node_modules/lodash/_baseTimes.js"(exports, module) {
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module.exports = baseTimes;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports, module) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module.exports = isObjectLike;
  }
});

// node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "node_modules/lodash/_baseIsArguments.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module.exports = baseIsArguments;
  }
});

// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/lodash/isArguments.js"(exports, module) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module.exports = isArguments;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports, module) {
    var isArray = Array.isArray;
    module.exports = isArray;
  }
});

// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "node_modules/lodash/stubFalse.js"(exports, module) {
    function stubFalse() {
      return false;
    }
    module.exports = stubFalse;
  }
});

// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "node_modules/lodash/isBuffer.js"(exports, module) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module.exports = isBuffer;
  }
});

// node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "node_modules/lodash/_isIndex.js"(exports, module) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module.exports = isIndex;
  }
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/lodash/isLength.js"(exports, module) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module.exports = isLength;
  }
});

// node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module.exports = baseIsTypedArray;
  }
});

// node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/lodash/_baseUnary.js"(exports, module) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module.exports = baseUnary;
  }
});

// node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/lodash/_nodeUtil.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module.exports = nodeUtil;
  }
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/lodash/isTypedArray.js"(exports, module) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module.exports = isTypedArray;
  }
});

// node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = arrayLikeKeys;
  }
});

// node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "node_modules/lodash/_isPrototype.js"(exports, module) {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module.exports = isPrototype;
  }
});

// node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/lodash/_overArg.js"(exports, module) {
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module.exports = overArg;
  }
});

// node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "node_modules/lodash/_nativeKeys.js"(exports, module) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module.exports = nativeKeys;
  }
});

// node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "node_modules/lodash/_baseKeys.js"(exports, module) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = baseKeys;
  }
});

// node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/lodash/isArrayLike.js"(exports, module) {
    var isFunction = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    module.exports = isArrayLike;
  }
});

// node_modules/lodash/keys.js
var require_keys = __commonJS({
  "node_modules/lodash/keys.js"(exports, module) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module.exports = keys;
  }
});

// node_modules/lodash/_baseAssign.js
var require_baseAssign = __commonJS({
  "node_modules/lodash/_baseAssign.js"(exports, module) {
    var copyObject = require_copyObject();
    var keys = require_keys();
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    module.exports = baseAssign;
  }
});

// node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
  "node_modules/lodash/_nativeKeysIn.js"(exports, module) {
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = nativeKeysIn;
  }
});

// node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
  "node_modules/lodash/_baseKeysIn.js"(exports, module) {
    var isObject2 = require_isObject();
    var isPrototype = require_isPrototype();
    var nativeKeysIn = require_nativeKeysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject2(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = baseKeysIn;
  }
});

// node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
  "node_modules/lodash/keysIn.js"(exports, module) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeysIn = require_baseKeysIn();
    var isArrayLike = require_isArrayLike();
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module.exports = keysIn;
  }
});

// node_modules/lodash/_baseAssignIn.js
var require_baseAssignIn = __commonJS({
  "node_modules/lodash/_baseAssignIn.js"(exports, module) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }
    module.exports = baseAssignIn;
  }
});

// node_modules/lodash/_cloneBuffer.js
var require_cloneBuffer = __commonJS({
  "node_modules/lodash/_cloneBuffer.js"(exports, module) {
    var root = require_root();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer = moduleExports ? root.Buffer : void 0;
    var allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    module.exports = cloneBuffer;
  }
});

// node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
  "node_modules/lodash/_copyArray.js"(exports, module) {
    function copyArray(source, array2) {
      var index = -1, length = source.length;
      array2 || (array2 = Array(length));
      while (++index < length) {
        array2[index] = source[index];
      }
      return array2;
    }
    module.exports = copyArray;
  }
});

// node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "node_modules/lodash/_arrayFilter.js"(exports, module) {
    function arrayFilter(array2, predicate) {
      var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array2[index];
        if (predicate(value, index, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module.exports = arrayFilter;
  }
});

// node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "node_modules/lodash/stubArray.js"(exports, module) {
    function stubArray() {
      return [];
    }
    module.exports = stubArray;
  }
});

// node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "node_modules/lodash/_getSymbols.js"(exports, module) {
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    module.exports = getSymbols;
  }
});

// node_modules/lodash/_copySymbols.js
var require_copySymbols = __commonJS({
  "node_modules/lodash/_copySymbols.js"(exports, module) {
    var copyObject = require_copyObject();
    var getSymbols = require_getSymbols();
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    module.exports = copySymbols;
  }
});

// node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "node_modules/lodash/_arrayPush.js"(exports, module) {
    function arrayPush(array2, values) {
      var index = -1, length = values.length, offset = array2.length;
      while (++index < length) {
        array2[offset + index] = values[index];
      }
      return array2;
    }
    module.exports = arrayPush;
  }
});

// node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "node_modules/lodash/_getPrototype.js"(exports, module) {
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module.exports = getPrototype;
  }
});

// node_modules/lodash/_getSymbolsIn.js
var require_getSymbolsIn = __commonJS({
  "node_modules/lodash/_getSymbolsIn.js"(exports, module) {
    var arrayPush = require_arrayPush();
    var getPrototype = require_getPrototype();
    var getSymbols = require_getSymbols();
    var stubArray = require_stubArray();
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    module.exports = getSymbolsIn;
  }
});

// node_modules/lodash/_copySymbolsIn.js
var require_copySymbolsIn = __commonJS({
  "node_modules/lodash/_copySymbolsIn.js"(exports, module) {
    var copyObject = require_copyObject();
    var getSymbolsIn = require_getSymbolsIn();
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }
    module.exports = copySymbolsIn;
  }
});

// node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "node_modules/lodash/_baseGetAllKeys.js"(exports, module) {
    var arrayPush = require_arrayPush();
    var isArray = require_isArray();
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    module.exports = baseGetAllKeys;
  }
});

// node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "node_modules/lodash/_getAllKeys.js"(exports, module) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys = require_keys();
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    module.exports = getAllKeys;
  }
});

// node_modules/lodash/_getAllKeysIn.js
var require_getAllKeysIn = __commonJS({
  "node_modules/lodash/_getAllKeysIn.js"(exports, module) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbolsIn = require_getSymbolsIn();
    var keysIn = require_keysIn();
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    module.exports = getAllKeysIn;
  }
});

// node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "node_modules/lodash/_DataView.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var DataView = getNative(root, "DataView");
    module.exports = DataView;
  }
});

// node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "node_modules/lodash/_Promise.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module.exports = Promise2;
  }
});

// node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "node_modules/lodash/_Set.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module.exports = Set2;
  }
});

// node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "node_modules/lodash/_WeakMap.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap2 = getNative(root, "WeakMap");
    module.exports = WeakMap2;
  }
});

// node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "node_modules/lodash/_getTag.js"(exports, module) {
    var DataView = require_DataView();
    var Map2 = require_Map();
    var Promise2 = require_Promise();
    var Set2 = require_Set();
    var WeakMap2 = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module.exports = getTag;
  }
});

// node_modules/lodash/_initCloneArray.js
var require_initCloneArray = __commonJS({
  "node_modules/lodash/_initCloneArray.js"(exports, module) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function initCloneArray(array2) {
      var length = array2.length, result = new array2.constructor(length);
      if (length && typeof array2[0] == "string" && hasOwnProperty.call(array2, "index")) {
        result.index = array2.index;
        result.input = array2.input;
      }
      return result;
    }
    module.exports = initCloneArray;
  }
});

// node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "node_modules/lodash/_Uint8Array.js"(exports, module) {
    var root = require_root();
    var Uint8Array = root.Uint8Array;
    module.exports = Uint8Array;
  }
});

// node_modules/lodash/_cloneArrayBuffer.js
var require_cloneArrayBuffer = __commonJS({
  "node_modules/lodash/_cloneArrayBuffer.js"(exports, module) {
    var Uint8Array = require_Uint8Array();
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }
    module.exports = cloneArrayBuffer;
  }
});

// node_modules/lodash/_cloneDataView.js
var require_cloneDataView = __commonJS({
  "node_modules/lodash/_cloneDataView.js"(exports, module) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    module.exports = cloneDataView;
  }
});

// node_modules/lodash/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
  "node_modules/lodash/_cloneRegExp.js"(exports, module) {
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    module.exports = cloneRegExp;
  }
});

// node_modules/lodash/_cloneSymbol.js
var require_cloneSymbol = __commonJS({
  "node_modules/lodash/_cloneSymbol.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    module.exports = cloneSymbol;
  }
});

// node_modules/lodash/_cloneTypedArray.js
var require_cloneTypedArray = __commonJS({
  "node_modules/lodash/_cloneTypedArray.js"(exports, module) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    module.exports = cloneTypedArray;
  }
});

// node_modules/lodash/_initCloneByTag.js
var require_initCloneByTag = __commonJS({
  "node_modules/lodash/_initCloneByTag.js"(exports, module) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    var cloneDataView = require_cloneDataView();
    var cloneRegExp = require_cloneRegExp();
    var cloneSymbol = require_cloneSymbol();
    var cloneTypedArray = require_cloneTypedArray();
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return new Ctor();
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return new Ctor();
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    module.exports = initCloneByTag;
  }
});

// node_modules/lodash/_baseCreate.js
var require_baseCreate = __commonJS({
  "node_modules/lodash/_baseCreate.js"(exports, module) {
    var isObject2 = require_isObject();
    var objectCreate = Object.create;
    var baseCreate = /* @__PURE__ */ function() {
      function object() {
      }
      return function(proto) {
        if (!isObject2(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    module.exports = baseCreate;
  }
});

// node_modules/lodash/_initCloneObject.js
var require_initCloneObject = __commonJS({
  "node_modules/lodash/_initCloneObject.js"(exports, module) {
    var baseCreate = require_baseCreate();
    var getPrototype = require_getPrototype();
    var isPrototype = require_isPrototype();
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    module.exports = initCloneObject;
  }
});

// node_modules/lodash/_baseIsMap.js
var require_baseIsMap = __commonJS({
  "node_modules/lodash/_baseIsMap.js"(exports, module) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var mapTag = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }
    module.exports = baseIsMap;
  }
});

// node_modules/lodash/isMap.js
var require_isMap = __commonJS({
  "node_modules/lodash/isMap.js"(exports, module) {
    var baseIsMap = require_baseIsMap();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    module.exports = isMap;
  }
});

// node_modules/lodash/_baseIsSet.js
var require_baseIsSet = __commonJS({
  "node_modules/lodash/_baseIsSet.js"(exports, module) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var setTag = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }
    module.exports = baseIsSet;
  }
});

// node_modules/lodash/isSet.js
var require_isSet = __commonJS({
  "node_modules/lodash/isSet.js"(exports, module) {
    var baseIsSet = require_baseIsSet();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    module.exports = isSet;
  }
});

// node_modules/lodash/_baseClone.js
var require_baseClone = __commonJS({
  "node_modules/lodash/_baseClone.js"(exports, module) {
    var Stack = require_Stack();
    var arrayEach = require_arrayEach();
    var assignValue = require_assignValue();
    var baseAssign = require_baseAssign();
    var baseAssignIn = require_baseAssignIn();
    var cloneBuffer = require_cloneBuffer();
    var copyArray = require_copyArray();
    var copySymbols = require_copySymbols();
    var copySymbolsIn = require_copySymbolsIn();
    var getAllKeys = require_getAllKeys();
    var getAllKeysIn = require_getAllKeysIn();
    var getTag = require_getTag();
    var initCloneArray = require_initCloneArray();
    var initCloneByTag = require_initCloneByTag();
    var initCloneObject = require_initCloneObject();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isMap = require_isMap();
    var isObject2 = require_isObject();
    var isSet = require_isSet();
    var keys = require_keys();
    var keysIn = require_keysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject2(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
      return result;
    }
    module.exports = baseClone;
  }
});

// node_modules/lodash/cloneDeep.js
var require_cloneDeep = __commonJS({
  "node_modules/lodash/cloneDeep.js"(exports, module) {
    var baseClone = require_baseClone();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_SYMBOLS_FLAG = 4;
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }
    module.exports = cloneDeep;
  }
});

// node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "node_modules/lodash/_setCacheAdd.js"(exports, module) {
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module.exports = setCacheAdd;
  }
});

// node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "node_modules/lodash/_setCacheHas.js"(exports, module) {
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module.exports = setCacheHas;
  }
});

// node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "node_modules/lodash/_SetCache.js"(exports, module) {
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module.exports = SetCache;
  }
});

// node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "node_modules/lodash/_arraySome.js"(exports, module) {
    function arraySome(array2, predicate) {
      var index = -1, length = array2 == null ? 0 : array2.length;
      while (++index < length) {
        if (predicate(array2[index], index, array2)) {
          return true;
        }
      }
      return false;
    }
    module.exports = arraySome;
  }
});

// node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "node_modules/lodash/_cacheHas.js"(exports, module) {
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    module.exports = cacheHas;
  }
});

// node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "node_modules/lodash/_equalArrays.js"(exports, module) {
    var SetCache = require_SetCache();
    var arraySome = require_arraySome();
    var cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array2);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array2;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array2, other);
      stack.set(other, array2);
      while (++index < arrLength) {
        var arrValue = array2[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array2);
      stack["delete"](other);
      return result;
    }
    module.exports = equalArrays;
  }
});

// node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "node_modules/lodash/_mapToArray.js"(exports, module) {
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    module.exports = mapToArray;
  }
});

// node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "node_modules/lodash/_setToArray.js"(exports, module) {
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    module.exports = setToArray;
  }
});

// node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "node_modules/lodash/_equalByTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var Uint8Array = require_Uint8Array();
    var eq = require_eq();
    var equalArrays = require_equalArrays();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    module.exports = equalByTag;
  }
});

// node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "node_modules/lodash/_equalObjects.js"(exports, module) {
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    module.exports = equalObjects;
  }
});

// node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "node_modules/lodash/_baseIsEqualDeep.js"(exports, module) {
    var Stack = require_Stack();
    var equalArrays = require_equalArrays();
    var equalByTag = require_equalByTag();
    var equalObjects = require_equalObjects();
    var getTag = require_getTag();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isTypedArray = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    module.exports = baseIsEqualDeep;
  }
});

// node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "node_modules/lodash/_baseIsEqual.js"(exports, module) {
    var baseIsEqualDeep = require_baseIsEqualDeep();
    var isObjectLike = require_isObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    module.exports = baseIsEqual;
  }
});

// node_modules/lodash/isEqual.js
var require_isEqual = __commonJS({
  "node_modules/lodash/isEqual.js"(exports, module) {
    var baseIsEqual = require_baseIsEqual();
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    module.exports = isEqual;
  }
});

// node_modules/lodash/_isFlattenable.js
var require_isFlattenable = __commonJS({
  "node_modules/lodash/_isFlattenable.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    module.exports = isFlattenable;
  }
});

// node_modules/lodash/_baseFlatten.js
var require_baseFlatten = __commonJS({
  "node_modules/lodash/_baseFlatten.js"(exports, module) {
    var arrayPush = require_arrayPush();
    var isFlattenable = require_isFlattenable();
    function baseFlatten(array2, depth, predicate, isStrict, result) {
      var index = -1, length = array2.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array2[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    module.exports = baseFlatten;
  }
});

// node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "node_modules/lodash/_arrayMap.js"(exports, module) {
    function arrayMap(array2, iteratee) {
      var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array2[index], index, array2);
      }
      return result;
    }
    module.exports = arrayMap;
  }
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/lodash/isSymbol.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module.exports = isSymbol;
  }
});

// node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "node_modules/lodash/_isKey.js"(exports, module) {
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    module.exports = isKey;
  }
});

// node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "node_modules/lodash/memoize.js"(exports, module) {
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize2(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize2.Cache || MapCache)();
      return memoized;
    }
    memoize2.Cache = MapCache;
    module.exports = memoize2;
  }
});

// node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "node_modules/lodash/_memoizeCapped.js"(exports, module) {
    var memoize2 = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize2(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    module.exports = memoizeCapped;
  }
});

// node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "node_modules/lodash/_stringToPath.js"(exports, module) {
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    module.exports = stringToPath;
  }
});

// node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "node_modules/lodash/_baseToString.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module.exports = baseToString;
  }
});

// node_modules/lodash/toString.js
var require_toString = __commonJS({
  "node_modules/lodash/toString.js"(exports, module) {
    var baseToString = require_baseToString();
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    module.exports = toString;
  }
});

// node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "node_modules/lodash/_castPath.js"(exports, module) {
    var isArray = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString = require_toString();
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    module.exports = castPath;
  }
});

// node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "node_modules/lodash/_toKey.js"(exports, module) {
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module.exports = toKey;
  }
});

// node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "node_modules/lodash/_baseGet.js"(exports, module) {
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object, path) {
      path = castPath(path, object);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    module.exports = baseGet;
  }
});

// node_modules/lodash/_baseIsMatch.js
var require_baseIsMatch = __commonJS({
  "node_modules/lodash/_baseIsMatch.js"(exports, module) {
    var Stack = require_Stack();
    var baseIsEqual = require_baseIsEqual();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    module.exports = baseIsMatch;
  }
});

// node_modules/lodash/_isStrictComparable.js
var require_isStrictComparable = __commonJS({
  "node_modules/lodash/_isStrictComparable.js"(exports, module) {
    var isObject2 = require_isObject();
    function isStrictComparable(value) {
      return value === value && !isObject2(value);
    }
    module.exports = isStrictComparable;
  }
});

// node_modules/lodash/_getMatchData.js
var require_getMatchData = __commonJS({
  "node_modules/lodash/_getMatchData.js"(exports, module) {
    var isStrictComparable = require_isStrictComparable();
    var keys = require_keys();
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    module.exports = getMatchData;
  }
});

// node_modules/lodash/_matchesStrictComparable.js
var require_matchesStrictComparable = __commonJS({
  "node_modules/lodash/_matchesStrictComparable.js"(exports, module) {
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    module.exports = matchesStrictComparable;
  }
});

// node_modules/lodash/_baseMatches.js
var require_baseMatches = __commonJS({
  "node_modules/lodash/_baseMatches.js"(exports, module) {
    var baseIsMatch = require_baseIsMatch();
    var getMatchData = require_getMatchData();
    var matchesStrictComparable = require_matchesStrictComparable();
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    module.exports = baseMatches;
  }
});

// node_modules/lodash/get.js
var require_get = __commonJS({
  "node_modules/lodash/get.js"(exports, module) {
    var baseGet = require_baseGet();
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    module.exports = get;
  }
});

// node_modules/lodash/_baseHasIn.js
var require_baseHasIn = __commonJS({
  "node_modules/lodash/_baseHasIn.js"(exports, module) {
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    module.exports = baseHasIn;
  }
});

// node_modules/lodash/_hasPath.js
var require_hasPath = __commonJS({
  "node_modules/lodash/_hasPath.js"(exports, module) {
    var castPath = require_castPath();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isIndex = require_isIndex();
    var isLength = require_isLength();
    var toKey = require_toKey();
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);
      var index = -1, length = path.length, result = false;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    module.exports = hasPath;
  }
});

// node_modules/lodash/hasIn.js
var require_hasIn = __commonJS({
  "node_modules/lodash/hasIn.js"(exports, module) {
    var baseHasIn = require_baseHasIn();
    var hasPath = require_hasPath();
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    module.exports = hasIn;
  }
});

// node_modules/lodash/_baseMatchesProperty.js
var require_baseMatchesProperty = __commonJS({
  "node_modules/lodash/_baseMatchesProperty.js"(exports, module) {
    var baseIsEqual = require_baseIsEqual();
    var get = require_get();
    var hasIn = require_hasIn();
    var isKey = require_isKey();
    var isStrictComparable = require_isStrictComparable();
    var matchesStrictComparable = require_matchesStrictComparable();
    var toKey = require_toKey();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    module.exports = baseMatchesProperty;
  }
});

// node_modules/lodash/identity.js
var require_identity = __commonJS({
  "node_modules/lodash/identity.js"(exports, module) {
    function identity(value) {
      return value;
    }
    module.exports = identity;
  }
});

// node_modules/lodash/_baseProperty.js
var require_baseProperty = __commonJS({
  "node_modules/lodash/_baseProperty.js"(exports, module) {
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    module.exports = baseProperty;
  }
});

// node_modules/lodash/_basePropertyDeep.js
var require_basePropertyDeep = __commonJS({
  "node_modules/lodash/_basePropertyDeep.js"(exports, module) {
    var baseGet = require_baseGet();
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    module.exports = basePropertyDeep;
  }
});

// node_modules/lodash/property.js
var require_property = __commonJS({
  "node_modules/lodash/property.js"(exports, module) {
    var baseProperty = require_baseProperty();
    var basePropertyDeep = require_basePropertyDeep();
    var isKey = require_isKey();
    var toKey = require_toKey();
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module.exports = property;
  }
});

// node_modules/lodash/_baseIteratee.js
var require_baseIteratee = __commonJS({
  "node_modules/lodash/_baseIteratee.js"(exports, module) {
    var baseMatches = require_baseMatches();
    var baseMatchesProperty = require_baseMatchesProperty();
    var identity = require_identity();
    var isArray = require_isArray();
    var property = require_property();
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    module.exports = baseIteratee;
  }
});

// node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  "node_modules/lodash/_createBaseFor.js"(exports, module) {
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    module.exports = createBaseFor;
  }
});

// node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  "node_modules/lodash/_baseFor.js"(exports, module) {
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    module.exports = baseFor;
  }
});

// node_modules/lodash/_baseForOwn.js
var require_baseForOwn = __commonJS({
  "node_modules/lodash/_baseForOwn.js"(exports, module) {
    var baseFor = require_baseFor();
    var keys = require_keys();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    module.exports = baseForOwn;
  }
});

// node_modules/lodash/_createBaseEach.js
var require_createBaseEach = __commonJS({
  "node_modules/lodash/_createBaseEach.js"(exports, module) {
    var isArrayLike = require_isArrayLike();
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    module.exports = createBaseEach;
  }
});

// node_modules/lodash/_baseEach.js
var require_baseEach = __commonJS({
  "node_modules/lodash/_baseEach.js"(exports, module) {
    var baseForOwn = require_baseForOwn();
    var createBaseEach = require_createBaseEach();
    var baseEach = createBaseEach(baseForOwn);
    module.exports = baseEach;
  }
});

// node_modules/lodash/_baseMap.js
var require_baseMap = __commonJS({
  "node_modules/lodash/_baseMap.js"(exports, module) {
    var baseEach = require_baseEach();
    var isArrayLike = require_isArrayLike();
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key, collection2) {
        result[++index] = iteratee(value, key, collection2);
      });
      return result;
    }
    module.exports = baseMap;
  }
});

// node_modules/lodash/_baseSortBy.js
var require_baseSortBy = __commonJS({
  "node_modules/lodash/_baseSortBy.js"(exports, module) {
    function baseSortBy(array2, comparer) {
      var length = array2.length;
      array2.sort(comparer);
      while (length--) {
        array2[length] = array2[length].value;
      }
      return array2;
    }
    module.exports = baseSortBy;
  }
});

// node_modules/lodash/_compareAscending.js
var require_compareAscending = __commonJS({
  "node_modules/lodash/_compareAscending.js"(exports, module) {
    var isSymbol = require_isSymbol();
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
        var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }
    module.exports = compareAscending;
  }
});

// node_modules/lodash/_compareMultiple.js
var require_compareMultiple = __commonJS({
  "node_modules/lodash/_compareMultiple.js"(exports, module) {
    var compareAscending = require_compareAscending();
    function compareMultiple(object, other, orders) {
      var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == "desc" ? -1 : 1);
        }
      }
      return object.index - other.index;
    }
    module.exports = compareMultiple;
  }
});

// node_modules/lodash/_baseOrderBy.js
var require_baseOrderBy = __commonJS({
  "node_modules/lodash/_baseOrderBy.js"(exports, module) {
    var arrayMap = require_arrayMap();
    var baseGet = require_baseGet();
    var baseIteratee = require_baseIteratee();
    var baseMap = require_baseMap();
    var baseSortBy = require_baseSortBy();
    var baseUnary = require_baseUnary();
    var compareMultiple = require_compareMultiple();
    var identity = require_identity();
    var isArray = require_isArray();
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            };
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }
      var index = -1;
      iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
      var result = baseMap(collection, function(value, key, collection2) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { "criteria": criteria, "index": ++index, "value": value };
      });
      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }
    module.exports = baseOrderBy;
  }
});

// node_modules/lodash/_apply.js
var require_apply = __commonJS({
  "node_modules/lodash/_apply.js"(exports, module) {
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    module.exports = apply;
  }
});

// node_modules/lodash/_overRest.js
var require_overRest = __commonJS({
  "node_modules/lodash/_overRest.js"(exports, module) {
    var apply = require_apply();
    var nativeMax = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array2 = Array(length);
        while (++index < length) {
          array2[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array2);
        return apply(func, this, otherArgs);
      };
    }
    module.exports = overRest;
  }
});

// node_modules/lodash/constant.js
var require_constant = __commonJS({
  "node_modules/lodash/constant.js"(exports, module) {
    function constant(value) {
      return function() {
        return value;
      };
    }
    module.exports = constant;
  }
});

// node_modules/lodash/_baseSetToString.js
var require_baseSetToString = __commonJS({
  "node_modules/lodash/_baseSetToString.js"(exports, module) {
    var constant = require_constant();
    var defineProperty = require_defineProperty();
    var identity = require_identity();
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    module.exports = baseSetToString;
  }
});

// node_modules/lodash/_shortOut.js
var require_shortOut = __commonJS({
  "node_modules/lodash/_shortOut.js"(exports, module) {
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    module.exports = shortOut;
  }
});

// node_modules/lodash/_setToString.js
var require_setToString = __commonJS({
  "node_modules/lodash/_setToString.js"(exports, module) {
    var baseSetToString = require_baseSetToString();
    var shortOut = require_shortOut();
    var setToString = shortOut(baseSetToString);
    module.exports = setToString;
  }
});

// node_modules/lodash/_baseRest.js
var require_baseRest = __commonJS({
  "node_modules/lodash/_baseRest.js"(exports, module) {
    var identity = require_identity();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    module.exports = baseRest;
  }
});

// node_modules/lodash/_isIterateeCall.js
var require_isIterateeCall = __commonJS({
  "node_modules/lodash/_isIterateeCall.js"(exports, module) {
    var eq = require_eq();
    var isArrayLike = require_isArrayLike();
    var isIndex = require_isIndex();
    var isObject2 = require_isObject();
    function isIterateeCall(value, index, object) {
      if (!isObject2(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    module.exports = isIterateeCall;
  }
});

// node_modules/lodash/sortBy.js
var require_sortBy = __commonJS({
  "node_modules/lodash/sortBy.js"(exports, module) {
    var baseFlatten = require_baseFlatten();
    var baseOrderBy = require_baseOrderBy();
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });
    module.exports = sortBy;
  }
});

// node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
  "node_modules/lodash/_baseFindIndex.js"(exports, module) {
    function baseFindIndex(array2, predicate, fromIndex, fromRight) {
      var length = array2.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array2[index], index, array2)) {
          return index;
        }
      }
      return -1;
    }
    module.exports = baseFindIndex;
  }
});

// node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
  "node_modules/lodash/_baseIsNaN.js"(exports, module) {
    function baseIsNaN(value) {
      return value !== value;
    }
    module.exports = baseIsNaN;
  }
});

// node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
  "node_modules/lodash/_strictIndexOf.js"(exports, module) {
    function strictIndexOf(array2, value, fromIndex) {
      var index = fromIndex - 1, length = array2.length;
      while (++index < length) {
        if (array2[index] === value) {
          return index;
        }
      }
      return -1;
    }
    module.exports = strictIndexOf;
  }
});

// node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
  "node_modules/lodash/_baseIndexOf.js"(exports, module) {
    var baseFindIndex = require_baseFindIndex();
    var baseIsNaN = require_baseIsNaN();
    var strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array2, value, fromIndex) {
      return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
    }
    module.exports = baseIndexOf;
  }
});

// node_modules/lodash/_arrayIncludes.js
var require_arrayIncludes = __commonJS({
  "node_modules/lodash/_arrayIncludes.js"(exports, module) {
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes(array2, value) {
      var length = array2 == null ? 0 : array2.length;
      return !!length && baseIndexOf(array2, value, 0) > -1;
    }
    module.exports = arrayIncludes;
  }
});

// node_modules/lodash/_arrayIncludesWith.js
var require_arrayIncludesWith = __commonJS({
  "node_modules/lodash/_arrayIncludesWith.js"(exports, module) {
    function arrayIncludesWith(array2, value, comparator) {
      var index = -1, length = array2 == null ? 0 : array2.length;
      while (++index < length) {
        if (comparator(value, array2[index])) {
          return true;
        }
      }
      return false;
    }
    module.exports = arrayIncludesWith;
  }
});

// node_modules/lodash/noop.js
var require_noop = __commonJS({
  "node_modules/lodash/noop.js"(exports, module) {
    function noop() {
    }
    module.exports = noop;
  }
});

// node_modules/lodash/_createSet.js
var require_createSet = __commonJS({
  "node_modules/lodash/_createSet.js"(exports, module) {
    var Set2 = require_Set();
    var noop = require_noop();
    var setToArray = require_setToArray();
    var INFINITY = 1 / 0;
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
      return new Set2(values);
    };
    module.exports = createSet;
  }
});

// node_modules/lodash/_baseUniq.js
var require_baseUniq = __commonJS({
  "node_modules/lodash/_baseUniq.js"(exports, module) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var cacheHas = require_cacheHas();
    var createSet = require_createSet();
    var setToArray = require_setToArray();
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array2, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array2.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array2);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value = array2[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    module.exports = baseUniq;
  }
});

// node_modules/lodash/uniq.js
var require_uniq = __commonJS({
  "node_modules/lodash/uniq.js"(exports, module) {
    var baseUniq = require_baseUniq();
    function uniq(array2) {
      return array2 && array2.length ? baseUniq(array2) : [];
    }
    module.exports = uniq;
  }
});

// node_modules/lodash/uniqWith.js
var require_uniqWith = __commonJS({
  "node_modules/lodash/uniqWith.js"(exports, module) {
    var baseUniq = require_baseUniq();
    function uniqWith(array2, comparator) {
      comparator = typeof comparator == "function" ? comparator : void 0;
      return array2 && array2.length ? baseUniq(array2, void 0, comparator) : [];
    }
    module.exports = uniqWith;
  }
});

// node_modules/lodash/defaults.js
var require_defaults = __commonJS({
  "node_modules/lodash/defaults.js"(exports, module) {
    var baseRest = require_baseRest();
    var eq = require_eq();
    var isIterateeCall = require_isIterateeCall();
    var keysIn = require_keysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var defaults = baseRest(function(object, sources) {
      object = Object(object);
      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }
      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;
        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];
          if (value === void 0 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            object[key] = source[key];
          }
        }
      }
      return object;
    });
    module.exports = defaults;
  }
});

// node_modules/lodash/_baseIntersection.js
var require_baseIntersection = __commonJS({
  "node_modules/lodash/_baseIntersection.js"(exports, module) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var arrayMap = require_arrayMap();
    var baseUnary = require_baseUnary();
    var cacheHas = require_cacheHas();
    var nativeMin = Math.min;
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
      while (othIndex--) {
        var array2 = arrays[othIndex];
        if (othIndex && iteratee) {
          array2 = arrayMap(array2, baseUnary(iteratee));
        }
        maxLength = nativeMin(array2.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || length >= 120 && array2.length >= 120) ? new SetCache(othIndex && array2) : void 0;
      }
      array2 = arrays[0];
      var index = -1, seen = caches[0];
      outer:
        while (++index < length && result.length < maxLength) {
          var value = array2[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
            othIndex = othLength;
            while (--othIndex) {
              var cache = caches[othIndex];
              if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
                continue outer;
              }
            }
            if (seen) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    module.exports = baseIntersection;
  }
});

// node_modules/lodash/isArrayLikeObject.js
var require_isArrayLikeObject = __commonJS({
  "node_modules/lodash/isArrayLikeObject.js"(exports, module) {
    var isArrayLike = require_isArrayLike();
    var isObjectLike = require_isObjectLike();
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    module.exports = isArrayLikeObject;
  }
});

// node_modules/lodash/_castArrayLikeObject.js
var require_castArrayLikeObject = __commonJS({
  "node_modules/lodash/_castArrayLikeObject.js"(exports, module) {
    var isArrayLikeObject = require_isArrayLikeObject();
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }
    module.exports = castArrayLikeObject;
  }
});

// node_modules/lodash/last.js
var require_last = __commonJS({
  "node_modules/lodash/last.js"(exports, module) {
    function last(array2) {
      var length = array2 == null ? 0 : array2.length;
      return length ? array2[length - 1] : void 0;
    }
    module.exports = last;
  }
});

// node_modules/lodash/intersectionWith.js
var require_intersectionWith = __commonJS({
  "node_modules/lodash/intersectionWith.js"(exports, module) {
    var arrayMap = require_arrayMap();
    var baseIntersection = require_baseIntersection();
    var baseRest = require_baseRest();
    var castArrayLikeObject = require_castArrayLikeObject();
    var last = require_last();
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
      comparator = typeof comparator == "function" ? comparator : void 0;
      if (comparator) {
        mapped.pop();
      }
      return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, void 0, comparator) : [];
    });
    module.exports = intersectionWith;
  }
});

// node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS({
  "node_modules/lodash/isPlainObject.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var getPrototype = require_getPrototype();
    var isObjectLike = require_isObjectLike();
    var objectTag = "[object Object]";
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module.exports = isPlainObject;
  }
});

// node_modules/lodash/isBoolean.js
var require_isBoolean = __commonJS({
  "node_modules/lodash/isBoolean.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var boolTag = "[object Boolean]";
    function isBoolean(value) {
      return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
    }
    module.exports = isBoolean;
  }
});

// node_modules/json-schema-compare/src/index.js
var require_src = __commonJS({
  "node_modules/json-schema-compare/src/index.js"(exports, module) {
    var isEqual = require_isEqual();
    var sortBy = require_sortBy();
    var uniq = require_uniq();
    var uniqWith = require_uniqWith();
    var defaults = require_defaults();
    var intersectionWith = require_intersectionWith();
    var isPlainObject = require_isPlainObject();
    var isBoolean = require_isBoolean();
    var normalizeArray = (val) => Array.isArray(val) ? val : [val];
    var undef = (val) => val === void 0;
    var keys = (obj) => isPlainObject(obj) || Array.isArray(obj) ? Object.keys(obj) : [];
    var has = (obj, key) => obj.hasOwnProperty(key);
    var stringArray = (arr) => sortBy(uniq(arr));
    var undefEmpty = (val) => undef(val) || Array.isArray(val) && val.length === 0;
    var keyValEqual = (a, b, key, compare2) => b && has(b, key) && a && has(a, key) && compare2(a[key], b[key]);
    var undefAndZero = (a, b) => undef(a) && b === 0 || undef(b) && a === 0 || isEqual(a, b);
    var falseUndefined = (a, b) => undef(a) && b === false || undef(b) && a === false || isEqual(a, b);
    var emptySchema = (schema) => undef(schema) || isEqual(schema, {}) || schema === true;
    var emptyObjUndef = (schema) => undef(schema) || isEqual(schema, {});
    var isSchema2 = (val) => undef(val) || isPlainObject(val) || val === true || val === false;
    function undefArrayEqual(a, b) {
      if (undefEmpty(a) && undefEmpty(b)) {
        return true;
      } else {
        return isEqual(stringArray(a), stringArray(b));
      }
    }
    function unsortedNormalizedArray(a, b) {
      a = normalizeArray(a);
      b = normalizeArray(b);
      return isEqual(stringArray(a), stringArray(b));
    }
    function schemaGroup(a, b, key, compare2) {
      var allProps = uniq(keys(a).concat(keys(b)));
      if (emptyObjUndef(a) && emptyObjUndef(b)) {
        return true;
      } else if (emptyObjUndef(a) && keys(b).length) {
        return false;
      } else if (emptyObjUndef(b) && keys(a).length) {
        return false;
      }
      return allProps.every(function(key2) {
        var aVal = a[key2];
        var bVal = b[key2];
        if (Array.isArray(aVal) && Array.isArray(bVal)) {
          return isEqual(stringArray(a), stringArray(b));
        } else if (Array.isArray(aVal) && !Array.isArray(bVal)) {
          return false;
        } else if (Array.isArray(bVal) && !Array.isArray(aVal)) {
          return false;
        }
        return keyValEqual(a, b, key2, compare2);
      });
    }
    function items(a, b, key, compare2) {
      if (isPlainObject(a) && isPlainObject(b)) {
        return compare2(a, b);
      } else if (Array.isArray(a) && Array.isArray(b)) {
        return schemaGroup(a, b, key, compare2);
      } else {
        return isEqual(a, b);
      }
    }
    function unsortedArray(a, b, key, compare2) {
      var uniqueA = uniqWith(a, compare2);
      var uniqueB = uniqWith(b, compare2);
      var inter = intersectionWith(uniqueA, uniqueB, compare2);
      return inter.length === Math.max(uniqueA.length, uniqueB.length);
    }
    var comparers = {
      title: isEqual,
      uniqueItems: falseUndefined,
      minLength: undefAndZero,
      minItems: undefAndZero,
      minProperties: undefAndZero,
      required: undefArrayEqual,
      enum: undefArrayEqual,
      type: unsortedNormalizedArray,
      items,
      anyOf: unsortedArray,
      allOf: unsortedArray,
      oneOf: unsortedArray,
      properties: schemaGroup,
      patternProperties: schemaGroup,
      dependencies: schemaGroup
    };
    var acceptsUndefined = [
      "properties",
      "patternProperties",
      "dependencies",
      "uniqueItems",
      "minLength",
      "minItems",
      "minProperties",
      "required"
    ];
    var schemaProps = ["additionalProperties", "additionalItems", "contains", "propertyNames", "not"];
    function compare(a, b, options) {
      options = defaults(options, {
        ignore: []
      });
      if (emptySchema(a) && emptySchema(b)) {
        return true;
      }
      if (!isSchema2(a) || !isSchema2(b)) {
        throw new Error("Either of the values are not a JSON schema.");
      }
      if (a === b) {
        return true;
      }
      if (isBoolean(a) && isBoolean(b)) {
        return a === b;
      }
      if (a === void 0 && b === false || b === void 0 && a === false) {
        return false;
      }
      if (undef(a) && !undef(b) || !undef(a) && undef(b)) {
        return false;
      }
      var allKeys = uniq(Object.keys(a).concat(Object.keys(b)));
      if (options.ignore.length) {
        allKeys = allKeys.filter((k) => options.ignore.indexOf(k) === -1);
      }
      if (!allKeys.length) {
        return true;
      }
      function innerCompare(a2, b2) {
        return compare(a2, b2, options);
      }
      return allKeys.every(function(key) {
        var aValue = a[key];
        var bValue = b[key];
        if (schemaProps.indexOf(key) !== -1) {
          return compare(aValue, bValue, options);
        }
        var comparer = comparers[key];
        if (!comparer) {
          comparer = isEqual;
        }
        if (isEqual(aValue, bValue)) {
          return true;
        }
        if (acceptsUndefined.indexOf(key) === -1) {
          if (!has(a, key) && has(b, key) || has(a, key) && !has(b, key)) {
            return aValue === bValue;
          }
        }
        var result = comparer(aValue, bValue, key, innerCompare);
        if (!isBoolean(result)) {
          throw new Error("Comparer must return true or false");
        }
        return result;
      });
    }
    module.exports = compare;
  }
});

// node_modules/validate.io-array/lib/index.js
var require_lib = __commonJS({
  "node_modules/validate.io-array/lib/index.js"(exports, module) {
    "use strict";
    function isArray(value) {
      return Object.prototype.toString.call(value) === "[object Array]";
    }
    module.exports = Array.isArray || isArray;
  }
});

// node_modules/validate.io-number/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/validate.io-number/lib/index.js"(exports, module) {
    "use strict";
    function isNumber(value) {
      return (typeof value === "number" || Object.prototype.toString.call(value) === "[object Number]") && value.valueOf() === value.valueOf();
    }
    module.exports = isNumber;
  }
});

// node_modules/validate.io-integer/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/validate.io-integer/lib/index.js"(exports, module) {
    "use strict";
    var isNumber = require_lib2();
    function isInteger(value) {
      return isNumber(value) && value % 1 === 0;
    }
    module.exports = isInteger;
  }
});

// node_modules/validate.io-integer-array/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/validate.io-integer-array/lib/index.js"(exports, module) {
    "use strict";
    var isArray = require_lib();
    var isInteger = require_lib3();
    function isIntegerArray(value) {
      var len;
      if (!isArray(value)) {
        return false;
      }
      len = value.length;
      if (!len) {
        return false;
      }
      for (var i = 0; i < len; i++) {
        if (!isInteger(value[i])) {
          return false;
        }
      }
      return true;
    }
    module.exports = isIntegerArray;
  }
});

// node_modules/validate.io-function/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/validate.io-function/lib/index.js"(exports, module) {
    "use strict";
    function isFunction(value) {
      return typeof value === "function";
    }
    module.exports = isFunction;
  }
});

// node_modules/compute-gcd/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/compute-gcd/lib/index.js"(exports, module) {
    "use strict";
    var isArray = require_lib();
    var isIntegerArray = require_lib4();
    var isFunction = require_lib5();
    var MAXINT = Math.pow(2, 31) - 1;
    function gcd(a, b) {
      var k = 1, t;
      if (a === 0) {
        return b;
      }
      if (b === 0) {
        return a;
      }
      while (a % 2 === 0 && b % 2 === 0) {
        a = a / 2;
        b = b / 2;
        k = k * 2;
      }
      while (a % 2 === 0) {
        a = a / 2;
      }
      while (b) {
        while (b % 2 === 0) {
          b = b / 2;
        }
        if (a > b) {
          t = b;
          b = a;
          a = t;
        }
        b = b - a;
      }
      return k * a;
    }
    function bitwise(a, b) {
      var k = 0, t;
      if (a === 0) {
        return b;
      }
      if (b === 0) {
        return a;
      }
      while ((a & 1) === 0 && (b & 1) === 0) {
        a >>>= 1;
        b >>>= 1;
        k++;
      }
      while ((a & 1) === 0) {
        a >>>= 1;
      }
      while (b) {
        while ((b & 1) === 0) {
          b >>>= 1;
        }
        if (a > b) {
          t = b;
          b = a;
          a = t;
        }
        b = b - a;
      }
      return a << k;
    }
    function compute() {
      var nargs = arguments.length, args, clbk, arr, len, a, b, i;
      args = new Array(nargs);
      for (i = 0; i < nargs; i++) {
        args[i] = arguments[i];
      }
      if (isIntegerArray(args)) {
        if (nargs === 2) {
          a = args[0];
          b = args[1];
          if (a < 0) {
            a = -a;
          }
          if (b < 0) {
            b = -b;
          }
          if (a <= MAXINT && b <= MAXINT) {
            return bitwise(a, b);
          } else {
            return gcd(a, b);
          }
        }
        arr = args;
      } else if (!isArray(args[0])) {
        throw new TypeError("gcd()::invalid input argument. Must provide an array of integers. Value: `" + args[0] + "`.");
      } else if (nargs > 1) {
        arr = args[0];
        clbk = args[1];
        if (!isFunction(clbk)) {
          throw new TypeError("gcd()::invalid input argument. Accessor must be a function. Value: `" + clbk + "`.");
        }
      } else {
        arr = args[0];
      }
      len = arr.length;
      if (len < 2) {
        return null;
      }
      if (clbk) {
        a = new Array(len);
        for (i = 0; i < len; i++) {
          a[i] = clbk(arr[i], i);
        }
        arr = a;
      }
      if (nargs < 3) {
        if (!isIntegerArray(arr)) {
          throw new TypeError("gcd()::invalid input argument. Accessed array values must be integers. Value: `" + arr + "`.");
        }
      }
      for (i = 0; i < len; i++) {
        a = arr[i];
        if (a < 0) {
          arr[i] = -a;
        }
      }
      a = arr[0];
      for (i = 1; i < len; i++) {
        b = arr[i];
        if (b <= MAXINT && a <= MAXINT) {
          a = bitwise(a, b);
        } else {
          a = gcd(a, b);
        }
      }
      return a;
    }
    module.exports = compute;
  }
});

// node_modules/compute-lcm/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/compute-lcm/lib/index.js"(exports, module) {
    "use strict";
    var gcd = require_lib6();
    var isArray = require_lib();
    var isIntegerArray = require_lib4();
    var isFunction = require_lib5();
    function lcm() {
      var nargs = arguments.length, args, clbk, arr, len, a, b, i;
      args = new Array(nargs);
      for (i = 0; i < nargs; i++) {
        args[i] = arguments[i];
      }
      if (isIntegerArray(args)) {
        if (nargs === 2) {
          a = args[0];
          b = args[1];
          if (a < 0) {
            a = -a;
          }
          if (b < 0) {
            b = -b;
          }
          if (a === 0 || b === 0) {
            return 0;
          }
          return a / gcd(a, b) * b;
        }
        arr = args;
      } else if (!isArray(args[0])) {
        throw new TypeError("lcm()::invalid input argument. Must provide an array of integers. Value: `" + args[0] + "`.");
      } else if (nargs > 1) {
        arr = args[0];
        clbk = args[1];
        if (!isFunction(clbk)) {
          throw new TypeError("lcm()::invalid input argument. Accessor must be a function. Value: `" + clbk + "`.");
        }
      } else {
        arr = args[0];
      }
      len = arr.length;
      if (len < 2) {
        return null;
      }
      if (clbk) {
        a = new Array(len);
        for (i = 0; i < len; i++) {
          a[i] = clbk(arr[i], i);
        }
        arr = a;
      }
      if (nargs < 3) {
        if (!isIntegerArray(arr)) {
          throw new TypeError("lcm()::invalid input argument. Accessed array values must be integers. Value: `" + arr + "`.");
        }
      }
      for (i = 0; i < len; i++) {
        a = arr[i];
        if (a < 0) {
          arr[i] = -a;
        }
      }
      a = arr[0];
      for (i = 1; i < len; i++) {
        b = arr[i];
        if (a === 0 || b === 0) {
          return 0;
        }
        a = a / gcd(a, b) * b;
      }
      return a;
    }
    module.exports = lcm;
  }
});

// node_modules/lodash/_assignMergeValue.js
var require_assignMergeValue = __commonJS({
  "node_modules/lodash/_assignMergeValue.js"(exports, module) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module.exports = assignMergeValue;
  }
});

// node_modules/lodash/_safeGet.js
var require_safeGet = __commonJS({
  "node_modules/lodash/_safeGet.js"(exports, module) {
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    module.exports = safeGet;
  }
});

// node_modules/lodash/toPlainObject.js
var require_toPlainObject = __commonJS({
  "node_modules/lodash/toPlainObject.js"(exports, module) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    module.exports = toPlainObject;
  }
});

// node_modules/lodash/_baseMergeDeep.js
var require_baseMergeDeep = __commonJS({
  "node_modules/lodash/_baseMergeDeep.js"(exports, module) {
    var assignMergeValue = require_assignMergeValue();
    var cloneBuffer = require_cloneBuffer();
    var cloneTypedArray = require_cloneTypedArray();
    var copyArray = require_copyArray();
    var initCloneObject = require_initCloneObject();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isArrayLikeObject = require_isArrayLikeObject();
    var isBuffer = require_isBuffer();
    var isFunction = require_isFunction();
    var isObject2 = require_isObject();
    var isPlainObject = require_isPlainObject();
    var isTypedArray = require_isTypedArray();
    var safeGet = require_safeGet();
    var toPlainObject = require_toPlainObject();
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject2(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    module.exports = baseMergeDeep;
  }
});

// node_modules/lodash/_baseMerge.js
var require_baseMerge = __commonJS({
  "node_modules/lodash/_baseMerge.js"(exports, module) {
    var Stack = require_Stack();
    var assignMergeValue = require_assignMergeValue();
    var baseFor = require_baseFor();
    var baseMergeDeep = require_baseMergeDeep();
    var isObject2 = require_isObject();
    var keysIn = require_keysIn();
    var safeGet = require_safeGet();
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject2(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    module.exports = baseMerge;
  }
});

// node_modules/lodash/_customDefaultsMerge.js
var require_customDefaultsMerge = __commonJS({
  "node_modules/lodash/_customDefaultsMerge.js"(exports, module) {
    var baseMerge = require_baseMerge();
    var isObject2 = require_isObject();
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject2(objValue) && isObject2(srcValue)) {
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, void 0, customDefaultsMerge, stack);
        stack["delete"](srcValue);
      }
      return objValue;
    }
    module.exports = customDefaultsMerge;
  }
});

// node_modules/lodash/_createAssigner.js
var require_createAssigner = __commonJS({
  "node_modules/lodash/_createAssigner.js"(exports, module) {
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    module.exports = createAssigner;
  }
});

// node_modules/lodash/mergeWith.js
var require_mergeWith = __commonJS({
  "node_modules/lodash/mergeWith.js"(exports, module) {
    var baseMerge = require_baseMerge();
    var createAssigner = require_createAssigner();
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });
    module.exports = mergeWith;
  }
});

// node_modules/lodash/defaultsDeep.js
var require_defaultsDeep = __commonJS({
  "node_modules/lodash/defaultsDeep.js"(exports, module) {
    var apply = require_apply();
    var baseRest = require_baseRest();
    var customDefaultsMerge = require_customDefaultsMerge();
    var mergeWith = require_mergeWith();
    var defaultsDeep = baseRest(function(args) {
      args.push(void 0, customDefaultsMerge);
      return apply(mergeWith, void 0, args);
    });
    module.exports = defaultsDeep;
  }
});

// node_modules/lodash/flatten.js
var require_flatten = __commonJS({
  "node_modules/lodash/flatten.js"(exports, module) {
    var baseFlatten = require_baseFlatten();
    function flatten(array2) {
      var length = array2 == null ? 0 : array2.length;
      return length ? baseFlatten(array2, 1) : [];
    }
    module.exports = flatten;
  }
});

// node_modules/lodash/flattenDeep.js
var require_flattenDeep = __commonJS({
  "node_modules/lodash/flattenDeep.js"(exports, module) {
    var baseFlatten = require_baseFlatten();
    var INFINITY = 1 / 0;
    function flattenDeep(array2) {
      var length = array2 == null ? 0 : array2.length;
      return length ? baseFlatten(array2, INFINITY) : [];
    }
    module.exports = flattenDeep;
  }
});

// node_modules/lodash/intersection.js
var require_intersection = __commonJS({
  "node_modules/lodash/intersection.js"(exports, module) {
    var arrayMap = require_arrayMap();
    var baseIntersection = require_baseIntersection();
    var baseRest = require_baseRest();
    var castArrayLikeObject = require_castArrayLikeObject();
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
    });
    module.exports = intersection;
  }
});

// node_modules/lodash/_baseIndexOfWith.js
var require_baseIndexOfWith = __commonJS({
  "node_modules/lodash/_baseIndexOfWith.js"(exports, module) {
    function baseIndexOfWith(array2, value, fromIndex, comparator) {
      var index = fromIndex - 1, length = array2.length;
      while (++index < length) {
        if (comparator(array2[index], value)) {
          return index;
        }
      }
      return -1;
    }
    module.exports = baseIndexOfWith;
  }
});

// node_modules/lodash/_basePullAll.js
var require_basePullAll = __commonJS({
  "node_modules/lodash/_basePullAll.js"(exports, module) {
    var arrayMap = require_arrayMap();
    var baseIndexOf = require_baseIndexOf();
    var baseIndexOfWith = require_baseIndexOfWith();
    var baseUnary = require_baseUnary();
    var copyArray = require_copyArray();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function basePullAll(array2, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values.length, seen = array2;
      if (array2 === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array2, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value;
        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array2) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array2, fromIndex, 1);
        }
      }
      return array2;
    }
    module.exports = basePullAll;
  }
});

// node_modules/lodash/pullAll.js
var require_pullAll = __commonJS({
  "node_modules/lodash/pullAll.js"(exports, module) {
    var basePullAll = require_basePullAll();
    function pullAll(array2, values) {
      return array2 && array2.length && values && values.length ? basePullAll(array2, values) : array2;
    }
    module.exports = pullAll;
  }
});

// node_modules/lodash/_castFunction.js
var require_castFunction = __commonJS({
  "node_modules/lodash/_castFunction.js"(exports, module) {
    var identity = require_identity();
    function castFunction(value) {
      return typeof value == "function" ? value : identity;
    }
    module.exports = castFunction;
  }
});

// node_modules/lodash/forEach.js
var require_forEach = __commonJS({
  "node_modules/lodash/forEach.js"(exports, module) {
    var arrayEach = require_arrayEach();
    var baseEach = require_baseEach();
    var castFunction = require_castFunction();
    var isArray = require_isArray();
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, castFunction(iteratee));
    }
    module.exports = forEach;
  }
});

// node_modules/lodash/_baseDifference.js
var require_baseDifference = __commonJS({
  "node_modules/lodash/_baseDifference.js"(exports, module) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var arrayMap = require_arrayMap();
    var baseUnary = require_baseUnary();
    var cacheHas = require_cacheHas();
    var LARGE_ARRAY_SIZE = 200;
    function baseDifference(array2, values, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, isCommon = true, length = array2.length, result = [], valuesLength = values.length;
      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
        while (++index < length) {
          var value = array2[index], computed = iteratee == null ? value : iteratee(value);
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
      return result;
    }
    module.exports = baseDifference;
  }
});

// node_modules/lodash/without.js
var require_without = __commonJS({
  "node_modules/lodash/without.js"(exports, module) {
    var baseDifference = require_baseDifference();
    var baseRest = require_baseRest();
    var isArrayLikeObject = require_isArrayLikeObject();
    var without = baseRest(function(array2, values) {
      return isArrayLikeObject(array2) ? baseDifference(array2, values) : [];
    });
    module.exports = without;
  }
});

// node_modules/json-schema-merge-allof/src/common.js
var require_common = __commonJS({
  "node_modules/json-schema-merge-allof/src/common.js"(exports, module) {
    var flatten = require_flatten();
    var flattenDeep = require_flattenDeep();
    var isPlainObject = require_isPlainObject();
    var uniq = require_uniq();
    var uniqWith = require_uniqWith();
    var without = require_without();
    function deleteUndefinedProps(returnObject) {
      for (const prop in returnObject) {
        if (has(returnObject, prop) && isEmptySchema(returnObject[prop])) {
          delete returnObject[prop];
        }
      }
      return returnObject;
    }
    var allUniqueKeys = (arr) => uniq(flattenDeep(arr.map(keys)));
    var getValues = (schemas, key) => schemas.map((schema) => schema && schema[key]);
    var has = (obj, propName) => Object.prototype.hasOwnProperty.call(obj, propName);
    var keys = (obj) => {
      if (isPlainObject(obj) || Array.isArray(obj)) {
        return Object.keys(obj);
      } else {
        return [];
      }
    };
    var notUndefined = (val) => val !== void 0;
    var isSchema2 = (val) => isPlainObject(val) || val === true || val === false;
    var isEmptySchema = (obj) => !keys(obj).length && obj !== false && obj !== true;
    var withoutArr = (arr, ...rest) => without.apply(null, [arr].concat(flatten(rest)));
    module.exports = {
      allUniqueKeys,
      deleteUndefinedProps,
      getValues,
      has,
      isEmptySchema,
      isSchema: isSchema2,
      keys,
      notUndefined,
      uniqWith,
      withoutArr
    };
  }
});

// node_modules/json-schema-merge-allof/src/complex-resolvers/properties.js
var require_properties = __commonJS({
  "node_modules/json-schema-merge-allof/src/complex-resolvers/properties.js"(exports, module) {
    var compare = require_src();
    var forEach = require_forEach();
    var {
      allUniqueKeys,
      deleteUndefinedProps,
      getValues,
      keys,
      notUndefined,
      uniqWith,
      withoutArr
    } = require_common();
    function removeFalseSchemas(target) {
      forEach(target, function(schema, prop) {
        if (schema === false) {
          delete target[prop];
        }
      });
    }
    function mergeSchemaGroup(group, mergeSchemas2) {
      const allKeys = allUniqueKeys(group);
      return allKeys.reduce(function(all, key) {
        const schemas = getValues(group, key);
        const compacted = uniqWith(schemas.filter(notUndefined), compare);
        all[key] = mergeSchemas2(compacted, key);
        return all;
      }, {});
    }
    module.exports = {
      keywords: ["properties", "patternProperties", "additionalProperties"],
      resolver(values, parents, mergers, options) {
        if (!options.ignoreAdditionalProperties) {
          values.forEach(function(subSchema) {
            const otherSubSchemas = values.filter((s) => s !== subSchema);
            const ownKeys = keys(subSchema.properties);
            const ownPatternKeys = keys(subSchema.patternProperties);
            const ownPatterns = ownPatternKeys.map((k) => new RegExp(k));
            otherSubSchemas.forEach(function(other) {
              const allOtherKeys = keys(other.properties);
              const keysMatchingPattern = allOtherKeys.filter((k) => ownPatterns.some((pk) => pk.test(k)));
              const additionalKeys = withoutArr(allOtherKeys, ownKeys, keysMatchingPattern);
              additionalKeys.forEach(function(key) {
                other.properties[key] = mergers.properties([
                  other.properties[key],
                  subSchema.additionalProperties
                ], key);
              });
            });
          });
          values.forEach(function(subSchema) {
            const otherSubSchemas = values.filter((s) => s !== subSchema);
            const ownPatternKeys = keys(subSchema.patternProperties);
            if (subSchema.additionalProperties === false) {
              otherSubSchemas.forEach(function(other) {
                const allOtherPatterns = keys(other.patternProperties);
                const additionalPatternKeys = withoutArr(allOtherPatterns, ownPatternKeys);
                additionalPatternKeys.forEach((key) => delete other.patternProperties[key]);
              });
            }
          });
        }
        const returnObject = {
          additionalProperties: mergers.additionalProperties(values.map((s) => s.additionalProperties)),
          patternProperties: mergeSchemaGroup(values.map((s) => s.patternProperties), mergers.patternProperties),
          properties: mergeSchemaGroup(values.map((s) => s.properties), mergers.properties)
        };
        if (returnObject.additionalProperties === false) {
          removeFalseSchemas(returnObject.properties);
        }
        return deleteUndefinedProps(returnObject);
      }
    };
  }
});

// node_modules/json-schema-merge-allof/src/complex-resolvers/items.js
var require_items = __commonJS({
  "node_modules/json-schema-merge-allof/src/complex-resolvers/items.js"(exports, module) {
    var compare = require_src();
    var forEach = require_forEach();
    var {
      allUniqueKeys,
      deleteUndefinedProps,
      has,
      isSchema: isSchema2,
      notUndefined,
      uniqWith
    } = require_common();
    function removeFalseSchemasFromArray(target) {
      forEach(target, function(schema, index) {
        if (schema === false) {
          target.splice(index, 1);
        }
      });
    }
    function getItemSchemas(subSchemas, key) {
      return subSchemas.map(function(sub) {
        if (!sub) {
          return void 0;
        }
        if (Array.isArray(sub.items)) {
          const schemaAtPos = sub.items[key];
          if (isSchema2(schemaAtPos)) {
            return schemaAtPos;
          } else if (has(sub, "additionalItems")) {
            return sub.additionalItems;
          }
        } else {
          return sub.items;
        }
        return void 0;
      });
    }
    function getAdditionalSchemas(subSchemas) {
      return subSchemas.map(function(sub) {
        if (!sub) {
          return void 0;
        }
        if (Array.isArray(sub.items)) {
          return sub.additionalItems;
        }
        return sub.items;
      });
    }
    function mergeItems(group, mergeSchemas2, items) {
      const allKeys = allUniqueKeys(items);
      return allKeys.reduce(function(all, key) {
        const schemas = getItemSchemas(group, key);
        const compacted = uniqWith(schemas.filter(notUndefined), compare);
        all[key] = mergeSchemas2(compacted, key);
        return all;
      }, []);
    }
    module.exports = {
      keywords: ["items", "additionalItems"],
      resolver(values, parents, mergers) {
        const items = values.map((s) => s.items);
        const itemsCompacted = items.filter(notUndefined);
        const returnObject = {};
        if (itemsCompacted.every(isSchema2)) {
          returnObject.items = mergers.items(items);
        } else {
          returnObject.items = mergeItems(values, mergers.items, items);
        }
        let schemasAtLastPos;
        if (itemsCompacted.every(Array.isArray)) {
          schemasAtLastPos = values.map((s) => s.additionalItems);
        } else if (itemsCompacted.some(Array.isArray)) {
          schemasAtLastPos = getAdditionalSchemas(values);
        }
        if (schemasAtLastPos) {
          returnObject.additionalItems = mergers.additionalItems(schemasAtLastPos);
        }
        if (returnObject.additionalItems === false && Array.isArray(returnObject.items)) {
          removeFalseSchemasFromArray(returnObject.items);
        }
        return deleteUndefinedProps(returnObject);
      }
    };
  }
});

// node_modules/json-schema-merge-allof/src/index.js
var require_src2 = __commonJS({
  "node_modules/json-schema-merge-allof/src/index.js"(exports, module) {
    var cloneDeep = require_cloneDeep();
    var compare = require_src();
    var computeLcm = require_lib7();
    var defaultsDeep = require_defaultsDeep();
    var flatten = require_flatten();
    var flattenDeep = require_flattenDeep();
    var intersection = require_intersection();
    var intersectionWith = require_intersectionWith();
    var isEqual = require_isEqual();
    var isPlainObject = require_isPlainObject();
    var pullAll = require_pullAll();
    var sortBy = require_sortBy();
    var uniq = require_uniq();
    var uniqWith = require_uniqWith();
    var propertiesResolver = require_properties();
    var itemsResolver = require_items();
    var contains = (arr, val) => arr.indexOf(val) !== -1;
    var isSchema2 = (val) => isPlainObject(val) || val === true || val === false;
    var isFalse = (val) => val === false;
    var isTrue = (val) => val === true;
    var schemaResolver = (compacted, key, mergeSchemas2) => mergeSchemas2(compacted);
    var stringArray = (values) => sortBy(uniq(flattenDeep(values)));
    var notUndefined = (val) => val !== void 0;
    var allUniqueKeys = (arr) => uniq(flattenDeep(arr.map(keys)));
    var first = (compacted) => compacted[0];
    var required = (compacted) => stringArray(compacted);
    var maximumValue = (compacted) => Math.max.apply(Math, compacted);
    var minimumValue = (compacted) => Math.min.apply(Math, compacted);
    var uniqueItems = (compacted) => compacted.some(isTrue);
    var examples = (compacted) => uniqWith(flatten(compacted), isEqual);
    function compareProp(key) {
      return function(a, b) {
        return compare({
          [key]: a
        }, { [key]: b });
      };
    }
    function getAllOf(schema) {
      let { allOf = [], ...copy } = schema;
      copy = isPlainObject(schema) ? copy : schema;
      return [copy, ...allOf.map(getAllOf)];
    }
    function getValues(schemas, key) {
      return schemas.map((schema) => schema && schema[key]);
    }
    function tryMergeSchemaGroups(schemaGroups, mergeSchemas2) {
      return schemaGroups.map(function(schemas, index) {
        try {
          return mergeSchemas2(schemas, index);
        } catch (e) {
          return void 0;
        }
      }).filter(notUndefined);
    }
    function keys(obj) {
      if (isPlainObject(obj) || Array.isArray(obj)) {
        return Object.keys(obj);
      } else {
        return [];
      }
    }
    function getAnyOfCombinations(arrOfArrays, combinations) {
      combinations = combinations || [];
      if (!arrOfArrays.length) {
        return combinations;
      }
      const values = arrOfArrays.slice(0).shift();
      const rest = arrOfArrays.slice(1);
      if (combinations.length) {
        return getAnyOfCombinations(rest, flatten(combinations.map((combination) => values.map((item) => [item].concat(combination)))));
      }
      return getAnyOfCombinations(rest, values.map((item) => item));
    }
    function throwIncompatible(values, paths) {
      let asJSON;
      try {
        asJSON = values.map(function(val) {
          return JSON.stringify(val, null, 2);
        }).join("\n");
      } catch (variable) {
        asJSON = values.join(", ");
      }
      throw new Error('Could not resolve values for path:"' + paths.join(".") + '". They are probably incompatible. Values: \n' + asJSON);
    }
    function callGroupResolver(complexKeywords, resolverName, schemas, mergeSchemas2, options, parents) {
      if (complexKeywords.length) {
        const resolverConfig = options.complexResolvers[resolverName];
        if (!resolverConfig || !resolverConfig.resolver) {
          throw new Error("No resolver found for " + resolverName);
        }
        const extractedKeywordsOnly = schemas.map((schema) => complexKeywords.reduce((all, key) => {
          if (schema[key] !== void 0) all[key] = schema[key];
          return all;
        }, {}));
        const unique = uniqWith(extractedKeywordsOnly, compare);
        const mergers = resolverConfig.keywords.reduce((all, key) => ({
          ...all,
          [key]: (schemas2, extraKey = []) => mergeSchemas2(schemas2, null, parents.concat(key, extraKey))
        }), {});
        const result = resolverConfig.resolver(unique, parents.concat(resolverName), mergers, options);
        if (!isPlainObject(result)) {
          throwIncompatible(unique, parents.concat(resolverName));
        }
        return result;
      }
    }
    function createRequiredMetaArray(arr) {
      return { required: arr };
    }
    var schemaGroupProps = ["properties", "patternProperties", "definitions", "dependencies"];
    var schemaArrays = ["anyOf", "oneOf"];
    var schemaProps = [
      "additionalProperties",
      "additionalItems",
      "contains",
      "propertyNames",
      "not",
      "items"
    ];
    var defaultResolvers = {
      type(compacted) {
        if (compacted.some(Array.isArray)) {
          const normalized = compacted.map(function(val) {
            return Array.isArray(val) ? val : [val];
          });
          const common = intersection.apply(null, normalized);
          if (common.length === 1) {
            return common[0];
          } else if (common.length > 1) {
            return uniq(common);
          }
        }
      },
      dependencies(compacted, paths, mergeSchemas2) {
        const allChildren = allUniqueKeys(compacted);
        return allChildren.reduce(function(all, childKey) {
          const childSchemas = getValues(compacted, childKey);
          let innerCompacted = uniqWith(childSchemas.filter(notUndefined), isEqual);
          const innerArrays = innerCompacted.filter(Array.isArray);
          if (innerArrays.length) {
            if (innerArrays.length === innerCompacted.length) {
              all[childKey] = stringArray(innerCompacted);
            } else {
              const innerSchemas = innerCompacted.filter(isSchema2);
              const arrayMetaScheams = innerArrays.map(createRequiredMetaArray);
              all[childKey] = mergeSchemas2(innerSchemas.concat(arrayMetaScheams), childKey);
            }
            return all;
          }
          innerCompacted = uniqWith(innerCompacted, compare);
          all[childKey] = mergeSchemas2(innerCompacted, childKey);
          return all;
        }, {});
      },
      oneOf(compacted, paths, mergeSchemas2) {
        const combinations = getAnyOfCombinations(cloneDeep(compacted));
        const result = tryMergeSchemaGroups(combinations, mergeSchemas2);
        const unique = uniqWith(result, compare);
        if (unique.length) {
          return unique;
        }
      },
      not(compacted) {
        return { anyOf: compacted };
      },
      pattern(compacted) {
        return compacted.map((r) => "(?=" + r + ")").join("");
      },
      multipleOf(compacted) {
        let integers = compacted.slice(0);
        let factor = 1;
        while (integers.some((n) => !Number.isInteger(n))) {
          integers = integers.map((n) => n * 10);
          factor = factor * 10;
        }
        return computeLcm(integers) / factor;
      },
      enum(compacted) {
        const enums = intersectionWith.apply(null, compacted.concat(isEqual));
        if (enums.length) {
          return sortBy(enums);
        }
      }
    };
    defaultResolvers.$id = first;
    defaultResolvers.$ref = first;
    defaultResolvers.$schema = first;
    defaultResolvers.additionalItems = schemaResolver;
    defaultResolvers.additionalProperties = schemaResolver;
    defaultResolvers.anyOf = defaultResolvers.oneOf;
    defaultResolvers.contains = schemaResolver;
    defaultResolvers.default = first;
    defaultResolvers.definitions = defaultResolvers.dependencies;
    defaultResolvers.description = first;
    defaultResolvers.examples = examples;
    defaultResolvers.exclusiveMaximum = minimumValue;
    defaultResolvers.exclusiveMinimum = maximumValue;
    defaultResolvers.items = itemsResolver;
    defaultResolvers.maximum = minimumValue;
    defaultResolvers.maxItems = minimumValue;
    defaultResolvers.maxLength = minimumValue;
    defaultResolvers.maxProperties = minimumValue;
    defaultResolvers.minimum = maximumValue;
    defaultResolvers.minItems = maximumValue;
    defaultResolvers.minLength = maximumValue;
    defaultResolvers.minProperties = maximumValue;
    defaultResolvers.properties = propertiesResolver;
    defaultResolvers.propertyNames = schemaResolver;
    defaultResolvers.required = required;
    defaultResolvers.title = first;
    defaultResolvers.uniqueItems = uniqueItems;
    var defaultComplexResolvers = {
      properties: propertiesResolver,
      items: itemsResolver
    };
    function merger(rootSchema, options, totalSchemas) {
      totalSchemas = totalSchemas || [];
      options = defaultsDeep(options, {
        ignoreAdditionalProperties: false,
        resolvers: defaultResolvers,
        complexResolvers: defaultComplexResolvers,
        deep: true
      });
      const complexResolvers = Object.entries(options.complexResolvers);
      function mergeSchemas2(schemas, base, parents) {
        schemas = cloneDeep(schemas.filter(notUndefined));
        parents = parents || [];
        const merged2 = isPlainObject(base) ? base : {};
        if (!schemas.length) {
          return;
        }
        if (schemas.some(isFalse)) {
          return false;
        }
        if (schemas.every(isTrue)) {
          return true;
        }
        schemas = schemas.filter(isPlainObject);
        const allKeys = allUniqueKeys(schemas);
        if (options.deep && contains(allKeys, "allOf")) {
          return merger({
            allOf: schemas
          }, options, totalSchemas);
        }
        const complexKeysArr = complexResolvers.map(([mainKeyWord, resolverConf]) => allKeys.filter((k) => resolverConf.keywords.includes(k)));
        complexKeysArr.forEach((keys2) => pullAll(allKeys, keys2));
        allKeys.forEach(function(key) {
          const values = getValues(schemas, key);
          const compacted = uniqWith(values.filter(notUndefined), compareProp(key));
          if (compacted.length === 1 && contains(schemaArrays, key)) {
            merged2[key] = compacted[0].map((schema) => mergeSchemas2([schema], schema));
          } else if (compacted.length === 1 && !contains(schemaGroupProps, key) && !contains(schemaProps, key)) {
            merged2[key] = compacted[0];
          } else {
            const resolver = options.resolvers[key] || options.resolvers.defaultResolver;
            if (!resolver) throw new Error("No resolver found for key " + key + ". You can provide a resolver for this keyword in the options, or provide a default resolver.");
            const merger2 = (schemas2, extraKey = []) => mergeSchemas2(schemas2, null, parents.concat(key, extraKey));
            merged2[key] = resolver(compacted, parents.concat(key), merger2, options);
            if (merged2[key] === void 0) {
              throwIncompatible(compacted, parents.concat(key));
            } else if (merged2[key] === void 0) {
              delete merged2[key];
            }
          }
        });
        return complexResolvers.reduce((all, [resolverKeyword, config], index) => ({
          ...all,
          ...callGroupResolver(complexKeysArr[index], resolverKeyword, schemas, mergeSchemas2, options, parents)
        }), merged2);
      }
      const allSchemas = flattenDeep(getAllOf(rootSchema));
      const merged = mergeSchemas2(allSchemas);
      return merged;
    }
    merger.options = {
      resolvers: defaultResolvers
    };
    module.exports = merger;
  }
});

// node_modules/@sjsf/form/dist/core/schema.js
var REF_KEY = "$ref";
var ID_KEY = "$id";
var DEFS_KEY = "$defs";
var DEFINITIONS_KEY = "definitions";
var PROPERTIES_KEY = "properties";
var ITEMS_KEY = "items";
var DEPENDENCIES_KEY = "dependencies";
var REQUIRED_KEY = "required";
var PATTERN_PROPERTIES_KEY = "patternProperties";
var DEFAULT_KEY = "default";
var CONST_KEY = "const";
var IF_KEY = "if";
var THEN_KEY = "then";
var ELSE_KEY = "else";
var CONTAINS_KEY = "contains";
var ALL_OF_KEY = "allOf";
var ANY_OF_KEY = "anyOf";
var ONE_OF_KEY = "oneOf";
var NOT_KEY = "not";
var ROOT_SCHEMA_PREFIX = "__sjsf_rootSchema";
var ADDITIONAL_PROPERTY_FLAG = "__additional_property";
var ADDITIONAL_PROPERTIES_KEY = "additionalProperties";
var ADDITIONAL_ITEMS_KEY = "additionalItems";
var PROPERTY_NAMES_KEY = "propertyNames";
var DISCRIMINATOR_KEY = "discriminator";
var PROPERTY_NAME_KEY = "propertyName";
var DATA_URL_FORMAT = "data-url";
var RECORDS_OF_SUB_SCHEMAS = [
  DEFS_KEY,
  DEFINITIONS_KEY,
  PROPERTIES_KEY,
  PATTERN_PROPERTIES_KEY,
  DEPENDENCIES_KEY
];
var SET_OF_RECORDS_OF_SUB_SCHEMAS = new Set(RECORDS_OF_SUB_SCHEMAS);
var ARRAYS_OF_SUB_SCHEMAS = [
  ITEMS_KEY,
  ALL_OF_KEY,
  ONE_OF_KEY,
  ANY_OF_KEY
];
var SET_OF_ARRAYS_OF_SUB_SCHEMAS = new Set(ARRAYS_OF_SUB_SCHEMAS);
var SUB_SCHEMAS = [
  ITEMS_KEY,
  ADDITIONAL_ITEMS_KEY,
  ADDITIONAL_PROPERTIES_KEY,
  PROPERTY_NAMES_KEY,
  CONTAINS_KEY,
  IF_KEY,
  THEN_KEY,
  ELSE_KEY,
  NOT_KEY
];
var SET_OF_SUB_SCHEMAS = new Set(SUB_SCHEMAS);
var SCHEMA_KEYS = [
  ...RECORDS_OF_SUB_SCHEMAS,
  ...ARRAYS_OF_SUB_SCHEMAS,
  ...SUB_SCHEMAS
];
function isSchema(schemaDef) {
  return typeof schemaDef === "object";
}
function isSchemaWithProperties(schema) {
  return schema.properties !== void 0;
}
function isNormalArrayItems(items) {
  return typeof items === "object" && !Array.isArray(items);
}
function isSubSchemaKey(key) {
  return SET_OF_SUB_SCHEMAS.has(key);
}
function isSubSchemasArrayKey(key) {
  return SET_OF_ARRAYS_OF_SUB_SCHEMAS.has(key);
}
function isSubSchemasRecordKey(key) {
  return SET_OF_RECORDS_OF_SUB_SCHEMAS.has(key);
}

// node_modules/@sjsf/form/dist/core/type.js
function typeOfValue(value) {
  if (value === null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "array";
  }
  const type = typeof value;
  switch (type) {
    case "boolean":
    // TODO: Integer type inference ?
    case "number":
    case "object":
    case "string":
      return type;
    default:
      throw new Error(`Unsupported schema type: ${type}`);
  }
}
function typeOfSchema(schema) {
  if (schema.type) {
    return schema.type;
  }
  if (schema.const !== void 0) {
    return typeOfValue(schema.const);
  }
  if (schema.properties || schema.additionalProperties || schema.propertyNames || schema.patternProperties) {
    return "object";
  }
  if (Array.isArray(schema.enum) && schema.enum.length > 0) {
    return Array.from(new Set(schema.enum.map(typeOfValue)));
  }
  const alt = schema.allOf ?? schema.anyOf ?? schema.oneOf;
  if (alt) {
    let types = [];
    for (let i = 0; i < alt.length; i++) {
      const item = alt[i];
      if (!isSchema(item)) {
        continue;
      }
      types = types.concat(typeOfSchema(item));
    }
    return Array.from(new Set(types));
  }
  return "null";
}
function isNullableSchemaType(type) {
  return type === "null" || Array.isArray(type) && type.includes("null");
}
function isSchemaNullable(schema) {
  return isNullableSchemaType(typeOfSchema(schema));
}
function pickSchemaType(types) {
  if (types.length === 0) {
    throw new Error(`Unsupported schema types: empty type array`);
  }
  const first = types[0];
  if (types.length === 1) {
    return first;
  }
  if (first === "null") {
    return types[1];
  }
  return first;
}
var getSimpleSchemaType = (schema) => {
  const type = typeOfSchema(schema);
  return Array.isArray(type) ? pickSchemaType(type) : type;
};
function isPrimitiveSchemaType(type) {
  return type === "boolean" || type === "integer" || type === "number" || type === "string" || type === "null";
}
function isArrayOrObjectSchemaType(type) {
  return type === "array" || type === "object";
}

// node_modules/@sjsf/form/dist/lib/array.js
var array = (count, factory) => Array.from(new Array(count), (_, i) => factory(i));

// node_modules/@sjsf/form/dist/core/definitions.js
var import_jsonpointer = __toESM(require_jsonpointer(), 1);

// node_modules/@sjsf/form/dist/lib/types.js
function isNil(v) {
  return v === void 0 || v === null;
}

// node_modules/@sjsf/form/dist/lib/object.js
function isObject(value) {
  return typeof value === "object" && value !== null;
}
function isRecord(value) {
  return isObject(value) && !Array.isArray(value);
}

// node_modules/@sjsf/form/dist/core/value.js
function isSchemaObjectValue(value) {
  return isRecord(value);
}
function isSchemaArrayValue(value) {
  return Array.isArray(value);
}
function isSchemaValueEmpty(value) {
  if (!isObject(value)) {
    return true;
  }
  if (Array.isArray(value)) {
    return value.length === 0;
  }
  return Object.keys(value).length === 0;
}

// node_modules/@sjsf/form/dist/core/merge.js
function mergeRecords(left, right, merge) {
  const target = Object.assign({}, left);
  for (const [key, value] of Object.entries(right)) {
    if (left[key] === void 0) {
      target[key] = value;
      continue;
    }
    target[key] = merge(left[key], value);
  }
  return target;
}
function mergeArrays(left, right, { merge, unique } = {}) {
  let merged;
  if (merge) {
    const [minArr, maxArr] = left.length <= right.length ? [left, right] : [right, left];
    merged = new Array(maxArr.length);
    for (let i = 0; i < minArr.length; i++) {
      merged[i] = merge(left[i], right[i]);
    }
    for (let i = minArr.length; i < maxArr.length; i++) {
      merged[i] = maxArr[i];
    }
  } else {
    merged = left.concat(right);
  }
  return unique ? Array.from(new Set(merged)) : merged;
}
function mergeSchemaDefinitions(left, right, options) {
  if (typeof left === "boolean" || typeof right === "boolean") {
    return right;
  }
  return mergeSchemas(left, right, options);
}
function mergeSchemaDependencies(left, right, options) {
  if (Array.isArray(left) || Array.isArray(right)) {
    return right;
  }
  return mergeSchemaDefinitions(left, right, options);
}
function mergeSchemas(left, right, options = {}) {
  const merged = Object.assign({}, left, right);
  for (const key of RECORDS_OF_SUB_SCHEMAS) {
    if (!(key in merged) || key === DEPENDENCIES_KEY) {
      continue;
    }
    const l = left[key];
    const r = right[key];
    if (l && r) {
      merged[key] = mergeRecords(l, r, (l2, r2) => mergeSchemaDefinitions(l2, r2, options));
    }
  }
  if (left[ITEMS_KEY] && right[ITEMS_KEY]) {
    merged[ITEMS_KEY] = isSchemaObjectValue(left[ITEMS_KEY]) && isSchemaObjectValue(right[ITEMS_KEY]) ? mergeSchemas(left[ITEMS_KEY], right[ITEMS_KEY], options) : right[ITEMS_KEY];
  }
  if (left[DEPENDENCIES_KEY] && right[DEPENDENCIES_KEY]) {
    merged[DEPENDENCIES_KEY] = mergeRecords(left[DEPENDENCIES_KEY], right[DEPENDENCIES_KEY], (l, r) => mergeSchemaDependencies(l, r, options));
  }
  for (const key of SUB_SCHEMAS) {
    if (!(key in merged) || key === ITEMS_KEY) {
      continue;
    }
    const l = left[key];
    const r = right[key];
    if (l && r) {
      merged[key] = mergeSchemaDefinitions(l, r, options);
    }
  }
  for (const key of ARRAYS_OF_SUB_SCHEMAS) {
    if (!(key in merged) || key === ITEMS_KEY) {
      continue;
    }
    const l = left[key];
    const r = right[key];
    if (l && r) {
      merged[key] = mergeArrays(l, r, {
        merge: options.arraySubSchemasMergeType === "override" ? (l2, r2) => mergeSchemaDefinitions(l2, r2, options) : void 0
      });
    }
  }
  if (left[REQUIRED_KEY] && right[REQUIRED_KEY]) {
    merged[REQUIRED_KEY] = mergeArrays(left[REQUIRED_KEY], right[REQUIRED_KEY], { unique: true });
  }
  return merged;
}
function mergeDefaultsWithFormData(defaults, formData, mergeExtraArrayDefaults = false, defaultsSupersedesUndefined = false, overrideFormDataWithDefaults = false) {
  if (Array.isArray(formData)) {
    const defaultsArray = Array.isArray(defaults) ? defaults : [];
    const overrideArray = overrideFormDataWithDefaults ? defaultsArray : formData;
    const overrideOppositeArray = overrideFormDataWithDefaults ? formData : defaultsArray;
    const mapped = overrideArray.map((value, idx) => {
      if (overrideOppositeArray[idx] !== void 0) {
        return mergeDefaultsWithFormData(defaultsArray[idx], formData[idx], mergeExtraArrayDefaults, defaultsSupersedesUndefined, overrideFormDataWithDefaults);
      }
      return value;
    });
    if ((mergeExtraArrayDefaults || overrideFormDataWithDefaults) && mapped.length < overrideOppositeArray.length) {
      mapped.push(...overrideOppositeArray.slice(mapped.length));
    }
    return mapped;
  }
  if (isSchemaObjectValue(formData)) {
    const acc = Object.assign({}, defaults);
    const defaultsObject = isSchemaObjectValue(defaults) ? defaults : {};
    for (const [key, value] of Object.entries(formData)) {
      const keyExistsInDefaults = key in defaultsObject;
      const keyDefault = defaultsObject[key];
      if (isSchemaObjectValue(keyDefault) && isSchemaObjectValue(value) && !Object.values(keyDefault).some(isSchemaObjectValue)) {
        acc[key] = {
          ...keyDefault,
          ...value
        };
        continue;
      }
      acc[key] = mergeDefaultsWithFormData(
        defaultsObject[key],
        value,
        mergeExtraArrayDefaults,
        defaultsSupersedesUndefined,
        // overrideFormDataWithDefaults can be true only when the key value exists in defaults
        // Or if the key value doesn't exist in formData
        // CHANGED: key is always in form data, maybe this condition should be value === undefined
        // overrideFormDataWithDefaults &&
        //   (keyExistsInDefaults || !keyExistsInFormData)
        overrideFormDataWithDefaults && keyExistsInDefaults
      );
    }
    return acc;
  }
  if (defaultsSupersedesUndefined && (!isNil(defaults) && isNil(formData) || typeof formData === "number" && isNaN(formData)) || overrideFormDataWithDefaults && !isNil(formData)) {
    return defaults;
  }
  return formData;
}
function mergeSchemaObjects(obj1, obj2, concatArrays = false) {
  const acc = Object.assign({}, obj1);
  for (const [key, right] of Object.entries(obj2)) {
    const left = obj1 ? obj1[key] : {};
    if (isSchemaObjectValue(left) && isSchemaObjectValue(right)) {
      acc[key] = mergeSchemaObjects(left, right, concatArrays);
    } else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {
      acc[key] = left.concat(concatArrays === "preventDuplicates" ? right.filter((v) => !left.includes(v)) : right);
    } else {
      acc[key] = right;
    }
  }
  return acc;
}

// node_modules/@sjsf/form/dist/core/definitions.js
function resolveRef(ref, rootSchema) {
  if (!ref.startsWith("#")) {
    throw new Error(`Invalid reference: ${ref}, must start with #`);
  }
  const schemaDef = import_jsonpointer.default.get(rootSchema, decodeURIComponent(ref.substring(1)));
  if (schemaDef === void 0) {
    throw new Error(`Could not find a definition for ${ref}.`);
  }
  return schemaDef;
}
function findSchemaDefinition(ref, rootSchema, stack = /* @__PURE__ */ new Set()) {
  const current = resolveRef(ref, rootSchema);
  if (!isSchema(current)) {
    throw new Error(`Definition for ${ref} should be a schema (object)`);
  }
  const nextRef = current[REF_KEY];
  if (nextRef) {
    if (stack.has(nextRef)) {
      if (stack.size === 1) {
        throw new Error(`Definition for ${ref} is a circular reference`);
      }
      const refs = Array.from(stack);
      const firstRef = refs[0];
      refs.push(ref, firstRef);
      throw new Error(`Definition for ${firstRef} contains a circular reference through ${refs.join(" -> ")}`);
    }
    const subSchema = findSchemaDefinition(nextRef, rootSchema, new Set(stack).add(ref));
    if (Object.keys(current).length < 2) {
      return subSchema;
    }
    const { [REF_KEY]: _, ...currentSchema } = current;
    return mergeSchemas(currentSchema, subSchema);
  }
  return current;
}

// node_modules/@sjsf/form/dist/core/discriminator.js
function getDiscriminatorFieldFromSchema(schema) {
  return schema.discriminator?.propertyName;
}
function getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField) {
  if (discriminatorField && isSchemaObjectValue(formData)) {
    const value = formData[discriminatorField];
    if (value === void 0) {
      return;
    }
    for (let i = 0; i < options.length; i++) {
      const option = options[i];
      const discriminator = option.properties?.[discriminatorField] ?? {};
      if (discriminator === true) {
        return i;
      }
      if (discriminator === false || discriminator.type === "object" || discriminator.type === "array") {
        continue;
      }
      if (discriminator.const === value) {
        return i;
      }
      if (discriminator.enum?.includes(value)) {
        return i;
      }
    }
  }
  return;
}

// node_modules/@sjsf/form/dist/lib/memoize.js
function memoize(cache, func) {
  return (arg) => {
    if (cache.has(arg)) {
      return cache.get(arg);
    }
    let ret = func(arg);
    cache.set(arg, ret);
    return ret;
  };
}
var weakMemoize = memoize;

// node_modules/@sjsf/form/dist/core/matching.js
function createAugmentSchema({ required, ...rest }) {
  return {
    allOf: [
      rest,
      {
        anyOf: Object.keys(rest.properties).map((key) => ({
          required: [key]
        }))
      }
    ]
  };
}
var AUGMENTED_SCHEMAS_CACHE = /* @__PURE__ */ new WeakMap();
var memoizedAugmentSchema = weakMemoize(AUGMENTED_SCHEMAS_CACHE, createAugmentSchema);
function isOptionMatching(option, validator, formData, rootSchema, discriminatorField, discriminatorFormData) {
  if (!isSchemaWithProperties(option)) {
    return validator.isValid(option, rootSchema, formData);
  }
  const discriminator = discriminatorField !== void 0 ? option.properties[discriminatorField] : void 0;
  if (discriminator !== void 0) {
    return validator.isValid(discriminator, rootSchema, discriminatorFormData);
  }
  return validator.isValid(memoizedAugmentSchema(option), rootSchema, formData);
}
function getFirstMatchingOption(validator, formData, options, rootSchema, discriminatorField) {
  if (formData === void 0) {
    return 0;
  }
  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);
  if (simpleDiscriminatorMatch !== void 0) {
    return simpleDiscriminatorMatch;
  }
  const isDiscriminatorActual = isSchemaObjectValue(formData) && discriminatorField !== void 0;
  for (let i = 0; i < options.length; i++) {
    if (isOptionMatching(options[i], validator, formData, rootSchema, isDiscriminatorActual ? discriminatorField : void 0, isDiscriminatorActual ? formData[discriminatorField] : void 0)) {
      return i;
    }
  }
  return 0;
}
function calculateIndexScore(validator, merger, rootSchema, schema, formData) {
  let totalScore = 0;
  if (schema) {
    const schemaProperties = schema.properties;
    if (schemaProperties && isSchemaObjectValue(formData)) {
      for (const [key, propertySchema] of Object.entries(schemaProperties)) {
        const formValue = formData[key];
        if (typeof propertySchema === "boolean") {
          continue;
        }
        if (propertySchema[REF_KEY] !== void 0) {
          const newSchema = retrieveSchema(validator, merger, propertySchema, rootSchema, formValue);
          totalScore += calculateIndexScore(validator, merger, rootSchema, newSchema, formValue);
          continue;
        }
        const altSchemas = propertySchema.oneOf || propertySchema.anyOf;
        if (altSchemas && formValue) {
          const discriminator = getDiscriminatorFieldFromSchema(propertySchema);
          totalScore += getClosestMatchingOption(validator, merger, rootSchema, formValue, altSchemas.filter(isSchema), -1, discriminator);
          continue;
        }
        if (propertySchema.type === "object") {
          if (isSchemaObjectValue(formValue)) {
            totalScore += 1;
          }
          totalScore += calculateIndexScore(validator, merger, rootSchema, propertySchema, formValue);
          continue;
        }
        if (formValue !== void 0 && propertySchema.type === typeOfValue(formValue)) {
          totalScore += 1;
          const defaultOrConst = propertySchema.default ?? propertySchema.const;
          if (defaultOrConst !== void 0) {
            totalScore += formValue === defaultOrConst ? 1 : -1;
          }
          continue;
        }
      }
    } else if (formData !== void 0 && typeof schema.type === "string" && schema.type === typeOfValue(formData)) {
      totalScore += 1;
    }
  }
  return totalScore;
}
function getClosestMatchingOption(validator, merger, rootSchema, formData, options, selectedOption = -1, discriminatorField) {
  if (options.length === 0) {
    return selectedOption;
  }
  const resolvedOptions = options.map((option) => {
    return resolveAllReferences(option, rootSchema);
  });
  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);
  if (typeof simpleDiscriminatorMatch === "number") {
    return simpleDiscriminatorMatch;
  }
  const allValidIndexes = [];
  if (formData !== void 0) {
    const canDiscriminatorBeApplied = isSchemaObjectValue(formData) && discriminatorField !== void 0;
    for (let i = 0; i < resolvedOptions.length; i++) {
      if (isOptionMatching(resolvedOptions[i], validator, formData, rootSchema, canDiscriminatorBeApplied ? discriminatorField : void 0, canDiscriminatorBeApplied ? formData[discriminatorField] : void 0)) {
        allValidIndexes.push(i);
      }
    }
    if (allValidIndexes.length === 1) {
      return allValidIndexes[0];
    }
  }
  if (allValidIndexes.length === 0) {
    for (let i = 0; i < resolvedOptions.length; i++) {
      allValidIndexes.push(i);
    }
  }
  const scoreCount = /* @__PURE__ */ new Set();
  let bestScore = 0;
  let bestIndex = selectedOption;
  for (let i = 0; i < allValidIndexes.length; i++) {
    const index = allValidIndexes[i];
    const option = resolvedOptions[index];
    const score = calculateIndexScore(validator, merger, rootSchema, option, formData);
    scoreCount.add(score);
    if (score > bestScore) {
      bestScore = score;
      bestIndex = index;
    }
  }
  if (allValidIndexes.length > 1 && scoreCount.size === 1 && selectedOption >= 0) {
    return selectedOption;
  }
  return bestIndex;
}

// node_modules/@sjsf/form/dist/core/deep-equal.js
function isSchemaValueDeepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (isObject(a) && isObject(b)) {
    if (Array.isArray(a)) {
      if (!Array.isArray(b)) {
        return false;
      }
      const { length } = a;
      if (length !== b.length) {
        return false;
      }
      for (let i = length; i-- !== 0; ) {
        if (!isSchemaValueDeepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    if (Array.isArray(b)) {
      return false;
    }
    const aKeys = Object.keys(a);
    let key;
    for (let i = aKeys.length; i-- !== 0; ) {
      key = aKeys[i];
      if (!isSchemaValueDeepEqual(a[key], b[key])) {
        return false;
      }
    }
    return Object.keys(b).length === aKeys.length;
  }
  return a !== a && b !== b;
}
var isSchemaDeepEqual = isSchemaValueDeepEqual;

// node_modules/@sjsf/form/dist/core/resolve.js
function retrieveSchema(validator, merger, schema, rootSchema = {}, formData) {
  return retrieveSchemaInternal(validator, merger, schema, rootSchema, formData)[0];
}
function resolveAllReferences(schema, rootSchema, stack = /* @__PURE__ */ new Set()) {
  let resolvedSchema = schema;
  const ref = resolvedSchema[REF_KEY];
  if (ref) {
    if (stack.has(ref)) {
      return resolvedSchema;
    }
    stack.add(ref);
    const { [REF_KEY]: _, ...resolvedSchemaWithoutRef } = resolvedSchema;
    return resolveAllReferences(mergeSchemas(findSchemaDefinition(ref, rootSchema), resolvedSchemaWithoutRef), rootSchema, stack);
  }
  const properties = resolvedSchema[PROPERTIES_KEY];
  if (properties) {
    const resolvedProps = /* @__PURE__ */ new Map();
    const stackCopies = [];
    for (const [key, value] of Object.entries(properties)) {
      if (typeof value === "boolean") {
        resolvedProps.set(key, value);
      } else {
        const stackCopy = new Set(stack);
        resolvedProps.set(key, resolveAllReferences(value, rootSchema, stackCopy));
        stackCopies.push(stackCopy);
      }
    }
    const stackSize = stack.size;
    for (const copy of stackCopies) {
      if (copy.size === stackSize) {
        continue;
      }
      copy.forEach(stack.add, stack);
    }
    resolvedSchema = {
      ...resolvedSchema,
      [PROPERTIES_KEY]: Object.fromEntries(resolvedProps)
    };
  }
  const items = resolvedSchema[ITEMS_KEY];
  if (items && !Array.isArray(items) && typeof items !== "boolean") {
    resolvedSchema = {
      ...resolvedSchema,
      items: resolveAllReferences(items, rootSchema, stack)
    };
  }
  return resolvedSchema;
}
function resolveReference(validator, merger, schema, rootSchema, expandAllBranches, stack, formData) {
  const resolvedSchema = resolveAllReferences(schema, rootSchema, stack);
  if (!isSchemaDeepEqual(schema, resolvedSchema)) {
    return retrieveSchemaInternal(validator, merger, resolvedSchema, rootSchema, formData, expandAllBranches, stack);
  }
  return [schema];
}
function retrieveSchemaInternal(validator, merger, schema, rootSchema, formData, expandAllBranches = false, stack = /* @__PURE__ */ new Set()) {
  const resolvedSchemas = resolveSchema(validator, merger, schema, rootSchema, expandAllBranches, stack, formData);
  return resolvedSchemas.flatMap((s) => {
    let resolvedSchema = s;
    if (IF_KEY in resolvedSchema) {
      return resolveCondition(validator, merger, resolvedSchema, rootSchema, expandAllBranches, stack, formData);
    }
    const resolvedAllOf = resolvedSchema.allOf;
    if (resolvedAllOf) {
      if (expandAllBranches) {
        const { allOf: _, ...restOfSchema } = resolvedSchema;
        const schemas = [];
        for (let i = 0; i < resolvedAllOf.length; i++) {
          const schema2 = resolvedAllOf[i];
          if (typeof schema2 === "boolean") {
            continue;
          }
          schemas.push(schema2);
        }
        schemas.push(restOfSchema);
        return schemas;
      }
      try {
        const withContainsSchemas = [];
        const withoutContainsSchemas = [];
        resolvedSchema.allOf?.forEach((s2) => {
          if (isSchema(s2) && s2.contains) {
            withContainsSchemas.push(s2);
          } else {
            withoutContainsSchemas.push(s2);
          }
        });
        if (withContainsSchemas.length) {
          resolvedSchema = { ...resolvedSchema, allOf: withoutContainsSchemas };
        }
        resolvedSchema = merger.mergeAllOf(resolvedSchema);
        if (withContainsSchemas.length) {
          resolvedSchema.allOf = withContainsSchemas;
        }
      } catch (e) {
        console.warn("could not merge subschemas in allOf:\n", e);
        const { allOf, ...resolvedSchemaWithoutAllOf } = resolvedSchema;
        return resolvedSchemaWithoutAllOf;
      }
    }
    const patternProperties = resolvedSchema.patternProperties;
    const hasPatternProperties = patternProperties !== void 0;
    const hasAdditionalProperties = resolvedSchema.additionalProperties !== void 0 && resolvedSchema.additionalProperties !== false;
    if (!hasPatternProperties && !hasAdditionalProperties) {
      return resolvedSchema;
    }
    const properties = { ...resolvedSchema.properties };
    const formDataIsSchemaObjectValue = isSchemaObjectValue(formData);
    if (hasPatternProperties) {
      for (const key of Object.keys(properties)) {
        const matchingProperties = getMatchingPatternProperties(patternProperties, key);
        if (matchingProperties.length > 0) {
          matchingProperties.push(properties[key]);
          properties[key] = retrieveSchema(validator, merger, { allOf: matchingProperties }, rootSchema, formDataIsSchemaObjectValue ? formData[key] : void 0);
        }
      }
    }
    return stubExistingAdditionalProperties(validator, merger, {
      ...resolvedSchema,
      properties
    }, rootSchema, formDataIsSchemaObjectValue ? formData : void 0);
  });
}
function resolveCondition(validator, merger, schema, rootSchema, expandAllBranches, stack, formData) {
  const { if: expression, then, else: otherwise, ...resolvedSchemaLessConditional } = schema;
  const conditionValue = expression !== void 0 && validator.isValid(expression, rootSchema, formData || {});
  let resolvedSchemas = [resolvedSchemaLessConditional];
  let schemas = [];
  if (expandAllBranches) {
    if (then && typeof then !== "boolean") {
      schemas = schemas.concat(retrieveSchemaInternal(validator, merger, then, rootSchema, formData, expandAllBranches, stack));
    }
    if (otherwise && typeof otherwise !== "boolean") {
      schemas = schemas.concat(retrieveSchemaInternal(validator, merger, otherwise, rootSchema, formData, expandAllBranches, stack));
    }
  } else {
    const conditionalSchema = conditionValue ? then : otherwise;
    if (conditionalSchema && typeof conditionalSchema !== "boolean") {
      schemas = schemas.concat(retrieveSchemaInternal(validator, merger, conditionalSchema, rootSchema, formData, expandAllBranches, stack));
    }
  }
  if (schemas.length) {
    resolvedSchemas = schemas.map((s) => mergeSchemas(resolvedSchemaLessConditional, s));
  }
  return resolvedSchemas.flatMap((s) => retrieveSchemaInternal(validator, merger, s, rootSchema, formData, expandAllBranches, stack));
}
function stubExistingAdditionalProperties(validator, merger, schema, rootSchema, formData) {
  const { additionalProperties, patternProperties } = schema;
  const isAdditionalProperties = typeof additionalProperties !== "boolean" && additionalProperties;
  const isArbitraryAdditionalProperty = additionalProperties === true || isAdditionalProperties && Object.keys(additionalProperties).length === 0;
  function getAdditionalPropertySchemaShallowClone(key) {
    if (patternProperties !== void 0) {
      const matchingProperties = getMatchingPatternProperties(patternProperties, key);
      if (matchingProperties.length > 0) {
        return {
          ...retrieveSchema(validator, merger, { allOf: matchingProperties }, rootSchema, formData?.[key])
        };
      }
    }
    if (isAdditionalProperties) {
      if (REF_KEY in additionalProperties) {
        return {
          ...retrieveSchema(validator, merger, { $ref: additionalProperties[REF_KEY] }, rootSchema, formData)
        };
      }
      if ("type" in additionalProperties) {
        return { ...additionalProperties };
      }
      if (ANY_OF_KEY in additionalProperties || ONE_OF_KEY in additionalProperties) {
        return {
          type: "object",
          ...additionalProperties
        };
      }
    }
    if (isArbitraryAdditionalProperty) {
      const value = formData?.[key];
      if (value !== void 0) {
        return { type: typeOfValue(value) };
      }
    }
    return { type: "null" };
  }
  if (formData !== void 0) {
    for (const key of Object.keys(formData)) {
      if (key in schema.properties) {
        continue;
      }
      const propertySchema = getAdditionalPropertySchemaShallowClone(key);
      propertySchema[ADDITIONAL_PROPERTY_FLAG] = true;
      schema.properties[key] = propertySchema;
    }
  }
  return schema;
}
function resolveSchema(validator, merger, schema, rootSchema, expandAllBranches, stack, formData) {
  const updatedSchemas = resolveReference(validator, merger, schema, rootSchema, expandAllBranches, stack, formData);
  if (updatedSchemas.length > 1 || updatedSchemas[0] !== schema) {
    return updatedSchemas;
  }
  if (DEPENDENCIES_KEY in schema) {
    const resolvedSchemas = resolveDependencies(validator, merger, schema, rootSchema, expandAllBranches, stack, formData);
    return resolvedSchemas.flatMap((s) => {
      return retrieveSchemaInternal(validator, merger, s, rootSchema, formData, expandAllBranches, stack);
    });
  }
  if (ALL_OF_KEY in schema && Array.isArray(schema.allOf)) {
    const allOfSchemaElements = schema.allOf.filter((s) => typeof s !== "boolean").map((allOfSubSchema) => retrieveSchemaInternal(validator, merger, allOfSubSchema, rootSchema, formData, expandAllBranches, stack));
    const allPermutations = getAllPermutationsOfXxxOf(allOfSchemaElements);
    return allPermutations.map((permutation) => ({
      ...schema,
      allOf: permutation
    }));
  }
  return [schema];
}
function resolveDependencies(validator, merger, schema, rootSchema, expandAllBranches, stack, formData) {
  const { dependencies, ...remainingSchema } = schema;
  const resolvedSchemas = resolveAnyOrOneOfSchemas(validator, remainingSchema, rootSchema, expandAllBranches, formData);
  return resolvedSchemas.flatMap((resolvedSchema) => processDependencies(validator, merger, dependencies, resolvedSchema, rootSchema, expandAllBranches, stack, formData));
}
function resolveAnyOrOneOfSchemas(validator, schema, rootSchema, expandAllBranches, rawFormData) {
  let anyOrOneOf;
  const { oneOf, anyOf, ...remaining } = schema;
  if (Array.isArray(oneOf)) {
    anyOrOneOf = oneOf;
  } else if (Array.isArray(anyOf)) {
    anyOrOneOf = anyOf;
  }
  if (anyOrOneOf) {
    const formData = rawFormData === void 0 && expandAllBranches ? {} : rawFormData;
    const discriminator = getDiscriminatorFieldFromSchema(schema);
    anyOrOneOf = anyOrOneOf.map((s) => {
      return resolveAllReferences(s, rootSchema);
    });
    const option = getFirstMatchingOption(validator, formData, anyOrOneOf, rootSchema, discriminator);
    if (expandAllBranches) {
      return anyOrOneOf.map((item) => mergeSchemas(remaining, item));
    }
    schema = mergeSchemas(remaining, anyOrOneOf[option]);
  }
  return [schema];
}
function processDependencies(validator, merger, dependencies, resolvedSchema, rootSchema, expandAllBranches, stack, formData) {
  let schemas = [resolvedSchema];
  for (const dependencyKey in dependencies) {
    if (!expandAllBranches && (!isSchemaObjectValue(formData) || formData[dependencyKey] === void 0)) {
      continue;
    }
    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {
      continue;
    }
    const { [dependencyKey]: dependencyValue, ...remainingDependencies } = dependencies;
    if (Array.isArray(dependencyValue)) {
      schemas[0] = mergeSchemas(resolvedSchema, { required: dependencyValue });
    } else if (typeof dependencyValue !== "boolean" && dependencyValue) {
      schemas = withDependentSchema(validator, merger, resolvedSchema, rootSchema, dependencyKey, dependencyValue, expandAllBranches, stack, formData);
    }
    return schemas.flatMap((schema) => processDependencies(validator, merger, remainingDependencies, schema, rootSchema, expandAllBranches, stack, formData));
  }
  return schemas;
}
function withDependentSchema(validator, merger, schema, rootSchema, dependencyKey, dependencyValue, expandAllBranches, stack, formData) {
  const dependentSchemas = retrieveSchemaInternal(validator, merger, dependencyValue, rootSchema, formData, expandAllBranches, stack);
  return dependentSchemas.flatMap((dependent) => {
    const { oneOf, ...dependentSchema } = dependent;
    const mergedSchema = mergeSchemas(schema, dependentSchema);
    if (oneOf === void 0) {
      return mergedSchema;
    }
    const resolvedOneOfs = oneOf.map((subschema) => {
      if (typeof subschema === "boolean" || !(REF_KEY in subschema)) {
        return [subschema];
      }
      return resolveReference(validator, merger, subschema, rootSchema, expandAllBranches, stack, formData);
    });
    const allPermutations = getAllPermutationsOfXxxOf(resolvedOneOfs);
    return allPermutations.flatMap((resolvedOneOf) => withExactlyOneSubSchema(validator, merger, mergedSchema, rootSchema, dependencyKey, resolvedOneOf, expandAllBranches, stack, formData));
  });
}
function withExactlyOneSubSchema(validator, merger, schema, rootSchema, dependencyKey, oneOf, expandAllBranches, stack, formData) {
  const validSubSchemas = oneOf.filter((subschema) => {
    if (typeof subschema === "boolean" || !subschema || !subschema.properties) {
      return false;
    }
    const { [dependencyKey]: conditionPropertySchema } = subschema.properties;
    if (conditionPropertySchema) {
      const conditionSchema = {
        type: "object",
        properties: {
          [dependencyKey]: conditionPropertySchema
        }
      };
      return validator.isValid(conditionSchema, rootSchema, formData) || expandAllBranches;
    }
    return false;
  });
  if (!expandAllBranches && validSubSchemas.length !== 1) {
    console.warn("ignoring oneOf in dependencies because there isn't exactly one subschema that is valid");
    return [schema];
  }
  return validSubSchemas.flatMap((s) => {
    const subschema = s;
    const { [dependencyKey]: _, ...dependentSubSchema } = subschema.properties;
    const dependentSchema = { ...subschema, properties: dependentSubSchema };
    const schemas = retrieveSchemaInternal(validator, merger, dependentSchema, rootSchema, formData, expandAllBranches, stack);
    return schemas.map((s2) => mergeSchemas(schema, s2));
  });
}
function getAllPermutationsOfXxxOf(listOfLists) {
  const allPermutations = listOfLists.reduce(
    (permutations, list) => {
      if (list.length > 1) {
        return list.flatMap((element) => array(permutations.length, (i) => [...permutations[i]].concat(element)));
      }
      permutations.forEach((permutation) => permutation.push(list[0]));
      return permutations;
    },
    [[]]
    // Start with an empty list
  );
  return allPermutations;
}
function getMatchingPatternProperties(patternProperties, key) {
  const schemas = [];
  for (const [p, d] of Object.entries(patternProperties)) {
    if (new RegExp(p).test(key)) {
      schemas.push(d);
    }
  }
  return schemas;
}

// node_modules/@sjsf/form/dist/core/constant-schema.js
function isSchemaOfConstantValue(schema) {
  return schema.const !== void 0 || Array.isArray(schema.enum) && schema.enum.length === 1;
}
function getSchemaConstantValue(schema) {
  const enumValues = schema.enum;
  if (Array.isArray(enumValues) && enumValues.length === 1) {
    return enumValues[0];
  }
  const constant = schema.const;
  if (constant !== void 0) {
    return constant;
  }
  throw new Error("schema cannot be inferred as a constant");
}

// node_modules/@sjsf/form/dist/core/is-select.js
function isSelect(validator, merger, theSchema, rootSchema) {
  const schema = retrieveSchema(validator, merger, theSchema, rootSchema);
  if (Array.isArray(schema.enum)) {
    return true;
  }
  const altSchemas = schema.oneOf || schema.anyOf;
  if (Array.isArray(altSchemas)) {
    return altSchemas.every((altSchemas2) => typeof altSchemas2 !== "boolean" && isSchemaOfConstantValue(altSchemas2));
  }
  return false;
}
function getSelectOptionValues({ enum: enumValues, oneOf, anyOf }) {
  if (enumValues !== void 0) {
    return enumValues;
  }
  const altSchema = oneOf ?? anyOf;
  if (altSchema === void 0) {
    return void 0;
  }
  return altSchema.map((schemaDef, i) => {
    if (!isSchema(schemaDef)) {
      throw new Error(`Invalid enum definition in altSchema.${i}`);
    }
    return getSchemaConstantValue(schemaDef);
  });
}
function isMultiSelect(validator, merger, { items, uniqueItems }, rootSchema) {
  return uniqueItems === true && isSchemaObjectValue(items) && isSelect(validator, merger, items, rootSchema);
}

// node_modules/@sjsf/form/dist/core/is-fixed-items.js
function isFixedItems(schema) {
  const { items } = schema;
  return Array.isArray(items) && items.length > 0 && items.every(isSchemaObjectValue);
}

// node_modules/@sjsf/form/dist/core/default-state.js
function getDefaultValueForType(type) {
  switch (type) {
    case "array":
      return [];
    case "object":
      return {};
    case "boolean":
      return false;
    case "integer":
    case "number":
      return 0;
    case "string":
      return "";
    case "null":
      return null;
    default:
      const n = type;
      throw new Error(`Unsupported schema type: ${n}`);
  }
}
function getDefaultFormState(validator, merger, theSchema, formData = void 0, rootSchema = {}, includeUndefinedValues = false, experimental_defaultFormStateBehavior = {}) {
  const schema = retrieveSchema(validator, merger, theSchema, rootSchema, formData);
  const defaults = computeDefaults(validator, merger, schema, {
    rootSchema,
    includeUndefinedValues,
    experimental_defaultFormStateBehavior,
    rawFormData: formData,
    parentDefaults: void 0,
    required: false,
    isSchemaRoot: true,
    stack: /* @__PURE__ */ new Set(),
    shouldMergeDefaultsIntoFormData: true
  });
  if (schema.type !== "object" && isSchemaObjectValue(schema.default) && // CHANGED: Added those conditions for typesafety, while original intentions is unknown
  (defaults === void 0 || typeof defaults === "object") && (formData === void 0 || typeof formData === "object")) {
    return {
      ...defaults,
      ...formData
    };
  }
  if (isSchemaObjectValue(formData) || Array.isArray(formData)) {
    const { mergeDefaultsIntoFormData } = experimental_defaultFormStateBehavior || {};
    const defaultSupersedesUndefined = mergeDefaultsIntoFormData === "useDefaultIfFormDataUndefined";
    const result = mergeDefaultsWithFormData(
      defaults,
      formData,
      true,
      // set to true to add any additional default array entries.
      defaultSupersedesUndefined,
      true
      // set to true to override formData with defaults if they exist.
    );
    return result;
  }
  return defaults;
}
function computeDefaults(validator, merger, rawSchema, computeDefaultsProps) {
  const { parentDefaults, rawFormData, rootSchema, includeUndefinedValues, stack, experimental_defaultFormStateBehavior, required, isSchemaRoot, shouldMergeDefaultsIntoFormData } = computeDefaultsProps;
  const rawDataIsObject = isSchemaObjectValue(rawFormData);
  const formData = rawDataIsObject ? rawFormData : {};
  const schema = isSchemaObjectValue(rawSchema) ? rawSchema : {};
  let defaults = parentDefaults;
  let schemaToCompute = null;
  let schemaToComputeFormData = formData;
  let experimentalBehaviorToCompute = experimental_defaultFormStateBehavior;
  let nextStack = stack;
  const { default: schemaDefault, $ref: schemaRef, oneOf: schemaOneOf, anyOf: schemaAnyOf, allOf: schemaAllOf } = schema;
  if (isSchemaOfConstantValue(schema) && experimental_defaultFormStateBehavior.constAsDefaults !== "never") {
    defaults = schema.const ?? schema.enum?.[0];
  } else if (isSchemaObjectValue(defaults) && isSchemaObjectValue(schemaDefault)) {
    defaults = mergeSchemaObjects(defaults, schemaDefault);
  } else if (schemaDefault !== void 0 && schemaOneOf === void 0 && schemaAnyOf === void 0 && schemaRef === void 0) {
    defaults = schemaDefault;
  } else if (schemaRef !== void 0) {
    if (!stack.has(schemaRef)) {
      nextStack = new Set(stack).add(schemaRef);
      schemaToCompute = findSchemaDefinition(schemaRef, rootSchema);
    }
    if (schemaToCompute && defaults === void 0) {
      defaults = schemaDefault;
    }
    if (shouldMergeDefaultsIntoFormData && schemaToCompute && !rawDataIsObject) {
      schemaToComputeFormData = rawFormData;
    }
  } else if (DEPENDENCIES_KEY in schema) {
    const defaultFormData = {
      ...getObjectDefaults(validator, merger, schema, {
        ...computeDefaultsProps,
        rawFormData: formData
      }, defaults),
      ...formData
    };
    const resolvedSchema = resolveDependencies(validator, merger, schema, rootSchema, false, /* @__PURE__ */ new Set(), defaultFormData);
    schemaToCompute = resolvedSchema[0];
  } else if (isFixedItems(schema)) {
    defaults = schema.items.map((itemSchema, idx) => computeDefaults(validator, merger, itemSchema, {
      rootSchema,
      includeUndefinedValues,
      stack,
      experimental_defaultFormStateBehavior,
      parentDefaults: Array.isArray(parentDefaults) ? parentDefaults[idx] : void 0,
      rawFormData: formData,
      required,
      isSchemaRoot: false,
      shouldMergeDefaultsIntoFormData
    }));
  } else if (schemaOneOf !== void 0) {
    const { oneOf: _, ...remaining } = schema;
    if (schemaOneOf.length === 0) {
      return void 0;
    }
    const schemaType = typeOfSchema(schema);
    if ((Array.isArray(schemaType) ? schemaType.every(isPrimitiveSchemaType) : isPrimitiveSchemaType(schemaType)) && experimentalBehaviorToCompute?.constAsDefaults === "skipOneOf") {
      experimentalBehaviorToCompute = {
        ...experimentalBehaviorToCompute,
        constAsDefaults: "never"
      };
    }
    const nextSchema = schemaOneOf[getClosestMatchingOption(validator, merger, rootSchema, rawFormData ?? schemaDefault, schemaOneOf.filter(isSchema), 0, getDiscriminatorFieldFromSchema(schema))];
    if (typeof nextSchema === "boolean") {
      return void 0;
    }
    schemaToCompute = mergeSchemas(remaining, nextSchema);
  } else if (schemaAnyOf !== void 0) {
    const { anyOf: _, ...remaining } = schema;
    if (schemaAnyOf.length === 0) {
      return void 0;
    }
    const nextSchema = schemaAnyOf[getClosestMatchingOption(validator, merger, rootSchema, rawFormData ?? schemaDefault, schemaAnyOf.filter(isSchema), 0, getDiscriminatorFieldFromSchema(schema))];
    if (typeof nextSchema === "boolean") {
      return void 0;
    }
    schemaToCompute = mergeSchemas(remaining, nextSchema);
  }
  if (schemaToCompute) {
    return computeDefaults(validator, merger, schemaToCompute, {
      isSchemaRoot,
      rootSchema,
      includeUndefinedValues,
      stack: nextStack,
      experimental_defaultFormStateBehavior: experimentalBehaviorToCompute,
      parentDefaults: defaults,
      rawFormData: rawFormData ?? schemaToComputeFormData,
      required,
      shouldMergeDefaultsIntoFormData
    });
  }
  if (defaults === void 0) {
    defaults = schema.default;
  }
  let defaultsWithFormData = getDefaultBasedOnSchemaType(validator, merger, schema, computeDefaultsProps, defaults) ?? defaults;
  if (shouldMergeDefaultsIntoFormData) {
    const { arrayMinItems = {} } = experimental_defaultFormStateBehavior || {};
    const { mergeExtraDefaults } = arrayMinItems;
    const matchingFormData = ensureFormDataMatchingSchema(validator, merger, schema, rootSchema, rawFormData, experimental_defaultFormStateBehavior);
    if (!isSchemaObjectValue(rawFormData) || schemaAllOf !== void 0) {
      defaultsWithFormData = mergeDefaultsWithFormData(defaultsWithFormData, matchingFormData, mergeExtraDefaults, true);
    }
  }
  return defaultsWithFormData;
}
function ensureFormDataMatchingSchema(validator, merger, schema, rootSchema, formData, experimental_defaultFormStateBehavior) {
  let validFormData = formData;
  const isSelectField = formData !== void 0 && !isSchemaOfConstantValue(schema) && isSelect(validator, merger, schema, rootSchema);
  if (isSelectField) {
    const selectOptionValues = getSelectOptionValues(schema);
    const isValid = selectOptionValues?.some((v) => isSchemaValueDeepEqual(v, formData));
    validFormData = isValid ? formData : void 0;
  }
  const constTakesPrecedence = schema.const !== void 0 && experimental_defaultFormStateBehavior?.constAsDefaults === "always";
  if (constTakesPrecedence) {
    validFormData = schema.const;
  }
  return validFormData;
}
function maybeAddDefaultToObject(obj, key, computedDefault, includeUndefinedValues, isConst, isSchemaRoot, isParentRequired, requiredFields, experimental_defaultFormStateBehavior) {
  const { emptyObjectFields = "populateAllDefaults" } = experimental_defaultFormStateBehavior;
  if (includeUndefinedValues || isConst) {
    if (computedDefault !== void 0) {
      obj.set(key, computedDefault);
    }
  } else if (emptyObjectFields !== "skipDefaults") {
    const isSelfOrParentRequired = isSchemaRoot ? requiredFields.has(key) : isParentRequired;
    if (isSchemaObjectValue(computedDefault)) {
      if (emptyObjectFields === "skipEmptyDefaults") {
        if (!isSchemaValueEmpty(computedDefault)) {
          obj.set(key, computedDefault);
        }
      } else if ((!isSchemaValueEmpty(computedDefault) || requiredFields.has(key)) && (isSelfOrParentRequired || emptyObjectFields !== "populateRequiredDefaults")) {
        obj.set(key, computedDefault);
      }
    } else if (
      // Store computedDefault if it's a defined primitive (e.g., true) and satisfies certain conditions
      // Condition 1: computedDefault is not undefined
      // Condition 2: If emptyObjectFields is 'populateAllDefaults' or 'skipEmptyDefaults) or if the key is a required field
      computedDefault !== void 0 && (emptyObjectFields === "populateAllDefaults" || emptyObjectFields === "skipEmptyDefaults" || isSelfOrParentRequired && requiredFields.has(key))
    ) {
      obj.set(key, computedDefault);
    }
  }
}
var AdditionalItemsHandling;
(function(AdditionalItemsHandling2) {
  AdditionalItemsHandling2[AdditionalItemsHandling2["Ignore"] = 0] = "Ignore";
  AdditionalItemsHandling2[AdditionalItemsHandling2["Invert"] = 1] = "Invert";
  AdditionalItemsHandling2[AdditionalItemsHandling2["Fallback"] = 2] = "Fallback";
})(AdditionalItemsHandling || (AdditionalItemsHandling = {}));
function getInnerSchemaForArrayItem(schema, additionalItems = AdditionalItemsHandling.Ignore, idx = -1) {
  if (idx >= 0) {
    if (Array.isArray(schema.items) && idx < schema.items.length) {
      const item = schema.items[idx];
      if (typeof item !== "boolean") {
        return item;
      }
    }
  } else if (schema.items && !Array.isArray(schema.items) && typeof schema.items !== "boolean") {
    return schema.items;
  }
  if (additionalItems !== AdditionalItemsHandling.Ignore && isSchemaObjectValue(schema.additionalItems)) {
    return schema.additionalItems;
  }
  return {};
}
function getDefaultBasedOnSchemaType(validator, merger, rawSchema, computeDefaultsProps, defaults) {
  switch (getSimpleSchemaType(rawSchema)) {
    // We need to recurse for object schema inner default values.
    case "object": {
      const { rawFormData } = computeDefaultsProps;
      return getObjectDefaults(validator, merger, rawSchema, {
        ...computeDefaultsProps,
        rawFormData: isSchemaObjectValue(rawFormData) ? rawFormData : {}
      }, defaults);
    }
    case "array": {
      return getArrayDefaults(validator, merger, rawSchema, computeDefaultsProps, Array.isArray(defaults) ? defaults : void 0);
    }
    default:
      return void 0;
  }
}
function getObjectDefaults(validator, merger, schema, { rootSchema, includeUndefinedValues, stack, experimental_defaultFormStateBehavior, required, isSchemaRoot, rawFormData: formData, shouldMergeDefaultsIntoFormData }, defaults) {
  const retrievedSchema = experimental_defaultFormStateBehavior?.allOf === "populateDefaults" && ALL_OF_KEY in schema ? retrieveSchema(validator, merger, schema, rootSchema, formData) : schema;
  const retrievedSchemaRequired = new Set(retrievedSchema.required);
  const parentConstObject = isSchemaObjectValue(retrievedSchema.const) ? retrievedSchema.const : {};
  const objDefaults = /* @__PURE__ */ new Map();
  const schemaProperties = retrievedSchema.properties;
  const defaultsAsObject = isSchemaObjectValue(defaults) ? defaults : void 0;
  const formDataAsObject = isSchemaObjectValue(formData) ? formData : void 0;
  if (schemaProperties !== void 0) {
    for (const [key, value] of Object.entries(schemaProperties)) {
      if (typeof value === "boolean") {
        continue;
      }
      const computedDefault = computeDefaults(validator, merger, value, {
        rootSchema,
        stack,
        experimental_defaultFormStateBehavior,
        includeUndefinedValues: includeUndefinedValues === true,
        parentDefaults: defaultsAsObject?.[key],
        rawFormData: formDataAsObject?.[key],
        required: retrievedSchemaRequired.has(key),
        isSchemaRoot: false,
        shouldMergeDefaultsIntoFormData
      });
      const isConst = (value.const !== void 0 || parentConstObject[key] !== void 0) && experimental_defaultFormStateBehavior.constAsDefaults !== "never";
      maybeAddDefaultToObject(objDefaults, key, computedDefault, includeUndefinedValues, isConst, isSchemaRoot, required, new Set(retrievedSchema.required), experimental_defaultFormStateBehavior);
    }
  }
  const schemaAdditionalProperties = retrievedSchema.additionalProperties;
  if (schemaAdditionalProperties !== void 0) {
    let keys = new Set(isSchemaObjectValue(defaults) ? schemaProperties === void 0 ? Object.keys(defaults) : Object.keys(defaults).filter((key) => !(key in schemaProperties)) : void 0);
    const formDataKeys = Object.keys(formData);
    const formDataRequired = new Set(schemaProperties === void 0 ? formDataKeys : formDataKeys.filter((key) => !(key in schemaProperties)));
    keys = keys.union(formDataRequired);
    const additionalPropertySchema = typeof schemaAdditionalProperties === "boolean" ? {} : schemaAdditionalProperties;
    keys.forEach((key) => {
      const computedDefault = computeDefaults(validator, merger, additionalPropertySchema, {
        rootSchema,
        stack,
        experimental_defaultFormStateBehavior,
        includeUndefinedValues: includeUndefinedValues === true,
        parentDefaults: defaultsAsObject?.[key],
        rawFormData: formDataAsObject?.[key],
        required: retrievedSchemaRequired.has(key),
        isSchemaRoot,
        shouldMergeDefaultsIntoFormData
      });
      maybeAddDefaultToObject(objDefaults, key, computedDefault, includeUndefinedValues, false, isSchemaRoot, required, formDataRequired, {});
    });
  }
  return Object.fromEntries(objDefaults);
}
function getArrayDefaults(validator, merger, schema, { rawFormData, rootSchema, stack, experimental_defaultFormStateBehavior, required, shouldMergeDefaultsIntoFormData }, defaults) {
  const { populate: arrayMinItemsPopulate, mergeExtraDefaults: arrayMergeExtraDefaults, computeSkipPopulate = () => false } = experimental_defaultFormStateBehavior?.arrayMinItems ?? {};
  const neverPopulate = arrayMinItemsPopulate === "never";
  const ignoreMinItemsFlagSet = arrayMinItemsPopulate === "requiredOnly";
  const isPopulateAll = arrayMinItemsPopulate === "all" || !neverPopulate && !ignoreMinItemsFlagSet;
  const isSkipEmptyDefaults = experimental_defaultFormStateBehavior?.emptyObjectFields === "skipEmptyDefaults";
  const emptyDefault = isSkipEmptyDefaults ? void 0 : [];
  if (defaults !== void 0) {
    defaults = defaults.map((item, idx) => {
      const schemaItem = getInnerSchemaForArrayItem(schema, AdditionalItemsHandling.Fallback, idx);
      return computeDefaults(validator, merger, schemaItem, {
        rootSchema,
        stack,
        experimental_defaultFormStateBehavior,
        parentDefaults: item,
        required,
        includeUndefinedValues: false,
        rawFormData: void 0,
        isSchemaRoot: false,
        shouldMergeDefaultsIntoFormData
      });
    });
  }
  if (Array.isArray(rawFormData)) {
    const schemaItem = getInnerSchemaForArrayItem(schema);
    if (neverPopulate) {
      defaults = rawFormData;
    } else {
      const itemDefaults = rawFormData.map((item, idx) => {
        return computeDefaults(validator, merger, schemaItem, {
          rootSchema,
          stack,
          experimental_defaultFormStateBehavior,
          rawFormData: item,
          parentDefaults: defaults?.[idx],
          required,
          includeUndefinedValues: false,
          isSchemaRoot: false,
          shouldMergeDefaultsIntoFormData
        });
      });
      const mergeExtraDefaults = (ignoreMinItemsFlagSet && required || isPopulateAll) && arrayMergeExtraDefaults === true;
      defaults = mergeDefaultsWithFormData(defaults, itemDefaults, mergeExtraDefaults);
    }
  }
  if (schema.const === void 0 || experimental_defaultFormStateBehavior.constAsDefaults === "never") {
    if (neverPopulate) {
      return defaults ?? emptyDefault;
    }
    if (ignoreMinItemsFlagSet && !required) {
      return defaults;
    }
  }
  const defaultsLength = defaults?.length ?? 0;
  if (!schema.minItems || isMultiSelect(validator, merger, schema, rootSchema) || computeSkipPopulate(validator, schema, rootSchema) || schema.minItems <= defaultsLength) {
    return defaults ?? emptyDefault;
  }
  const fillerSchema = getInnerSchemaForArrayItem(schema, AdditionalItemsHandling.Invert);
  const fillerDefault = fillerSchema.default;
  const fillerEntries = new Array(schema.minItems - defaultsLength).fill(computeDefaults(validator, merger, fillerSchema, {
    parentDefaults: fillerDefault,
    rootSchema,
    stack,
    experimental_defaultFormStateBehavior,
    required,
    includeUndefinedValues: false,
    rawFormData: void 0,
    isSchemaRoot: false,
    shouldMergeDefaultsIntoFormData
  }));
  return defaultsLength ? defaults.concat(fillerEntries) : fillerEntries;
}

// node_modules/@sjsf/form/dist/core/order-properties.js
var errorPropList = (arr) => arr.length > 1 ? `properties '${arr.join("', '")}'` : `property '${arr[0]}'`;
function orderProperties(properties, order) {
  const keys = Object.keys(properties);
  if (order === void 0) {
    return keys;
  }
  const orderFiltered = order.filter((prop) => prop === "*" || properties[prop]);
  const orderSet = new Set(orderFiltered);
  const rest = keys.filter((prop) => !orderSet.has(prop));
  const restIndex = orderFiltered.indexOf("*");
  if (restIndex === -1) {
    if (rest.length) {
      throw new Error(`uiSchema order list does not contain ${errorPropList(rest)}`);
    }
    return orderFiltered;
  }
  if (restIndex !== orderFiltered.lastIndexOf("*")) {
    throw new Error("uiSchema order list contains more than one wildcard item");
  }
  orderFiltered.splice(restIndex, 1, ...rest);
  return orderFiltered;
}

// node_modules/@sjsf/form/dist/core/is-additional-property.js
function isAdditionalProperty(properties, property) {
  const propertySchema = properties[property];
  if (typeof propertySchema === "boolean" || !propertySchema) {
    return false;
  }
  return ADDITIONAL_PROPERTY_FLAG in propertySchema;
}

// node_modules/@sjsf/form/dist/core/is-file-schema.js
function isFileSchema({ type, format }) {
  return type === "string" && format === DATA_URL_FORMAT;
}
function isFilesArray(validator, merger, schema, rootSchema) {
  const { items } = schema;
  if (isNormalArrayItems(items)) {
    const itemsSchema = retrieveSchema(validator, merger, items, rootSchema);
    return isFileSchema(itemsSchema);
  }
  return false;
}

// node_modules/@sjsf/form/dist/core/is-expandable.js
function isSchemaExpandable(schema, formData) {
  return (isSchemaObjectValue(schema.additionalProperties) || schema.patternProperties !== void 0) && isSchemaObjectValue(formData) && (schema.maxProperties === void 0 || Object.keys(formData).length < schema.maxProperties);
}

// node_modules/@sjsf/form/dist/core/sanitize-data-for-new-schema.js
var NO_VALUE = Symbol("no Value");
function retrieveIfNeeded(validator, merger, schema, rootSchema, formData) {
  return schema[REF_KEY] !== void 0 ? retrieveSchema(validator, merger, schema, rootSchema, formData) : schema;
}
function sanitizeArrays(newSchema, oldSchemaItems, newSchemaItems, validator, merger, rootSchema, data) {
  const oldSchemaType = oldSchemaItems.type;
  const newSchemaType = newSchemaItems.type;
  if (!oldSchemaType || oldSchemaType === newSchemaType) {
    const maxItems = newSchema.maxItems ?? -1;
    if (newSchemaType === "object") {
      return data.reduce((newValue, aValue) => {
        const itemValue = sanitizeDataForNewSchema(validator, merger, rootSchema, newSchemaItems, oldSchemaItems, aValue);
        if (itemValue !== void 0 && (maxItems < 0 || newValue.length < maxItems)) {
          newValue.push(itemValue);
        }
        return newValue;
      }, []);
    } else {
      return maxItems > 0 && data.length > maxItems ? data.slice(0, maxItems) : data;
    }
  }
  return NO_VALUE;
}
function sanitizeDataForNewSchema(validator, merger, rootSchema, newSchema, oldSchema, data) {
  let newFormData;
  const newSchemaProperties = newSchema.properties;
  const isDataObject = isSchemaObjectValue(data);
  if (newSchemaProperties !== void 0) {
    const removeOldSchemaData = {};
    const oldSchemaProperties = oldSchema.properties;
    if (oldSchemaProperties !== void 0 && isDataObject) {
      Object.keys(oldSchemaProperties).forEach((key) => {
        if (key in data) {
          removeOldSchemaData[key] = void 0;
        }
      });
    }
    const keys = Object.keys(newSchemaProperties);
    const nestedData = {};
    keys.forEach((key) => {
      const formValue = isDataObject ? data[key] : void 0;
      const oldKeyedSchemaDef = oldSchemaProperties?.[key];
      let oldKeyedSchema = typeof oldKeyedSchemaDef === "object" ? oldKeyedSchemaDef : {};
      const newKeyedSchemaDef = newSchemaProperties?.[key];
      let newKeyedSchema = typeof newKeyedSchemaDef === "object" ? newKeyedSchemaDef : {};
      oldKeyedSchema = retrieveIfNeeded(validator, merger, oldKeyedSchema, rootSchema, formValue);
      newKeyedSchema = retrieveIfNeeded(validator, merger, newKeyedSchema, rootSchema, formValue);
      const oldSchemaTypeForKey = oldKeyedSchema.type;
      const newSchemaTypeForKey = newKeyedSchema.type;
      if (!oldSchemaTypeForKey || oldSchemaTypeForKey === newSchemaTypeForKey) {
        if (key in removeOldSchemaData) {
          delete removeOldSchemaData[key];
        }
        if (newSchemaTypeForKey === "object" || newSchemaTypeForKey === "array" && Array.isArray(formValue)) {
          const itemData = sanitizeDataForNewSchema(validator, merger, rootSchema, newKeyedSchema, oldKeyedSchema, formValue);
          if (itemData !== void 0 || newSchemaTypeForKey === "array") {
            nestedData[key] = itemData;
          }
        } else {
          const newOptionDefault = newKeyedSchema.default ?? NO_VALUE;
          const oldOptionDefault = oldKeyedSchema.default ?? NO_VALUE;
          if (newOptionDefault !== NO_VALUE && newOptionDefault !== formValue) {
            if (oldOptionDefault === formValue) {
              removeOldSchemaData[key] = newOptionDefault;
            } else if (newKeyedSchema.readOnly === true) {
              removeOldSchemaData[key] = void 0;
            }
          }
          const newOptionConst = newKeyedSchema.const ?? NO_VALUE;
          const oldOptionConst = oldKeyedSchema.const ?? NO_VALUE;
          if (newOptionConst !== NO_VALUE && newOptionConst !== formValue) {
            removeOldSchemaData[key] = oldOptionConst === formValue ? newOptionConst : void 0;
          }
        }
      }
    });
    newFormData = {
      ...isDataObject ? data : void 0,
      ...removeOldSchemaData,
      ...nestedData
    };
  } else if (oldSchema.type === "array" && newSchema.type === "array" && Array.isArray(data)) {
    let oldSchemaItems = oldSchema.items;
    let newSchemaItems = newSchema.items;
    if (isSchemaObjectValue(oldSchemaItems) && isSchemaObjectValue(newSchemaItems)) {
      const newFormDataArray = sanitizeArrays(newSchema, retrieveIfNeeded(validator, merger, oldSchemaItems, rootSchema, data), retrieveIfNeeded(validator, merger, newSchemaItems, rootSchema, data), validator, merger, rootSchema, data);
      if (newFormDataArray !== NO_VALUE) {
        newFormData = newFormDataArray;
      }
    } else if (typeof oldSchemaItems === "boolean" && typeof newSchemaItems === "boolean" && oldSchemaItems === newSchemaItems) {
      newFormData = data;
    }
  }
  return newFormData;
}

// node_modules/@sjsf/form/dist/core/schema-transformer.js
function transformSchemaDefinition(schema, transform, ctx = { type: "root", path: [] }) {
  if (!isSchema(schema)) {
    return transform(schema, ctx);
  }
  const shallowCopy = {
    ...schema
  };
  for (const key of ARRAYS_OF_SUB_SCHEMAS) {
    const array2 = schema[key];
    if (array2 === void 0 || !Array.isArray(array2)) {
      continue;
    }
    const c2 = {
      type: "array",
      parent: schema,
      key,
      index: 0,
      path: ctx.path.concat(key, 0)
    };
    shallowCopy[key] = array2.map((item, index) => {
      c2.index = index;
      c2.path[c2.path.length - 1] = index;
      return transformSchemaDefinition(item, transform, c2);
    });
  }
  const map = /* @__PURE__ */ new Map();
  for (const key of RECORDS_OF_SUB_SCHEMAS) {
    const record = schema[key];
    if (record === void 0) {
      continue;
    }
    const c2 = {
      type: "record",
      parent: schema,
      key,
      property: "",
      path: ctx.path.concat(key, "")
    };
    for (const [property, value] of Object.entries(record)) {
      if (Array.isArray(value)) {
        continue;
      }
      c2.property = property;
      c2.path[c2.path.length - 1] = property;
      map.set(property, transformSchemaDefinition(value, transform, c2));
    }
    shallowCopy[key] = Object.fromEntries(map);
    map.clear();
  }
  const c = {
    type: "sub",
    parent: schema,
    key: "items",
    path: ctx.path.concat("")
  };
  for (const key of SUB_SCHEMAS) {
    const value = schema[key];
    if (value === void 0 || Array.isArray(value)) {
      continue;
    }
    c.key = key;
    c.path[c.path.length - 1] = key;
    shallowCopy[key] = transformSchemaDefinition(value, transform, c);
  }
  return transform(shallowCopy, ctx);
}

// node_modules/@sjsf/form/dist/core/prefix-schema-refs.js
function prefixSchemaRefs(schema, prefix) {
  return transformSchemaDefinition(schema, (node) => {
    if (!isSchema(node)) {
      return node;
    }
    const ref = node[REF_KEY];
    if (ref !== void 0 && ref.startsWith("#")) {
      node[REF_KEY] = `${prefix}${ref}`;
    }
    return node;
  });
}

// node_modules/@sjsf/form/dist/core/schema-hash.js
function hashString(string) {
  let hash = 0;
  for (let i = 0; i < string.length; i += 1) {
    const chr = string.charCodeAt(i);
    hash = (hash << 5) - hash + chr;
    hash = hash & hash;
  }
  return hash.toString(16);
}
function schemaHash(schema) {
  const allKeys = /* @__PURE__ */ new Set();
  JSON.stringify(schema, (key, value) => (allKeys.add(key), value));
  return hashString(JSON.stringify(schema, Array.from(allKeys).sort()));
}

// node_modules/@sjsf/form/dist/core/merger.js
var import_json_schema_merge_allof = __toESM(require_src2(), 1);
var defaultMerger = {
  mergeAllOf(schema) {
    return (0, import_json_schema_merge_allof.default)(schema, { deep: false });
  }
};

// node_modules/@sjsf/form/dist/core/schema-traverser.js
function makeSchemaDefinitionTraverser(keys, visitor) {
  return function* traverse(schema, ctx = { type: "root", path: [] }) {
    if (visitor.onEnter) {
      yield* visitor.onEnter(schema, ctx);
    }
    if (isSchema(schema)) {
      const fakeKey = "";
      const subCtx = {
        type: "sub",
        parent: schema,
        key: fakeKey,
        // @ts-expect-error
        path: ctx.path.concat(fakeKey)
      };
      const arrayCtx = {
        type: "array",
        parent: schema,
        key: fakeKey,
        index: 0,
        // @ts-expect-error
        path: ctx.path.concat(fakeKey, 0)
      };
      const recordCtx = {
        type: "record",
        parent: schema,
        key: fakeKey,
        property: "",
        // @ts-expect-error
        path: ctx.path.concat(fakeKey, "")
      };
      for (const key of keys) {
        if (isSubSchemaKey(key)) {
          const value = schema[key];
          if (value === void 0 || Array.isArray(value)) {
            continue;
          }
          subCtx.key = key;
          subCtx.path[subCtx.path.length - 1] = key;
          yield* traverse(value, subCtx);
        }
        if (isSubSchemasArrayKey(key)) {
          const array2 = schema[key];
          if (array2 === void 0 || !Array.isArray(array2)) {
            continue;
          }
          arrayCtx.key = key;
          arrayCtx.path[arrayCtx.path.length - 2] = key;
          for (let index = 0; index < array2.length; index++) {
            arrayCtx.index = index;
            arrayCtx.path[arrayCtx.path.length - 1] = index;
            yield* traverse(array2[index], arrayCtx);
          }
        }
        if (isSubSchemasRecordKey(key)) {
          const record = schema[key];
          if (record === void 0) {
            continue;
          }
          recordCtx.key = key;
          recordCtx.path[recordCtx.path.length - 2] = key;
          for (const property of Object.keys(record)) {
            const value = record[property];
            if (value === void 0 || Array.isArray(value)) {
              continue;
            }
            recordCtx.property = property;
            recordCtx.path[recordCtx.path.length - 1] = property;
            yield* traverse(value, recordCtx);
          }
        }
      }
    }
    if (visitor.onLeave) {
      yield* visitor.onLeave(schema, ctx);
    }
  };
}

// node_modules/@sjsf/form/dist/core/schema-value-traverser.js
function* traverseSchemaValue(value, visitor, ctx = { type: "root", path: [] }) {
  if (visitor.onEnter) {
    yield* visitor.onEnter(value, ctx);
  }
  if (Array.isArray(value)) {
    const c = {
      type: "array",
      index: 0,
      path: ctx.path.concat(0)
    };
    for (let index = 0; index < value.length; index++) {
      c.index = index;
      c.path[c.path.length - 1] = index;
      yield* traverseSchemaValue(value[index], visitor, c);
    }
  } else if (isObject(value)) {
    const c = {
      type: "record",
      key: "",
      path: ctx.path.concat("")
    };
    for (const key of Object.keys(value)) {
      c.key = key;
      c.path[c.path.length - 1] = key;
      yield* traverseSchemaValue(value[key], visitor, c);
    }
  }
  if (visitor.onLeave) {
    yield* visitor.onLeave(value, ctx);
  }
}

// node_modules/@sjsf/form/dist/core/path.js
function partsToPath(parts) {
  let parentIsArrayOfSubSchemas = false;
  return parts.map((p) => {
    if (parentIsArrayOfSubSchemas) {
      const num = Number(p);
      if (Number.isInteger(num) && num >= 0) {
        parentIsArrayOfSubSchemas = false;
        return num;
      }
    }
    parentIsArrayOfSubSchemas = SET_OF_ARRAYS_OF_SUB_SCHEMAS.has(p);
    return p;
  });
}
function refToPath(ref) {
  if (ref === "#") {
    return [];
  }
  const parts = ref.substring(2).split("/");
  return partsToPath(parts);
}
function getSchemaDefinitionByPath(rootSchema, schema, path) {
  for (let i = 0; i < path.length; i++) {
    if (schema === void 0 || !isSchema(schema)) {
      return void 0;
    }
    if (schema.$ref) {
      return getSchemaDefinitionByPath(rootSchema, resolveRef(schema.$ref, rootSchema), path.slice(i));
    }
    const alt = schema.anyOf ?? schema.oneOf ?? schema.allOf;
    if (alt) {
      const slice = path.slice(i);
      let def;
      let lastBool;
      for (const subSchema of alt) {
        if (!isSchema(subSchema)) {
          continue;
        }
        def = getSchemaDefinitionByPath(rootSchema, subSchema, slice);
        if (def === void 0) {
          continue;
        }
        if (isSchema(def)) {
          return def;
        }
        lastBool = def;
      }
      if (lastBool !== void 0) {
        return lastBool;
      }
    }
    const k = path[i];
    const type = getSimpleSchemaType(schema);
    if (type === "array") {
      const { items, additionalItems } = schema;
      schema = (Array.isArray(items) ? items[k] : items) ?? additionalItems;
      continue;
    }
    if (type === "object") {
      const { properties, patternProperties, additionalProperties } = schema;
      schema = (properties && properties[k]) ?? (patternProperties && Object.entries(patternProperties).find(([p]) => new RegExp(p).test(k))?.[1]) ?? additionalProperties;
      continue;
    }
    return void 0;
  }
  return schema;
}

// node_modules/@sjsf/form/dist/core/known-properties.js
function* getKnownProperties({ $ref: ref, properties, dependencies, oneOf, allOf, anyOf }, rootSchema, stack = /* @__PURE__ */ new Set()) {
  if (ref) {
    if (stack.has(ref)) {
      return;
    }
    stack.add(ref);
    const resolved = resolveRef(ref, rootSchema);
    if (isSchema(resolved)) {
      yield* getKnownProperties(resolved, rootSchema, stack);
    }
    return;
  }
  if (properties) {
    for (const key of Object.keys(properties)) {
      yield key;
    }
  }
  for (const alternatives of [oneOf, allOf, anyOf]) {
    if (Array.isArray(alternatives)) {
      for (const alternative of alternatives) {
        if (isSchema(alternative)) {
          yield* getKnownProperties(alternative, rootSchema, stack);
        }
      }
    }
  }
  if (dependencies !== void 0) {
    for (const dependency of Object.values(dependencies)) {
      if (!Array.isArray(dependency) && isSchema(dependency)) {
        yield* getKnownProperties(dependency, rootSchema, stack);
      }
    }
  }
}

export {
  REF_KEY,
  ID_KEY,
  DEFS_KEY,
  DEFINITIONS_KEY,
  PROPERTIES_KEY,
  ITEMS_KEY,
  DEPENDENCIES_KEY,
  REQUIRED_KEY,
  PATTERN_PROPERTIES_KEY,
  DEFAULT_KEY,
  CONST_KEY,
  IF_KEY,
  THEN_KEY,
  ELSE_KEY,
  CONTAINS_KEY,
  ALL_OF_KEY,
  ANY_OF_KEY,
  ONE_OF_KEY,
  NOT_KEY,
  ROOT_SCHEMA_PREFIX,
  ADDITIONAL_PROPERTY_FLAG,
  ADDITIONAL_PROPERTIES_KEY,
  ADDITIONAL_ITEMS_KEY,
  PROPERTY_NAMES_KEY,
  DISCRIMINATOR_KEY,
  PROPERTY_NAME_KEY,
  DATA_URL_FORMAT,
  RECORDS_OF_SUB_SCHEMAS,
  SET_OF_RECORDS_OF_SUB_SCHEMAS,
  ARRAYS_OF_SUB_SCHEMAS,
  SET_OF_ARRAYS_OF_SUB_SCHEMAS,
  SUB_SCHEMAS,
  SET_OF_SUB_SCHEMAS,
  SCHEMA_KEYS,
  isSchema,
  isSchemaWithProperties,
  isNormalArrayItems,
  isSubSchemaKey,
  isSubSchemasArrayKey,
  isSubSchemasRecordKey,
  typeOfValue,
  typeOfSchema,
  isNullableSchemaType,
  isSchemaNullable,
  pickSchemaType,
  getSimpleSchemaType,
  isPrimitiveSchemaType,
  isArrayOrObjectSchemaType,
  isObject,
  isSchemaObjectValue,
  isSchemaArrayValue,
  isSchemaValueEmpty,
  mergeSchemas,
  mergeDefaultsWithFormData,
  mergeSchemaObjects,
  resolveRef,
  findSchemaDefinition,
  getDiscriminatorFieldFromSchema,
  getOptionMatchingSimpleDiscriminator,
  weakMemoize,
  createAugmentSchema,
  AUGMENTED_SCHEMAS_CACHE,
  getFirstMatchingOption,
  calculateIndexScore,
  getClosestMatchingOption,
  isSchemaValueDeepEqual,
  isSchemaDeepEqual,
  retrieveSchema,
  resolveAllReferences,
  resolveReference,
  retrieveSchemaInternal,
  resolveCondition,
  stubExistingAdditionalProperties,
  resolveSchema,
  resolveDependencies,
  resolveAnyOrOneOfSchemas,
  processDependencies,
  withDependentSchema,
  withExactlyOneSubSchema,
  getAllPermutationsOfXxxOf,
  getMatchingPatternProperties,
  isSchemaOfConstantValue,
  getSchemaConstantValue,
  isSelect,
  getSelectOptionValues,
  isMultiSelect,
  isFixedItems,
  getDefaultValueForType,
  getDefaultFormState,
  computeDefaults,
  ensureFormDataMatchingSchema,
  AdditionalItemsHandling,
  getInnerSchemaForArrayItem,
  getDefaultBasedOnSchemaType,
  getObjectDefaults,
  getArrayDefaults,
  orderProperties,
  isAdditionalProperty,
  isFileSchema,
  isFilesArray,
  isSchemaExpandable,
  sanitizeDataForNewSchema,
  transformSchemaDefinition,
  prefixSchemaRefs,
  schemaHash,
  defaultMerger,
  makeSchemaDefinitionTraverser,
  traverseSchemaValue,
  partsToPath,
  refToPath,
  getSchemaDefinitionByPath,
  getKnownProperties
};
//# sourceMappingURL=chunk-L5BEN6GZ.js.map
